/************************************************************************
 *  File: pcie_diag.c
 *
 *  Sample user-mode diagnostics application for accessing PCIE
 *  devices using WinDriver's API.
 *  Code was generated by DriverWizard v10.21.
 *
 *  Jungo Confidential. Copyright (c) 2011 Jungo Ltd.  http://www.jungo.com
 *************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include "wdc_defs.h"
#include "wdc_lib.h"
#include "utils.h"
#include "status_strings.h"
#include "samples/shared/diag_lib.h"
#include "samples/shared/wdc_diag_lib.h"
#include "samples/shared/pci_regs.h"
#include "pcie_lib.h"


/*************************************************************
  General definitions
*************************************************************/
/* Error messages display */
#define PCIE_ERR printf

/*************************************************************
  Global variables
*************************************************************/
/* User's input command */
static CHAR gsInput[256];

/* --------------------------------------------------
   PCIE configuration registers information
   -------------------------------------------------- */
/* Configuration registers information array */
const WDC_REG gPCIE_CfgRegs[] = {
  { WDC_AD_CFG_SPACE, PCI_VID, WDC_SIZE_16, WDC_READ_WRITE, "VID", "Vendor ID" },
  { WDC_AD_CFG_SPACE, PCI_DID, WDC_SIZE_16, WDC_READ_WRITE, "DID", "Device ID" },
  { WDC_AD_CFG_SPACE, PCI_CR, WDC_SIZE_16, WDC_READ_WRITE, "CMD", "Command" },
  { WDC_AD_CFG_SPACE, PCI_SR, WDC_SIZE_16, WDC_READ_WRITE, "STS", "Status" },
  { WDC_AD_CFG_SPACE, PCI_REV, WDC_SIZE_32, WDC_READ_WRITE, "RID_CLCD", "Revision ID & Class Code" },
  { WDC_AD_CFG_SPACE, PCI_CCSC, WDC_SIZE_8, WDC_READ_WRITE, "SCC", "Sub Class Code" },
  { WDC_AD_CFG_SPACE, PCI_CCBC, WDC_SIZE_8, WDC_READ_WRITE, "BCC", "Base Class Code" },
  { WDC_AD_CFG_SPACE, PCI_CLSR, WDC_SIZE_8, WDC_READ_WRITE, "CALN", "Cache Line Size" },
  { WDC_AD_CFG_SPACE, PCI_LTR, WDC_SIZE_8, WDC_READ_WRITE, "LAT", "Latency Timer" },
  { WDC_AD_CFG_SPACE, PCI_HDR, WDC_SIZE_8, WDC_READ_WRITE, "HDR", "Header Type" },
  { WDC_AD_CFG_SPACE, PCI_BISTR, WDC_SIZE_8, WDC_READ_WRITE, "BIST", "Built-in Self Test" },
  { WDC_AD_CFG_SPACE, PCI_BAR0, WDC_SIZE_32, WDC_READ_WRITE, "BADDR0", "Base Address 0" },
  { WDC_AD_CFG_SPACE, PCI_BAR1, WDC_SIZE_32, WDC_READ_WRITE, "BADDR1", "Base Address 1" },
  { WDC_AD_CFG_SPACE, PCI_BAR2, WDC_SIZE_32, WDC_READ_WRITE, "BADDR2", "Base Address 2" },
  { WDC_AD_CFG_SPACE, PCI_BAR3, WDC_SIZE_32, WDC_READ_WRITE, "BADDR3", "Base Address 3" },
  { WDC_AD_CFG_SPACE, PCI_BAR4, WDC_SIZE_32, WDC_READ_WRITE, "BADDR4", "Base Address 4" },
  { WDC_AD_CFG_SPACE, PCI_BAR5, WDC_SIZE_32, WDC_READ_WRITE, "BADDR5", "Base Address 5" },
  { WDC_AD_CFG_SPACE, PCI_CIS, WDC_SIZE_32, WDC_READ_WRITE, "CIS", "CardBus CIS Pointer" },
  { WDC_AD_CFG_SPACE, PCI_SVID, WDC_SIZE_16, WDC_READ_WRITE, "SVID", "Sub-system Vendor ID" },
  { WDC_AD_CFG_SPACE, PCI_SDID, WDC_SIZE_16, WDC_READ_WRITE, "SDID", "Sub-system Device ID" },
  { WDC_AD_CFG_SPACE, PCI_EROM, WDC_SIZE_32, WDC_READ_WRITE, "EROM", "Expansion ROM Base Address" },
  { WDC_AD_CFG_SPACE, PCI_CAP, WDC_SIZE_8, WDC_READ_WRITE, "NEW_CAP", "New Capabilities Pointer" },
  { WDC_AD_CFG_SPACE, PCI_ILR, WDC_SIZE_32, WDC_READ_WRITE, "INTLN", "Interrupt Line" },
  { WDC_AD_CFG_SPACE, PCI_IPR, WDC_SIZE_32, WDC_READ_WRITE, "INTPIN", "Interrupt Pin" },
  { WDC_AD_CFG_SPACE, PCI_MGR, WDC_SIZE_32, WDC_READ_WRITE, "MINGNT", "Minimum Required Burst Period" },
  { WDC_AD_CFG_SPACE, PCI_MLR, WDC_SIZE_32, WDC_READ_WRITE, "MAXLAT", "Maximum Latency" },
};
#define PCIE_CFG_REGS_NUM sizeof(gPCIE_CfgRegs) / sizeof(WDC_REG)
/* TODO: For read-only or write-only registers, change the direction field of
   the relevant registers in gPCIE_CfgRegs to WDC_READ or WDC_WRITE. */
/* NOTE: You can define additional configuration registers in gPCIE_CfgRegs. */
const WDC_REG *gpPCIE_CfgRegs = gPCIE_CfgRegs;

/* -----------------------------------------------
   PCIE run-time registers information
   ----------------------------------------------- */
/* Run-time registers information array */
/* const WDC_REG gPCIE_Regs[]; */
const WDC_REG *gpPCIE_Regs = NULL;
/* TODO: You can remove the comment from the gPCIE_Regs array declaration and
   fill the array with run-time registers information for your device,
   in which case be sure to set gpPCIE_Regs to point to gPCIE_Regs. */
#define PCIE_REGS_NUM 0

/*************************************************************
  Static functions prototypes
*************************************************************/
/* -----------------------------------------------
   Main diagnostics menu
   ----------------------------------------------- */
static void MenuMain(WDC_DEVICE_HANDLE *phDev, WDC_DEVICE_HANDLE *phDev1, WDC_DEVICE_HANDLE *phDev2, 
		     WDC_DEVICE_HANDLE *phDev3, WDC_DEVICE_HANDLE *phDev4, WDC_DEVICE_HANDLE *phDev5,int min__, int max__);

/* static void MenuMain(WDC_DEVICE_HANDLE *phDev, WDC_DEVICE_HANDLE *phDev1, WDC_DEVICE_HANDLE *phDev2,  */
/* WDC_DEVICE_HANDLE *phDev3, WDC_DEVICE_HANDLE *phDev4, WDC_DEVICE_HANDLE *phDev5); */

/* -----------------------------------------------
   Device find, open and close
   ----------------------------------------------- */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId);
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot);
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot);
static void DeviceClose(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Read/write memory and I/O addresses
   ----------------------------------------------- */


/* -----------------------------------------------
    Read/write the configuration space
   ----------------------------------------------- */

/* ----------------------------------------------------
    Plug-and-play and power management events handling
   ---------------------------------------------------- */
static void MenuMBtest(WDC_DEVICE_HANDLE hDev,WDC_DEVICE_HANDLE hDev1 ,WDC_DEVICE_HANDLE hDev2,
		       WDC_DEVICE_HANDLE hDev3, WDC_DEVICE_HANDLE hDev4, WDC_DEVICE_HANDLE hDev5, int min__, int max__);

/* static void MenuMBtest(WDC_DEVICE_HANDLE hDev,WDC_DEVICE_HANDLE hDev1 ,WDC_DEVICE_HANDLE hDev2, */
/* WDC_DEVICE_HANDLE hDev3, WDC_DEVICE_HANDLE hDev4, WDC_DEVICE_HANDLE hDev5); */
static int pcie_send(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send);
static int pcie_rec(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static void *pt_sn_filewrite(void *nword_write);
void *pt_trig_dma(void *threadarg);
//vic
int nwrite_2;


//
//     data storage
//
static int buff_snova[4000000];
static int buff_trig [4000000];
static int snova_pointer;
static int trig_pointer;
static int snova_wcount;
static int trig_wcount;
static int fd_trig_pt;
static int fd_sn_pt;
static int fd_trig_pt_m;
static int fd_monitor_pt;
//
static int fd_trig_pt_tpc;
static int fd_sn_pt_tpc;
static int fd_trig_pt_m_tpc;
static int fd_monitor_pt_tpc;
//
static DWORD dwDMABufSize;
static int itrig_m_d, itrig_m, ith_fr;

//
//#define dwDMABufSize = 1000000;
//
//
//

#define  jbuf_ev_size 1000000
pthread_mutex_t mutexlock;
static int write_point_n, read_point_n, write_point_s, read_point_s;
static int write_point_n_tpc, read_point_n_tpc, write_point_s_tpc, read_point_s_tpc;
//static int buffer_wc_n[jbuf_ev_size], buffer_wc_s[jbuf_ev_size];
static int buffer_ev_n[jbuf_ev_size], buffer_ev_s[jbuf_ev_size];
static int buffer_ev_n_tpc[jbuf_ev_size], buffer_ev_s_tpc[jbuf_ev_size];

//
//  for PMT
//
    PVOID pbuf_rec_n1;
    WD_DMA *pDma_rec_n1;

    PVOID pbuf_rec_n2;
    WD_DMA *pDma_rec_n2;


    PVOID pbuf_rec_s;
    WD_DMA *pDma_rec_s;
    PVOID pbuf_rec_s1;
    WD_DMA *pDma_rec_s1;
    PVOID pbuf_rec_s2;
    WD_DMA *pDma_rec_s2;
    PVOID pbuf_rec_s3;
    WD_DMA *pDma_rec_s3;
    PVOID pbuf_rec_s4;
    WD_DMA *pDma_rec_s4;
//
//  for TPC
//
    PVOID pbuf_rec_n1_tpc;
    WD_DMA *pDma_rec_n1_tpc;

    PVOID pbuf_rec_n2_tpc;
    WD_DMA *pDma_rec_n2_tpc;


    PVOID pbuf_rec_s_tpc;
    WD_DMA *pDma_rec_s_tpc;
    PVOID pbuf_rec_s1_tpc;
    WD_DMA *pDma_rec_s1_tpc;
    PVOID pbuf_rec_s2_tpc;
    WD_DMA *pDma_rec_s2_tpc;
    PVOID pbuf_rec_s3_tpc;
    WD_DMA *pDma_rec_s3_tpc;
    PVOID pbuf_rec_s4_tpc;
    WD_DMA *pDma_rec_s4_tpc;

    PVOID pbuf_send_fake;
    WD_DMA *pDma_send_fake;
//

/*************************************************************
  Functions implementation
 *************************************************************/
/* int main(void) */
int main(int argc, char **argv)
{

  int min__ = atoi(argv[1]);
  int max__ = atoi(argv[2]);

  struct timeval start;
  gettimeofday(&start,NULL);

  long seconds, useconds;
  seconds = start.tv_sec;
  useconds = start.tv_usec;

  printf("\nStart time of program: %ld sec %ld usec\n",seconds,useconds);


    WDC_DEVICE_HANDLE hDev = NULL;
    WDC_DEVICE_HANDLE hDev1 = NULL;
    WDC_DEVICE_HANDLE hDev2 = NULL;
    WDC_DEVICE_HANDLE hDev3 = NULL;
    WDC_DEVICE_HANDLE hDev4 = NULL;
    WDC_DEVICE_HANDLE hDev5 = NULL;

    DWORD dwStatus;

    printf("\n");
    printf("PCIE diagnostic utility.\n");
    printf("Application accesses hardware using " WD_PROD_NAME ".\n");

    /* Initialize the PCIE library */
    dwStatus = PCIE_LibInit();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        PCIE_ERR("pcie_diag: Failed to initialize the PCIE library: %s",
            PCIE_GetLastErr());
        return dwStatus;
    }

    printf("Let me find devices...\n");
    /* Find and open a PCIE device (by default ID) */
    if (PCIE_DEFAULT_VENDOR_ID)
      hDev = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID);
    if (PCIE_DEFAULT_VENDOR_ID)
      hDev1 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID);
    /*
    if (PCIE_DEFAULT_VENDOR_ID)
      hDev2 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID);
    if (PCIE_DEFAULT_VENDOR_ID)
      hDev3 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID);
    */
    /*
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID);
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev1 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID+1);
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev2 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID+2);
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev3 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID+3);
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev4 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID+4);
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev5 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID+5);
    */    
    
    
    hDev3  = hDev;
    hDev5  = hDev1;


    /* Display main diagnostics menu for communicating with the device */
    /* MenuMain(&hDev, &hDev1, &hDev2, &hDev3, &hDev4, &hDev5); */
    MenuMain(&hDev, &hDev1, &hDev2, &hDev3, &hDev4, &hDev5,min__,max__);


    /* Perform necessary cleanup before exiting the program */
    if (hDev)
        DeviceClose(hDev);
        DeviceClose(hDev1);
        DeviceClose(hDev2);
        DeviceClose(hDev3);
        DeviceClose(hDev4);
        DeviceClose(hDev5);

    dwStatus = PCIE_LibUninit();
    if (WD_STATUS_SUCCESS != dwStatus)
        PCIE_ERR("pcie_diag: Failed to uninit the PCIE library: %s", PCIE_GetLastErr());
    
    return dwStatus;
}

/* -----------------------------------------------
    Main diagnostics menu
   ----------------------------------------------- */
/* Main menu options */
enum {
    MENU_MAIN_SCAN_PCI_BUS = 1,
    MENU_MAIN_FIND_AND_OPEN,
    MENU_MAIN_RW_ADDR,
    MENU_MAIN_RW_CFG_SPACE,
    MENU_MAIN_RW_REGS,
    MENU_MAIN_ENABLE_DISABLE_INT,
    MENU_MAIN_EVENTS,
    MENU_MAIN_MB_TEST, /* add new route for testing */
    MENU_MAIN_JSEBII_TEST, /* add new route for testing */
    MENU_MAIN_EXIT = DIAG_EXIT_MENU,
};

/* Main diagnostics menu */
static void MenuMain(WDC_DEVICE_HANDLE *phDev, WDC_DEVICE_HANDLE *phDev1, WDC_DEVICE_HANDLE *phDev2, 
		     WDC_DEVICE_HANDLE *phDev3, WDC_DEVICE_HANDLE *phDev4, WDC_DEVICE_HANDLE *phDev5,int min__,int max__)
  
/* static void MenuMain(WDC_DEVICE_HANDLE *phDev, WDC_DEVICE_HANDLE *phDev1, WDC_DEVICE_HANDLE *phDev2,  */
/* 		     WDC_DEVICE_HANDLE *phDev3, WDC_DEVICE_HANDLE *phDev4, WDC_DEVICE_HANDLE *phDev5) */
{

  MenuMBtest(*phDev, *phDev1, *phDev2, *phDev3, *phDev4, *phDev5,min__,max__);
  return;
}

/* -----------------------------------------------
   Device find, open and close
   ----------------------------------------------- */
/* Find and open a PCIE device */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId)
{
  WD_PCI_SLOT slot;
  
  if (!DeviceFind(dwVendorId, dwDeviceId, &slot))
    return NULL;
  
  return DeviceOpen(&slot);
}

/* Find a PCIE device */
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot)
{
  DWORD dwStatus;
  DWORD i, dwNumDevices;
  WDC_PCI_SCAN_RESULT scanResult;
  
  if (dwVendorId == 0)
    {
      if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwVendorId,
						"Enter vendor ID", TRUE, 0, 0))
        {
	  return FALSE;
        }
      
      if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwDeviceId,
						"Enter device ID", TRUE, 0, 0))
        {
	  return FALSE;
        }
    }
  
  BZERO(scanResult);
  dwStatus = WDC_PciScanDevices(dwVendorId, dwDeviceId, &scanResult);
  if (WD_STATUS_SUCCESS != dwStatus)
    {
      PCIE_ERR("DeviceFind: Failed scanning the PCI bus.\n"
	       "Error: 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      return FALSE;
    }
  
  dwNumDevices = scanResult.dwNumDevices;
  if (!dwNumDevices)
    {
      PCIE_ERR("No matching device was found for search criteria "
	       "(Vendor ID 0x%lX, Device ID 0x%lX)\n",
	       dwVendorId, dwDeviceId);
      
      return FALSE;
    }
  
  printf("\n");
  printf("Found %ld matching device%s [ Vendor ID 0x%lX%s, Device ID 0x%lX%s ]:\n",
	 dwNumDevices, dwNumDevices > 1 ? "s" : "",
	 dwVendorId, dwVendorId ? "" : " (ALL)",
	 dwDeviceId, dwDeviceId ? "" : " (ALL)");
  
  for (i = 0; i < dwNumDevices; i++)
    {
      printf("\n");
      printf("%2ld. Vendor ID: 0x%lX, Device ID: 0x%lX\n",
	     i + 1,
	     scanResult.deviceId[i].dwVendorId,
	     scanResult.deviceId[i].dwDeviceId);
      
      WDC_DIAG_PciDeviceInfoPrint(&scanResult.deviceSlot[i], FALSE);
    }
  printf("\n");
  
  if (dwNumDevices > 1)
    {
      sprintf(gsInput, "Select a device (1 - %ld): ", dwNumDevices);
      i = 0;
      if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&i,
						gsInput, FALSE, 1, dwNumDevices))
        {
	  return FALSE;
        }
    }
  
  *pSlot = scanResult.deviceSlot[i - 1];
  
  return TRUE;
}/* Find a PCIE device */

/* Open a handle to a PCIE device */
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot)
{
  WDC_DEVICE_HANDLE hDev;
  DWORD dwStatus;
  WD_PCI_CARD_INFO deviceInfo;
  
  /* Retrieve the device's resources information */
  BZERO(deviceInfo);
  deviceInfo.pciSlot = *pSlot;
  dwStatus = WDC_PciGetDeviceInfo(&deviceInfo);
  if (WD_STATUS_SUCCESS != dwStatus)
    {
      PCIE_ERR("DeviceOpen: Failed retrieving the device's resources information.\n"
	       "Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      return NULL;
    }
  
  /* NOTE: You can modify the device's resources information here, if
     necessary (mainly the deviceInfo.Card.Items array or the items number -
     deviceInfo.Card.dwItems) in order to register only some of the resources
     or register only a portion of a specific address space, for example. */
  
  /* Open a handle to the device */
  hDev = PCIE_DeviceOpen(&deviceInfo);
  if (!hDev)
    {
      PCIE_ERR("DeviceOpen: Failed opening a handle to the device: %s",
	       PCIE_GetLastErr());
      return NULL;
    }
  
  return hDev;
}/* Open a handle to a PCIE device */

/* Close handle to a PCIE device */
static void DeviceClose(WDC_DEVICE_HANDLE hDev)
{
  if (!hDev)
    return;
  
  if (!PCIE_DeviceClose(hDev))
    {
      PCIE_ERR("DeviceClose: Failed closing PCIE device: %s",
	       PCIE_GetLastErr());
    }
}/* Close handle to a PCIE device */



/* Read/write memory or I/O space address menu */
//static void MenuMBtest(WDC_DEVICE_HANDLE hDev, WDC_DEVICE_HANDLE hDev1 ,WDC_DEVICE_HANDLE hDev2, 
//		       WDC_DEVICE_HANDLE hDev3, WDC_DEVICE_HANDLE hDev4, WDC_DEVICE_HANDLE hDev5)
static void MenuMBtest(WDC_DEVICE_HANDLE hDev, WDC_DEVICE_HANDLE hDev1 ,WDC_DEVICE_HANDLE hDev2, 
		       WDC_DEVICE_HANDLE hDev3, WDC_DEVICE_HANDLE hDev4, WDC_DEVICE_HANDLE hDev5,int min__, int max__)
  
{
  
#include "wdc_defs.h"
#define poweroff      0x0
#define poweron       0x1
#define configure_s30 0x2
#define configure_s60 0x3
#define configure_cont 0x20
#define rdstatus      0x80
#define loopback        0x04
  
#define dcm2_run_off  254
#define dcm2_run_on   255
  
#define dcm2_online   2
#define dcm2_setmask  3
#define dcm2_offline_busy 4
#define dcm2_load_packet_a 10
#define dcm2_load_packet_b 11
#define dcm2_offline_load 9
#define dcm2_status_read 20
#define dcm2_led_sel     29
#define dcm2_buffer_status_read 30
#define dcm2_status_read_inbuf 21
#define dcm2_status_read_evbuf 22
#define dcm2_status_read_noevnt 23
#define dcm2_zero 12
#define dcm2_compressor_hold 31

#define dcm2_5_readdata 4
#define dcm2_5_firstdcm 8
#define dcm2_5_lastdcm  9
#define dcm2_5_status_read 5
#define dcm2_5_source_id 25
#define dcm2_5_lastchnl 24

#define dcm2_packet_id_a 25
#define dcm2_packet_id_b 26
#define dcm2_hitformat_a 27
#define dcm2_hitformat_b 28

#define part_run_off  254
#define part_run_on   255
#define part_online   2
#define part_offline_busy 3
#define part_offline_hold 4
#define part_status_read 20
#define part_source_id 25


#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  mb_cntrl_add     0x1
#define  mb_cntrl_test_on 0x1
#define  mb_cntrl_test_off 0x0
#define  mb_cntrl_set_run_on 0x2
#define  mb_cntrl_set_run_off 0x3
#define  mb_cntrl_set_trig1 0x4
#define  mb_cntrl_set_trig2 0x5
#define  mb_cntrl_load_frame 0x6
#define  mb_cntrl_load_trig_pos 0x7

#define  mb_feb_power_add 0x1
#define  mb_feb_conf_add 0x2
#define  mb_feb_pass_add 0x3

#define  mb_feb_lst_on          1
#define  mb_feb_lst_off         0
#define  mb_feb_rxreset         2
#define  mb_feb_align           3
#define  mb_feb_pll_reset       5


#define  mb_feb_adc_align       1
#define  mb_feb_a_nocomp        2
#define  mb_feb_b_nocomp        3
#define  mb_feb_blocksize       4
#define  mb_feb_timesize        5
#define  mb_feb_mod_number      6
#define  mb_feb_a_id            7
#define  mb_feb_b_id            8
#define  mb_feb_max             9

#define  mb_feb_test_source    10
#define  mb_feb_test_sample    11
#define  mb_feb_test_frame     12
#define  mb_feb_test_channel   13
#define  mb_feb_test_ph        14
#define  mb_feb_test_base      15
#define  mb_feb_test_ram_data  16

#define  mb_feb_a_test         17
#define  mb_feb_b_test         18

#define  mb_feb_rd_status      20

#define  mb_feb_a_rdhed        21
#define  mb_feb_a_rdbuf        22
#define  mb_feb_b_rdhed        23
#define  mb_feb_b_rdbuf        24

#define  mb_feb_read_probe     30
#define  mb_feb_dram_reset     31
#define  mb_feb_adc_reset      33

#define  mb_a_buf_status       34
#define  mb_b_buf_status       35
#define  mb_a_ham_status       36
#define  mb_b_ham_status       37

#define  mb_feb_a_maxwords     40
#define  mb_feb_b_maxwords     41

#define  mb_feb_hold_enable    42

#define  mb_feb_tpc_load_threshold   100
#define  mb_feb_tpc_load_baseline    164
//#define  mb_feb_tpc_load_presample   230
//#define  mb_feb_tpc_load_postsample  231
#define  mb_feb_tpc_sel_combase     232
//#define  mb_feb_tpc_sel_comthres    233
#define  mb_feb_tpc_load_combase   234
#define  mb_feb_tpc_load_comthres   235
//#define  mb_feb_tpc_sel_bipolar   236

#define  mb_feb_tpc_load_thr_mean   164
#define  mb_feb_tpc_load_thr_vari   165
#define  mb_feb_tpc_load_common_thr 166
#define  mb_feb_tpc_sel_bipolar     167
#define  mb_feb_tpc_load_presample  168
#define  mb_feb_tpc_load_postsample 169
#define  mb_feb_tpc_sel_comthres    170

#define  mb_pmt_adc_reset       1
#define  mb_pmt_spi_add         2
#define  mb_pmt_adc_data_load   3

#define  mb_xmit_conf_add 0x2
#define  mb_xmit_pass_add 0x3

#define  mb_xmit_modcount 0x1
#define  mb_xmit_enable_1 0x2
#define  mb_xmit_enable_2 0x3
#define  mb_xmit_test1 0x4
#define  mb_xmit_test2 0x5

#define   mb_xmit_testdata  10

#define  mb_xmit_rdstatus 20
#define  mb_xmit_rdcounters 21
#define  mb_xmit_link_reset    22
#define  mb_opt_dig_reset   23
#define  mb_xmit_dpa_fifo_reset    24
#define  mb_xmit_dpa_word_align    25
#define  mb_xmit_link_pll_reset    26

#define  mb_trig_run                1
#define  mb_trig_frame_size         2
#define  mb_trig_deadtime_size      3
#define  mb_trig_active_size        4
#define  mb_trig_delay1_size        5
#define  mb_trig_delay2_size        6
#define  mb_trig_enable             7

#define  mb_trig_calib_delay        8

#define  mb_trig_prescale0         10
#define  mb_trig_prescale1         11
#define  mb_trig_prescale2         12
#define  mb_trig_prescale3         13
#define  mb_trig_prescale4         14
#define  mb_trig_prescale5         15
#define  mb_trig_prescale6         16
#define  mb_trig_prescale7         17
#define  mb_trig_prescale8         18

#define  mb_trig_mask0             20
#define  mb_trig_mask1             21
#define  mb_trig_mask2             22
#define  mb_trig_mask3             23
#define  mb_trig_mask4             24
#define  mb_trig_mask5             25
#define  mb_trig_mask6             26
#define  mb_trig_mask7             27
#define  mb_trig_mask8             28

#define  mb_trig_rd_param          30
#define  mb_trig_pctrig            31
#define  mb_trig_rd_status         32
#define  mb_trig_reset             33
#define  mb_trig_calib             34
#define  mb_trig_rd_gps            35

#define  mb_trig_sel1              40
#define  mb_trig_sel2              41
#define  mb_trig_sel3              42
#define  mb_trig_sel4              43

#define  mb_trig_p1_delay          50
#define  mb_trig_p1_width          51
#define  mb_trig_p2_delay          52
#define  mb_trig_p2_width          53
#define  mb_trig_p3_delay          54
#define  mb_trig_p3_width          55
#define  mb_trig_pulse_delay       58
#define  mb_trig_output_select     59

#define  mb_trig_pulse1            60
#define  mb_trig_pulse2            61
#define  mb_trig_pulse3            62

#define  mb_trig_frame_trig        63

#define  mb_trig_frame_trig_frm    83
#define  mb_trig_frame_trig_div    84

#define  mb_shaper_pulsetime        1
#define  mb_shaper_dac              2
#define  mb_shaper_pattern          3
#define  mb_shaper_write            4
#define  mb_shaper_pulse            5
#define  mb_shaper_entrig           6

#define  mb_feb_pmt_gate_size      47
#define  mb_feb_pmt_beam_delay     48
#define  mb_feb_pmt_beam_size      49

#define  mb_feb_pmt_ch_set         50
#define  mb_feb_pmt_delay0         51
#define  mb_feb_pmt_delay1         52
#define  mb_feb_pmt_precount       53
#define  mb_feb_pmt_thresh0        54
#define  mb_feb_pmt_thresh1        55
#define  mb_feb_pmt_thresh2        56
#define  mb_feb_pmt_thresh3        57
#define  mb_feb_pmt_width          58
#define  mb_feb_pmt_deadtime       59
#define  mb_feb_pmt_window         60
#define  mb_feb_pmt_words          61
#define  mb_feb_pmt_cos_mul        62
#define  mb_feb_pmt_cos_thres      63
#define  mb_feb_pmt_mich_mul       64
#define  mb_feb_pmt_mich_thres     65
#define  mb_feb_pmt_beam_mul       66
#define  mb_feb_pmt_beam_thres     67
#define  mb_feb_pmt_en_top         68
#define  mb_feb_pmt_en_upper       69
#define  mb_feb_pmt_en_lower       70
#define  mb_feb_pmt_blocksize      71

#define  mb_feb_pmt_test           80
#define  mb_feb_pmt_clear          81
#define  mb_feb_pmt_test_data      82
#define  mb_feb_pmt_pulse          83

#define  mb_feb_pmt_rxreset        84
#define  mb_feb_pmt_align_pulse    85
#define  mb_feb_pmt_rd_counters    86

#define  dma_buffer_size        40000000
  
  static DWORD dwAddrSpace;
  
  static UINT32 u32Data;
  static unsigned short u16Data;
  static unsigned long long u64Data, u64Data1;
  static DWORD dwOffset;
  static long imod,ichip;
  unsigned short *buffp;
  
  
  //vic
  char title1[100];
  char title[100];
  //vic
  
  /*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
  */
  static UINT32 i,j,k,ifr,nread,iprint,iwrite,ik,il,is,checksum;
  static UINT32 istop,newcmd,irand,ioffset,kword,lastchnl,ib;
  static UINT32 send_array[40000],read_array[dma_buffer_size],read_array1[40000];
  static UINT32 read_array_c[40000];
  static UINT32 read_comp[8000];
  static UINT32 nmask,index,itmp,nword_tot,nevent,iv,ijk,islow_read;
  static UINT32 imod_p,imod_trig,imod_shaper;
  unsigned short idcm_read_array[40000],read_array_s[1600000];
  static UINT32 idcm_read_array32[40000];
  static UINT32 idcm_send_array[400000];
  static UINT32 idcm_verify_array[400000];
  static int icomp_l,comp_s,ia,ic,ihuff,sample_b,dis;
  UINT32 *idcm_send_p,*idcm_verify_p,*pbuffp_rec;
  //    DWORD dwDMABufSize;
  PVOID pbuf;
  WD_DMA *pDma;
  DWORD dwStatus;
  DWORD dwOptions = DMA_FROM_DEVICE;
  UINT32 iread,icheck,izero;
  UINT32 buf_send[40000];
  static int   count,num,counta,nword,ireadback,nloop,ierror;
  static int   ij,nsend,iloop,inew,idma_readback,iadd,jevent;
  static int   itest,iframe,irun,ichip_c,dummy1,itrig_c;
  static int  idup,ihold,idouble,ihold_set,istatus_read;
  static int  idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
  static int   timesize,ipulse,ibase,a_id,itrig_delay;
  static int   iset,ncount,nsend_f,nwrite,itrig_ext;
  static int   imod_xmit,idiv,isample;
  static int   iframe_length, itrig,idrift_time,ijtrig;
  static int   idelay0, idelay1, threshold0, threshold1, pmt_words;
  static int   cos_mult, cos_thres, en_top, en_upper, en_lower;
  static int   irise, ifall, istart_time, use_pmt, pmt_testpulse;
  static int   ich_head, ich_sample, ich_frm,idebug,ntot_rec,nred;
  static int   ineu,ibusy_send,ibusy_test,ihold_word,ndma_loop;
  static int   irawprint, nwrite_byte,idis_c,idis_c1;
  static int   icomp_index, nword_comp, nk, ilast_check;
  static int   ic_ev, ic_fr, event_save, frame_save,frame_ev,event_ev;
  static int   imod_fem, imod_st, imod_last, itrig_type, last_dma_loop_size;
  static int   fd, n_read, n_write, pt_trig_wdone, pt_snova_wdone;
  static int   pt_trig_dmastart;
  static int   nremain, nread_dma,nremain_tran1, nremain_tran2,ig, nremain_dma;
  static int   rc_pt, nword_n, nwrite_byte_n, is1, event_head[100];
  static int   wait_min, wait_max;
  static int   iwait_usec,iwait_loop;
  static int   icom_factor,ifr_c2;
  static int   pmt_dac_scan,idac_shaper;
  static int   itrig_pulse,p1_delay,p1_width,p2_delay,p2_width, pulse_trig_delay;
  static int   icont,ibytec,n_trig, imulti,isuper, ipr_trig, imonitor;
  static int   ipmt_read, itpc_read, itpc_adc, imod_xmit_tpc, imod_st_tpc,imod_last_tpc;
  static int   islope, iwidth, ibeg, izero_sup, istart, istart_old;
  static int   iround, idir;
  static int   icount, idiff, adc_v;
  static int   ifake_kazu;
  static int   frame_trig_sample, frame_trig_div;
  //
  struct timeval start;
  
  
  static int fd_sn;
  //
  void *status_pt;
  size_t stacksize;
  //
  //
  pthread_t threads[3];
  //
  pthread_attr_t attr_pt_trig_dma, attr_pt_sn_dma;
  pthread_attr_t attr_pt_tr, attr_pt_sn;
  //
  pthread_attr_t attr_pt_trig_dma_tpc, attr_pt_sn_dma_tpc;
  pthread_attr_t attr_pt_tr_tpc, attr_pt_sn_tpc;
  //
  pthread_attr_t attr_pt_tr_m, attr_pt_trig_dma_m;
  pthread_attr_t attr_pt_fake;
  
  //
  unsigned char    charchannel;
  unsigned char    carray[4000];
  struct timespec tim, tim2;
  tim.tv_sec = 0;
  //    tim.tv_nsec =128000;
  tim.tv_nsec =172000; // extend the delay for 12 MHz clock
  
  PVOID pbuf_rec;
  WD_DMA *pDma_rec;
  PVOID pbuf_rec1;
  WD_DMA *pDma_rec1;
  PVOID pbuf_rec2;
  WD_DMA *pDma_rec2;
  
  //    PVOID pbuf_rec_n;
  //    WD_DMA *pDma_rec_n;
  
  DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_CACHE;
  //    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_CACHE | DMA_ALLOW_64BIT_ADDRESS;
  DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_64BIT_ADDRESS;
  
  static UINT64 *buffp_rec64;
  static UINT32 *buffp_rec32, *buffp_rec32_n;
  static UINT32 *buffp_send;
  UINT32 *px, *py, *py1;
  
  FILE *outf,*inpf,*outfile,*pFilee;
  
  struct thread_data
  {
    int id;
    WDC_DEVICE_HANDLE hdev;
    WDC_DEVICE_HANDLE hdevc;
  };
  
  struct thread_data thread_data_n;
  struct thread_data thread_data_sn;
  //
  struct thread_data thread_data_n_tpc;
  struct thread_data thread_data_sn_tpc;
  //
  struct thread_data thread_data_n_m;
  
  nread = 4096*2+6; /*16384 32768, 65536+4;  number of byte to be readout */
  ifr=0;
  iwrite =0;
  iprint =0;
  icheck =0;
  istop=0;
  
  printf("Input the command code for test......\n");
  
  printf("     (1) SuperNova readout test -- 2 buffer mode \n");
  printf("     (2) SuperNova readout test -- multiple boards \n");
  printf("     (3) Neutrino event readout -- multiple baotrds \n");
  printf("     (4) Dev1 -- Neutrino event readout -- multiple baotrds \n");
  printf("     (5) SuperNova readout test -- thread \n");
  
  //    scanf("%d",&newcmd);
  newcmd =1; // Jose: choose case 1
  switch(newcmd) {
    
    
    dwDMABufSize = 1000000;
    
    
  case 1:
    
    pFilee = fopen("sn_tester_20160127.txt","a");
    
    printf(" SuperNova readout test \n");
    printf(" enable number of loop\n");
    /* scanf("%d",&nloop); */
    nloop = 1;
    //     printf(" enter 1 to turn on huffman encoding \n");
    //     scanf("%d",&ihuff);
    
    //vic
    ihuff = 1;
    //     printf("tyep 1 to compare with the 1st event\n");
    //     scanf("%d",&comp_s);
    printf("type 1 for print out debug information in dma loop\n");
    /* scanf("%d",&idebug); */
    
    idebug = 0;
    /* printf("type 1 for raw data print \n"); */
    /* scanf("%d",&irawprint); */
    irawprint = 0;
    /* printf(" enter buffer size in bytes \n"); */
    /* scanf("%d",&dwDMABufSize); */
    
    
    //     printf(" 1 for checking the event \n");
    //     scanf("%d",&icheck);
    //     printf(" type 1 to use random number \n");
    //     scanf("%d",&irand);
    icheck =0;
    ifr=0;
    irand = 0;
    islow_read =0;
    //     if(icheck != 1) {
    //      printf(" 1 for print event\n");
    //      scanf("%d",&iprint);
    //    }
    //     else iprint =0;
    iprint = 1;
    //     printf(" number event \n");
    //     scanf("%d",&nevent);
    
    //     printf(" enter number of words per packet \n");
    //     scanf("%d",&nsend);
    nsend=500;
    /* imod_xmit=8; */
    /* imod_fem =9; */
    
    
    imod_xmit=6;
    imod_fem =7;
    
    // once the fpga is booted we should let system receive fill frame before send any data.
    // set system with normal transmitter mode
    
    dwAddrSpace =2;
    u32Data = 0x20000000;    // initial transmitter, no hold
    dwOffset = 0x18;
    WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
    dwAddrSpace =2;
    u32Data = 0x20000000;    // initial transmitter, no hold
    dwOffset = 0x20;
    WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
    
    dwAddrSpace =2;
    u32Data = 0x20000000;    // initial receiver
    dwOffset = 0x1c;
    WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
    dwAddrSpace =2;
    u32Data = 0x20000000;   // initial receiver
    dwOffset = 0x24;
    WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
    
    
    dwAddrSpace =2;
    u32Data = 0xfff;    // set mode off with 0xfff...
    dwOffset = 0x28;
    WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
    
    //
    //
    //
    px = &buf_send;
    py = &read_array;
    imod =0;  /* controller module */
    /** initialize **/
    buf_send[0]=0x0;
    buf_send[1]=0x0;
    i=1;
    k=1;
    i = pcie_send(hDev3, i, k, px);
    // set offline test
    imod=0;
    ichip=1;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
    i=1;
    k=1;
    i = pcie_send(hDev3, i, k, px);
    //disable the run command
    imod=0;
    ichip=1;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //trun off run
    i=1;
    k=1;
    i = pcie_send(hDev3, i, k, px);
    // turn on the Stratix III power supply
    imod=imod_fem;
    ichip =1;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
    i=1;
    k=1;
    i = pcie_send(hDev3, i, k, px);
    usleep(200000);  // wait for 200 ms
    //     printf(" enable number of loop\n");
    //     scanf("%d",&nloop);
    for (j=0; j<nloop; j++) {
      usleep(10000); // wait for 10ms
      
      //
      //    boot up xmit module 1st
      //
      printf(" boot xmit module \n");
      //inpf = fopen("/home/ub/xmit_fpga_link_header","r");
      inpf = fopen("/home/kterao/local152_code/xmit_fpga_link_header","r");
      imod=imod_xmit;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      //      for (i=0; i<100000; i++) {
      //          ik= i%2;
      //          dummy1= (ik+i)*(ik+i);
      //      }
      
      
      /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
	carray[count] = charchannel;
	count++;
	counta++;
	if((count%(nsend*2)) == 0) {
	  //        printf(" loop = %d\n",dummy1);
	  buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
	  send_array[0] =buf_send[0];
	  if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
				  ,carray[2], carray[3]);
	  for (ij=0; ij< nsend; ij++) {
	    if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
	    else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
	    //         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
	    send_array[ij+1] = buf_send[ij+1];
	  }
	  nword =nsend+1;
	  i=1;
	  //       if(dummy1 == 0)
	  ij = pcie_send(hDev3, i, nword, px);
	  nanosleep(&tim , &tim2);
	  dummy1 = dummy1+1;
	  count =0;
	}
      }
      if(feof(inpf)) {
	printf("You have reached the end-of-file word count= %d %d\n", counta, count);
	buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
	if ( count > 1) {
	  if( ((count-1)%2) ==0) {
	    ik =(count-1)/2;
	  }
	  else {
	    ik =(count-1)/2+1;
	  }
	  ik=ik+2;   // add one more for safety
	  printf("ik= %d\n",ik);
	  for (ij=0; ij<ik; ij++){
	    if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
	    else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
	    send_array[ij+1] = buf_send[ij+1];
	  }
	}
	else ik=1;
	
	for (ij=ik-10; ij< ik+1; ij++) {
	  printf("Last data = %d, %x\n",ij,buf_send[ij]);
	}
	
	nword =ik+1;
	i=1;
	i = pcie_send(hDev3, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
      //
      printf(" xmit done, booting FEM \n");
      /* scanf("%d",&ik); */
      
      //
      //    Boot stratix after XMIT module
      //
      
      /* inpf = fopen("/home/ub/feb_fpga_test_new_head_zero","r"); */
      //vic
      /* inpf = fopen("/home/ub/feb_tpc_fpga_sn_zero_test","r"); */
      //inpf = fopen("/home/ub/module1x_140820_deb_1_25_2016.rbf","r"); // Chi's new FPGA code (Jan 25, 2016)
      //inpf = fopen("/home/kterao/local152_code/feb_tpc_fpga_sn_zero_test","r");
      inpf = fopen("/home/davidc1/firmware/module1x_140820_deb_3_21_2016.rbf","r");
      imod = imod_fem;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      //      for (i=0; i<100000; i++) {
      //          ik= i%2;
      //          dummy1= (ik+i)*(ik+i);
      //      }
      
      
      /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
	carray[count] = charchannel;
	count++;
	counta++;
	if((count%(nsend*2)) == 0) {
	  //        printf(" loop = %d\n",dummy1);
	  buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
	  send_array[0] =buf_send[0];
	  if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
				  ,carray[2], carray[3]);
	  for (ij=0; ij< nsend; ij++) {
	    if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
	    else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
	    //         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
	    send_array[ij+1] = buf_send[ij+1];
	  }
	  nword =nsend+1;
	  i=1;
	  //       if(dummy1 == 0)
	  ij = pcie_send(hDev3, i, nword, px);
	  nanosleep(&tim , &tim2);
	  dummy1 = dummy1+1;
	  count =0;
	}
      }
      if(feof(inpf)) {
	printf("You have reached the end-of-file word count= %d %d\n", counta, count);
	buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
	if ( count > 1) {
	  if( ((count-1)%2) ==0) {
	    ik =(count-1)/2;
	  }
	  else {
	    ik =(count-1)/2+1;
	  }
	  ik=ik+2;   // add one more for safety
	  printf("ik= %d\n",ik);
	  for (ij=0; ij<ik; ij++){
	    if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
	    else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
	    send_array[ij+1] = buf_send[ij+1];
	  }
	}
	else ik=1;
	
	for (ij=ik-10; ij< ik+1; ij++) {
	  printf("Last data = %d, %x\n",ij,buf_send[ij]);
	}
	
	nword =ik+1;
	i=1;
	i = pcie_send(hDev3, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
      //
      //    both FEM and XMIT bootted.
      //
      //
      //   /* set tx mode register */
      //
      u32Data = 0x00003fff;  // set up number of words hold coming back from the XMIT module
      printf(" number of words for hold be send back = %x\n",u32Data);
      dwOffset = 0x28;
      dwAddrSpace =2;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
      //
      //   set up hold
      //
      printf(" set up the hold condition \n");
      dwAddrSpace =2;
      u32Data = 0x8000000;    // set up transmitter to return the hold -- upper transciever
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x8000000;    // set up transmitter to return the hold -- lower transciever
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
      
      
      
      //
      //    start testing routine
      //
      printf(" enter 1 to reset the dram \n");
      /* scanf("%d",&ik); */
      //      ik =1;
      if(ik ==1) {
	imod=imod_fem;
	ichip=3;
	buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
	i=1;
	k=1;
	i = pcie_send(hDev3, i, k, px);
	imod=imod_fem;
	ichip=3;
	buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
	i=1;
	k=1;
	i = pcie_send(hDev3, i, k, px);
	
	usleep(5000);    // wait for 5 ms for DRAM to be initialized
	
	imod=imod_fem;
	ichip=3;
	buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
	i=1;
	k=1;
	i = pcie_send(hDev3, i, k, px);
	
	
      }
      //       printf(" enter 1 to read system status \n");
      //       scanf("%d",&ik);
      ik=1;
      nword =1;
      if(ik ==1) {
	
	
	i = pcie_rec(hDev3,0,1,nword,iprint,py);     // init the receiver
	
	imod=imod_fem;
	ichip=3;
	buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
	i=1;
	k=1;
	i = pcie_send(hDev3, i, k, px);
	py = &read_array;
	i = pcie_rec(hDev3,0,2,nword,iprint,py);     // read out 2 32 bits words
	printf("receive data word = %x, %x \n", read_array[0], read_array[1]);
      }
      //       printf(" enter L1 trigger delay \n");
      //       scanf("%d",&itrig_delay);
      itrig_delay = 51;
      nword =1;
      //
      // set to use test generator 2, set test =2
      //
      imod=imod_fem;
      ichip=mb_feb_pass_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x2<<16);  // set test source to 2
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      //
      // set frame set to be 255 --- there will be 256/8 = 32 adc samples.
      //
      imod=0;
      ichip=1;
      iframe= 8191;    //1023
      /* iframe= 25599;    //1023 */
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      
      
      //
      // load trig 1 position relative to the frame..
      //
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      //
      //    start loading the test 2 data memory
      //
      imod =imod_fem;
      iround =0;
      idir =1;
      
      
      
      
      sprintf(title1,"joses_data_01272016_min_%d_max_%d.txt",min__,max__);       
      outfile = fopen(title1, "w");
      
      
      ichip=3;
      for (is=0; is<64; is++) {
        ik = 0x4000+is;                        // load channel address
        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); // load channe address
        i = pcie_send(hDev3, 1, 1, px);
        ibase = is+1;    // set the base value of the ADC data
	//        printf("channel = %d, ibase = %x\n", is,ibase);
	//        scanf("%d", &ijk);
        for (ik=0; ik< 256; ik++) {
	  //         if((ik > ibeg) && (ik <= (ibeg+iwidth))) {
	  //           ijk= ibase+(ik-ibeg)*islope;
	  //         }
	  //         else ijk=ibase;
	  if(iround == 3) idir =-1;
	  if(iround == 0) idir = 1;
	  iround = iround + idir;
	  ijk= ibase + iround;
	  
	  /* if( (ik >= min__) && (ik <= max__) ) ijk=300+ibase; */
	  if( (ik >= 254) || (ik <= 5) ) ijk=300+ibase;
	  
	  //if( (ik > 240) & (ik <247)) ijk=300+ibase;
	  
	  
	  if(ik == 0) fprintf(outfile,"Channel %d fake data\n", is);
	  fprintf(outfile,"\t%4d",ijk);
	  if(((ik+1)%16)==0) fprintf(outfile,"\n");	     
	  
	  /* } */
	  
	  
	  /* //         if ((ik>247)) ijk=300+ibase; */
	  //if(is%4 == 0) {
	  //           if(ik == 0) printf(" channel %d fake data \n",is);
	  //printf(" %4d", ijk);
	  //if(((ik+1)%16)==0) printf("\n");
	  //}
	  k = 0x8000+ ijk;        // make sure bit 15-12 is clear for the data
	  //        printf("k = %x\n", k);
	  //        scanf("%d", &ijk);
	  buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); // load test data
	  i = pcie_send(hDev3, 1, 1, px);
	  send_array[is*256+ik]=ijk;           //load up data map
        }
      }
      ichip=3;
      if(ihuff == 1) buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x0<<16);  // turn the compression
      else buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x1<<16);  // set b channel no compression
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      //      }
      //
      //
      //
      ichip =3;
      printf(" loading zero suppression parameter \n");
      imod=imod_fem;
      for (ik=0; ik< 64; ik++) {
	
	ibase =ik+1;
	ijk=ik+10;     // threshold
	buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_tpc_load_threshold+ik)+((ijk & 0xffff)<< 16); // load threshold
	i = pcie_send(hDev3, 1, 1, px);
	usleep(10);
	
	//        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_tpc_load_baseline+ik)+((ibase & 0xffff)<< 16); // load baseline
	//        i = pcie_send(hDev3, 1, 1, px);
	//        usleep(10);
	//        buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_tpc_load_threshold+ik)+((ijk & 0xffff)<< 16); // load threshold
	//        i = pcie_send(hDev3, 1, 1, px);
	//        usleep(10);
      }
      ijk=2;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_tpc_load_presample)+((ijk & 0xffff)<< 16); // load preample
      i = pcie_send(hDev3, 1, 1, px);
      usleep(10);
      
      ijk=3;     //was 4
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_tpc_load_postsample)+((ijk & 0xffff)<< 16); // load postsample
      i = pcie_send(hDev3, 1, 1, px);
      usleep(10);
      //
      //      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_tpc_sel_combase)+((1 & 0xffff)<< 16); // channel baseline
      //       i = pcie_send(hDev3, 1, 1, px);
      //       usleep(10);
      //
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_tpc_sel_comthres)+((1 & 0xffff)<< 16); // channel threshold
      i = pcie_send(hDev3, 1, 1, px);
      usleep(10);
      //
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_tpc_sel_bipolar)+((0 & 0xffff)<< 16); // no biploar
      i = pcie_send(hDev3, 1, 1, px);
      usleep(10);
      //
      //
      ijk=10;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_tpc_load_thr_mean)+((ijk & 0xffff)<< 16); // load preample
      i = pcie_send(hDev3, 1, 1, px);
      usleep(10);
      
      ijk=100;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_tpc_load_thr_vari)+((ijk & 0xffff)<< 16); // load preample
      i = pcie_send(hDev3, 1, 1, px);
      usleep(10);

      
      imod=imod_fem;
      ichip=3;
      if(ihuff == 1) buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x0<<16);  // turn the compression
      else buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x1<<16);  // set b channel no compression
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      
      timesize =4;
      imod=imod_fem;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      
      a_id =0xf;
      imod=imod_fem;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set a_id
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      
      imod=imod_fem;
      ichip=4;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set a_id
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      //
      //     set max word in the pre-buffer memory
      //
      ik=8000;
      imod=imod_fem;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_max+(ik<<16);  // set pre-buffer max word
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      //
      //     enable hold
      //
      imod=imod_fem;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_hold_enable+(0x1<<16);  // enable the hold
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      
      //       imod=11;
      //       ichip=3;
      //       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_test+(0x1<<16);    // enable a test on
      //       i=1;
      //       k=1;
      //       if(islow_read == 1) i = pcie_send(hDev, i, k, px);
      
      
      imod=imod_fem;
      ichip=4;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x0<<16);    // set last module on
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      
      imod=imod_fem;
      ichip=4;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rxreset+(0x0<<16);    // reset LINKIN DPA
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      
      //
      //     set up xmit module  -- module count
      //
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_modcount+(0x0<<16);  // set number of module to 1 to enable output
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      //
      //     rest optical
      //
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_opt_dig_reset+(0x1<<16);  // set optical reset on
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      //
      //     enable superNova Token Passing
      //
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_2+(0x1<<16);  // enable token 1 pass
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      //
      //
      printf(" enter 1 to reset the DPA \n");
      /* scanf("%d",&ik); */
      
      //
      //     reset XMIT LINK IN DPA
      //
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      //
      //     wait for 10ms just in case
      //
      usleep(10000);
      printf(" XMIT FIFO reset \n");
      //
      //     reset XMIT FIFO reset
      //
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_fifo_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      
      //
      //
      //
      imod=imod_fem;
      printf(" reset the link PLL for module %x \n", imod);
      ichip=4;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pll_reset+(0x0<<16);    // reset LINKIN PLL
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      usleep(1000);   // give PLL time to reset
      
      //
      //
      //
      
      i = pcie_rec(hDev3,0,1,nword,iprint,py);     // init the receiver
      imod=imod_fem;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      py = &read_array;
      i = pcie_rec(hDev3,0,2,nword,iprint,py);     // read out 2 32 bits words
      if(iprint == 1) printf("FEM module %d status word after PLL reset = %x, %x \n", imod, read_array[0], read_array[1]);
      
      //
      //
      //       reset XMIT LINK IN DPA
      //
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_pll_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      usleep(1000);
      //
      //     reset XMIT LINK IN DPA
      //
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      //
      //     wait for 10ms just in case
      //
      usleep(10000);
      printf(" XMIT FIFO reset \n");
      //
      //     reset XMIT FIFO reset
      //
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_fifo_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      
      //
      //    set up last module to the module next to XMIT
      //
      imod=imod_fem;
      printf(" set last module on, module address %d\n", imod);
      ichip=4;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x0<<16);    // set last module on
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      
      
      //
      //      test re-align circuit
      //
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_word_align+(0x1<<16);  //  send alignment pulse
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      
      //        printf(" enter 1 to set continue on re-align circuit \n");
      //        scanf("%d",&ik);
      
      usleep(5000); //wait for 5 ms
      //      printf(" XMIT re-align done \n");
      //      scanf("%d",&ik);
      
      nword =1;
      
      i = pcie_rec(hDev3,0,1,nword,iprint,py);     // init the receiver
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod_xmit<<11)+(ichip<<8)+mb_xmit_rdstatus+(0x0<<16);  // read out status
      
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      py = &read_array;
      i = pcie_rec(hDev3,0,2,nword,iprint,py);     // read out 2 32 bits words
      printf("xmit status word = %x, %x \n", read_array[0], read_array[1]);
      
      
      
      printf(" finish XMIT alignment \n");
      /* scanf("%d",&ik); */
      //
      //
      //
      //
      
      //
      //
      
      
      usleep(5000); //wait for 5 ms
      printf(" XMIT re-align done \n");
      
      
      //       dwDMABufSize = 200000;
      dwDMABufSize = 200000;
      
      //      ndma_loop =(dma_buffer_size*4)/dwDMABufSize;  // set DMA loop for 100 M 32bits words
      ndma_loop =1;
      printf(" DMA will run %d loop\n", ndma_loop);
      ntot_rec=0;
      for (iv=0; iv<ndma_loop; iv++) {
        if(ifr ==0) {
	  //         ifr=1;
	  printf(" buffer allocation 1\n");
	  dwStatus = WDC_DMAContigBufLock(hDev5, &pbuf_rec1, dwOptions_rec, dwDMABufSize, &pDma_rec1);
	  if (WD_STATUS_SUCCESS != dwStatus) {
	    printf("Failed locking a rec 1 Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
	    printf("enter 1 to continue \n");
	    scanf("%d",&is);
	  }
	  else {
	    u32Data = pDma_rec1->Page->pPhysicalAddr & 0xffffffff;
	    printf(" buffer allocation lower address = %x\n", u32Data);
	    u32Data = (pDma_rec1->Page->pPhysicalAddr >> 32) & 0xffffffff;
	    printf(" buffer allocation higher address = %x\n", u32Data);
	  }
	  //         ifr=1;
	  printf(" buffer allocation 2\n");
	  dwStatus = WDC_DMAContigBufLock(hDev5, &pbuf_rec2, dwOptions_rec, dwDMABufSize, &pDma_rec2);
	  if (WD_STATUS_SUCCESS != dwStatus) {
	    printf("Failed locking a rec 2 Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
	    printf("enter 1 to continue \n");
	    /* scanf("%d",&is); */
	  }
	  else {
	    u32Data = pDma_rec2->Page->pPhysicalAddr & 0xffffffff;
	    printf(" buffer allocation 2 lower address = %x\n", u32Data);
	    u32Data = (pDma_rec2->Page->pPhysicalAddr >> 32) & 0xffffffff;
	    printf(" buffer allocation 2 higher address = %x\n", u32Data);
	  }
	  
	  /* set tx mode register */
	  
	  u32Data = 0x00001000;
	  dwOffset = tx_md_reg;
	  dwAddrSpace =cs_bar;
	  WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	  
	  /* write this will abort previous DMA */
	  dwAddrSpace =2;
	  dwOffset = cs_dma_msi_abort;
	  u32Data = dma_abort;
	  WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	  /* clear DMA register after the abort */
	  dwAddrSpace =2;
	  dwOffset = cs_dma_msi_abort;
	  u32Data = 0;
	  WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	  printf(" initial abort finished \n");
        }
	
        if((iv%2) == 0) buffp_rec32 = pbuf_rec1;
        else buffp_rec32 = pbuf_rec2;
	
	/* synch cache */
        if((iv%2) ==0) WDC_DMASyncCpu(pDma_rec1);
        else WDC_DMASyncCpu(pDma_rec2);
	
        printf(".");
        if(idebug ==1) printf(" synch CPU \n");
	///
	///    set up the DMA size  (half buffer size limit??)
	///
        nwrite =(dwDMABufSize/8);  //remove factor 2
	//       nwrite = 4000;
	
        for (is=1; is<3; is++) {
	  tr_bar = t1_tr_bar;
	  r_cs_reg = r1_cs_reg;
	  dma_tr = dma_tr1;
	  if(is == 2) {
	    tr_bar = t2_tr_bar;
	    r_cs_reg = r2_cs_reg;
	    dma_tr = dma_tr2;
	  }
	  if(idebug ==1) printf(" is = %d\n",is);
	  /** initialize the receiver ***/
	  u32Data = cs_init;
	  dwOffset = r_cs_reg;
	  dwAddrSpace =cs_bar;
	  //
	  // rreceiver only get initialize for the 1st time
	  //
	  if(ifr ==0) WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	  /** start the receiver **/
	  dwAddrSpace = cs_bar;
	  u32Data = cs_start+(nwrite*2)*4;   /* 32 bits mode == 4 bytes per word *2 fibers **/
	  dwOffset = r_cs_reg;
	  WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
        }
        if((ifr ==0) &&(idebug ==1)) printf(" initial receiver \n");
	//       scanf("%d",&ik);
	/** set up DMA for both transceiver together **/
	
        dwAddrSpace =cs_bar;
        dwOffset = cs_dma_add_low_reg;
        if((iv%2) == 0) u32Data = pDma_rec1->Page->pPhysicalAddr & 0xffffffff;
        else u32Data = pDma_rec2->Page->pPhysicalAddr & 0xffffffff;
        WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	
        dwAddrSpace =cs_bar;
        dwOffset = cs_dma_add_high_reg;
        if((iv%2) == 0) u32Data = (pDma_rec1->Page->pPhysicalAddr >> 32) & 0xffffffff;
        else u32Data = (pDma_rec2->Page->pPhysicalAddr >> 32) & 0xffffffff;
        WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	
	/* byte count */
        dwAddrSpace =cs_bar;
        dwOffset = cs_dma_by_cnt;
        u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
        WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	
	
	/* write this will start DMA */
        dwAddrSpace =2;
        dwOffset = cs_dma_cntrl;
        if((iv%2) == 0) is = (pDma_rec1->Page->pPhysicalAddr >> 32) & 0xffffffff;
        else is = (pDma_rec2->Page->pPhysicalAddr >> 32) & 0xffffffff;
        if(is == 0) {
          printf(" use 3dw \n");
          u32Data = dma_tr12+dma_3dw_rec;
        }
        else {
          u32Data = dma_tr12+dma_4dw_rec;
          printf(" use 4dw \n");
        }
        WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
        if(idebug ==1) printf(" DMA set up done \n");
	
        if(ifr ==0) {
	  ifr=1;
	  //
	  //      turn the run on to start data flow
	  //
	  printf(" enter 1 to set the RUN on \n");
	  scanf("%d",&ik);
	  
	  imod=0;
	  ichip=1;
	  buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
	  i=1;
	  k=1;
	  i = pcie_send(hDev3, i, k, px);
        }
	
	/***    check to see if DMA is done or not **/
        idone =0;
        for (is=0; is<60000000; is++) {;
	  /* for (is=0; is<300000; is++) {; */
          dwAddrSpace =cs_bar;
 	  u64Data =0;
	  dwOffset = cs_dma_cntrl;
          WDC_ReadAddr32(hDev5, dwAddrSpace, dwOffset, &u32Data);
	  if(idebug ==1) printf(" receive DMA status word %d %X \n", is, u32Data);
	  if((u32Data & dma_in_progress) == 0) {
            idone =1;
	    //            if(idebug ==1) printf(" receive DMA complete %d \n", i);
            printf(" receive DMA complete %d \n", is);
          }
	  if((u32Data & dma_in_progress) == 0) break;
        }
	
	//vic
	//DMA is complete !!!!
	
	
	dwAddrSpace =cs_bar;
	u64Data =0;
	dwOffset = t1_cs_reg;
	WDC_ReadAddr64(hDev5, dwAddrSpace, dwOffset, &u64Data);
	printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
	dwAddrSpace =cs_bar;
	u64Data =0;
	dwOffset = t2_cs_reg;
	WDC_ReadAddr64(hDev5, dwAddrSpace, dwOffset, &u64Data);
	printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
	
        if(idone == 0) {
	  //
	  dwAddrSpace =cs_bar;
	  u64Data =0;
	  dwOffset = t1_cs_reg;
	  WDC_ReadAddr64(hDev5, dwAddrSpace, dwOffset, &u64Data);
	  printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
	  dwAddrSpace =cs_bar;
	  u64Data =0;
	  dwOffset = t2_cs_reg;
	  WDC_ReadAddr64(hDev5, dwAddrSpace, dwOffset, &u64Data);
	  printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
	  //
	  printf(" loop %d, DMA is not finished \n", iv);
	  dwAddrSpace =cs_bar;
	  dwOffset = cs_dma_by_cnt;
	  WDC_ReadAddr32(hDev5, dwAddrSpace, dwOffset, &u32Data);
	  printf (" DMA word count = %x\n",u32Data);
	  
	  //
	  /* scanf("%d",&is); */
	  //         if((iv%2) == 0) WDC_DMASyncIo(pDma_rec1);
	  //         else WDC_DMASyncIo(pDma_rec2);
	  nred = (((nwrite)*4*2)-(u32Data))/4;
	  printf(" number of words received %d %d %d %d\n",nred, ntot_rec, iv, nwrite);
	  //scanf("%d",&is);
	  for (is=0; is<nred; is++) {
	    read_array[is+(iv*(nwrite*2))]= *buffp_rec32++;
	  }
	  ntot_rec = ntot_rec+nred;
	  //
	  //
	  //
	  u64Data =0;
	  dwOffset = t1_cs_reg;
	  WDC_ReadAddr64(hDev5, dwAddrSpace, dwOffset, &u64Data);
	  u32Data=u64Data>>32;
	  nremain_tran1 = u32Data;
	  printf(" enter 1 to contrinue %d %d %d\n", nremain_tran1, nwrite, nread_dma);
	  /* scanf("%d",&is); */
	  
	  if(iv%2 ==0) {
	    WDC_DMASyncCpu(pDma_rec1);
	    WDC_DMASyncIo(pDma_rec1);
	  }
	  else {
	    WDC_DMASyncCpu(pDma_rec2);
	    WDC_DMASyncIo(pDma_rec2);
	  }
	  
	  ik= (nwrite-nread_dma)/4;
	  
	  nremain = ((nwrite*8)-(nred*4))-nremain_tran1;
	  printf(" nremain = %d, nremain/4 = %d \n", nremain, nremain/4);
	  
	  printf(" enter 1 to contrinue %d %d %d\n", (nremain_tran1)&0xffffff, nwrite, nread_dma);
	  /* scanf("%d",&is); */

	  fprintf(pFilee, "%d,%d,%d\n",min__,(max__ - min__),0);
	  fclose(pFilee);
	  return;
	  
	  
	  for (ig=0; ig< ((nremain/8)+4); ig++) {
	    dwAddrSpace = t1_tr_bar;
	    u64Data =0;
	    dwOffset =0;
	    WDC_ReadAddr64(hDev5, dwAddrSpace, dwOffset, &u64Data);
	    u32Data =   (u64Data>> 32) & 0xffffffff;
	    read_array[ntot_rec+ig*2+1] = u32Data;
	    u32Data =   u64Data& 0xffffffff;
	    read_array[ntot_rec+ig*2] = u32Data;
	  }
	  ntot_rec = ntot_rec+ ((nremain/4)+8);
	  
	  /* write this will abort previous DMA */
	  dwAddrSpace =2;
	  dwOffset = cs_dma_msi_abort;
	  u32Data = dma_abort;
	  WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	  /* clear DMA register after the abort */
	  dwAddrSpace =2;
	  dwOffset = cs_dma_msi_abort;
	  u32Data = 0;
	  WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	  printf(" before abort, type 1 to continue\n");
	  scanf("%d",&is);
        }
        if(idone == 0) break;
	/* synch DMA i/O cache **/
	
	if((iv%2) == 0) WDC_DMASyncIo(pDma_rec1);
	else WDC_DMASyncIo(pDma_rec2);
	
	//
        if(idebug == 1) {
	  dwAddrSpace =cs_bar;
	  u64Data =0;
	  dwOffset = t1_cs_reg;
	  WDC_ReadAddr64(hDev5, dwAddrSpace, dwOffset, &u64Data);
	  printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
	  dwAddrSpace =cs_bar;
	  u64Data =0;
	  dwOffset = t2_cs_reg;
	  WDC_ReadAddr64(hDev5, dwAddrSpace, dwOffset, &u64Data);
	  printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
        }
	//
	//     copy of the data array
	//
	
	for (is=0; is<nwrite*2; is++) {
	  read_array[is+(iv*(nwrite*2))]= *buffp_rec32++;
        }
        ntot_rec = ntot_rec+(nwrite*2);
      }
      
      //vic - this may be slower, but we wait for read_array to be filled from the raw buffer returned from DMA
      sprintf(title,"joses_data_01272016_min_%d_max_%d.dat",min__,max__);
      fd_sn = creat(title,0755);
      printf("fd_sn = %d\n", fd_sn);
      nwrite_2 = write(fd_sn,read_array,dwDMABufSize);
      printf("\n\n\n\n\t==> Done writing the file: n_write2: %d !!!!!\n\n\n\n",nwrite_2);
      
      
      fprintf(pFilee,"%d,%d,%d\n",min__,(max__ - min__),1);
      fclose(pFilee);
      
      return;
      
      
      //
      //
      //
      //       if(irawprint ==1) {
      if(1) { // Jose: run this
	
	// hhhh: use this to decode file output
	
        for (is=0; is< ntot_rec; is++) {
	  if((is%8) ==0) printf("%4d",is);
	  if(((is%250000) ==0) && (is !=0)) {
	    printf(" type 1 to continue\n");
	    scanf("%d", &dummy1);
	  }
	  printf(" %8x",read_array[is]);
	  if(((is+1)%8) ==0 ) printf("\n");
        }
        if(((is+1)*8) != 0)printf("\n");
      }
      printf(" type 1 to continue\n");
      scanf("%d", &dummy1);
      //
      //     
      ik=0;
      for (is=0; is< ntot_rec; is++) {
        if(read_array[is] == 0xffffffff) {
	  event_head[ik] =is;
	  ik= ik+1;
	  printf(" event %d header at %d\n", ik-1,is);
        }
        read_array_s[is*2] = (read_array[is] & 0xffff);
        read_array_s[is*2+1] = (read_array[is] >> 16) & 0xffff;
      }
      printf(" type 1 to continue\n");
      scanf("%d", &dummy1);
      
      //
      //
      for (is=0; is< ik-1; is++) {
        i= event_head[is];
        printf(" header word = %x, %x, %x, %x, %x, %x, %x \n", read_array[i], read_array[i+1],
	       read_array[i+2], read_array[i+3], read_array[i+4], read_array[i+5],read_array[i+6]);
        for (ij= (i+7)*2; ij< (event_head[is+1]-1)*2; ij++) {
	  ijk = read_array_s[ij];
	  //         printf(" data = %x \n", ijk);
	  //         scanf("%d", &dummy1);
	  if((ijk & 0xf000) == 0x4000) {
	    printf(" \n ** channel word, frame = %x, channel = %x \n", ((ijk>>6) & 0x3f), (ijk & 0x3f));
	  }
	  else if ((ijk & 0xf000) == 0x1000) {
	    printf("    packet time = %x \n", (ijk & 0xfff));
	    il=0;
	  }
	  else if ((ijk & 0xf000) == 0x3000) {
	    printf(" %x ****\n", (ijk & 0xfff));
	  }
	  else if ((ijk & 0x8000) == 0x8000) {
	    i = ijk & 0x7fff;
	    icount =0;
	    ib=0;
	    for (il=0; il< 15; il++) {
	      ia = (i>> il) & 0x1;
	      ic = (i>>(il+1)) & 0x1;
	      if((ib==1) & (ia== 0)) icount = icount+1;
	      //           printf(" il = %d, ia = %d, ib= %d, ic= %d, icount = %d \n", il, ia, ib, ic, icount);
	      //           scanf("%d", &dummy1);
	      if(((ic==1) & ((ia==1) | (ib==1))) | (il ==14)) {
		if(icount ==0) idiff =0;
		else if(icount ==1) idiff = -1;
		else if(icount ==2) idiff = 1;
		else if(icount ==3) idiff = -2;
		else if(icount ==4) idiff = 2;
		else printf(" huffman error \n");
		adc_v = adc_v + idiff;
		icount=0;
		ib=0;
		printf(" %x", adc_v);
	      }
	      if(il == 14) break;
	      if(ia == 1) ib=1;
	      //           printf(" %x", ijk);
	    }
	  }
	  else {
	    adc_v = ijk & 0xfff;
	    printf(" %x", (ijk & 0xfff));
	  }
	  //         printf(" type 1 to continue\n");
	  //         scanf("%d", &dummy1);
	  
        }
        printf(" packet end %x \n", read_array[event_head[is+1]-1]);
        printf(" type 1 to continue\n");
        scanf("%d", &dummy1);
      }

      nread = (((read_array[2] & 0xfff)<<12) + ((read_array[2] & 0xfff0000)>>16));
      nread =nread+1;
       nread = nread/2;
       printf(" no. of word within the frame is %d\n", nread);
       printf(" %x, %x, %x, %x \n", read_array[0], read_array[1], read_array[2], read_array[3]);
       printf(" %x, %x, %x, %x \n", read_array[4], read_array[5], read_array[6], read_array[7]);
       scanf("%d",&is);
       for (is=0; is< nread+7; is++) {       // 6 header + 1 trailer.
	 read_comp[is] = read_array[is];
       }
       //
       //
       //
       printf(" 1st event \n");
       for (is=0; is< nread+7; is++) {
         if((is%8) ==0) printf("%4d",is);
         printf(" %8x",read_array[is]);
         if(((is+1)%8) ==0 ) printf("\n");
       }
       //       if(((is+1)%8) !=0 ) printf("\n");
       printf("\n");
       //
       //
       //
       icomp_l = (ntot_rec)/(nread+7); // only compare complete event  // have to add header
       if(comp_s ==1) printf(" compare %d of event in the loop, nread = %d \n",icomp_l, nread);
       if(comp_s == 1) {
	 for(is=0; is<icomp_l; is++) {
	   for (ik=6; ik< nread+6; ik++) {   //for the moment skip header
	     k=ik+is*(nread+7);
	     if(read_comp[ik] != read_array[k]) {
	       printf(" data error seq within event = %d, total seq = %d, event = %d, first event data word = %8x, data = %8x \n", ik,k,is,read_comp[ik], read_array[k]);
	       scanf("%d",&k);
	       for (il=0; il< 2*(nread+7); il++) {
		 if((il%8) ==0) printf("%4d",il);
		 k= il + is*(nread+7);
		 printf(" %8x",read_array[k]);
		 if(((il+1)%8) ==0 ) printf("\n");
	       }
	       //            if(((il+1)%8) !=0 ) printf("\n");
	       printf("\n");
	     }
	   }
	 }
       }
       printf(" compare finished \n");
       scanf("%d",&is);
       is=0;
       while (is < nwrite*2) {
         if(((nwrite*2)-is) <= 12) printf(" not enough word header \n");
         if(((nwrite*2)-is) <= 12) break;
         if((read_array_s[is] == 0xffff) && (read_array_s[is+1] == 0xffff)) {
	   printf(" event header %8x \n", read_array_s[is]+(read_array_s[is+1] << 16));
	   is=is+2;
	   printf(" module header = %4x\n", read_array_s[is]);
	   is=is+1;
	   printf(" address word = %4x, aid = %2x, module numebr %3d\n", read_array_s[is], ((read_array_s[is]>>5) &0x7f), (read_array_s[is] &0x1f));
	   is=is+1;
	   ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
	   nread=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
	   nread = nread+1;
	   printf(" word count word = %8x, word count = %8d \n", ik,nread);
	   is = is+2;
	   ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
	   k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
	   printf(" event number word = %8x, event number = %8d \n", ik,k);
	   is = is+2;
	   ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
	   k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
	   printf(" frame number word = %8x, frame number = %8d \n", ik,k);
	   is =is+2;
	   ik= (read_array_s[is]<<16)+ (read_array_s[is+1]);
	   k=  ((read_array_s[is] & 0xfff) << 12)+ (read_array_s[is+1] & 0xfff);
	   printf(" checksum word = %8x, checksum = %8x \n", ik,k);
	   is=is+2;
	   if(((nwrite*2)-is) <= (nread+2)) printf(" not enough word for the event \n");
	   if(((nwrite*2)-is) <= (nread+2)) break;
	   is=is+nread;
	   printf("end of packet word, %8x \n", read_array_s[is]+ (read_array_s[is+1]<<16));
	   is = is+2;
	   scanf("%d", &ik);
         }
       }
       
       imod=0;
       ichip=1;
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
       i=1;
       k=1;
       i = pcie_send(hDev3, i, k, px);
       scanf("%d",&ik);
    }
    
    break;
    
    
    
    
    
    
  } //&&&&&&&&&&&&&&&&&&&
  
}







static int pcie_send(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send)
{
  /* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
  static DWORD dwAddrSpace;
  static DWORD dwDMABufSize;
  
  static UINT32 *buf_send;
  static WD_DMA *pDma_send;
  static DWORD dwStatus;
  static DWORD dwOptions_send = DMA_TO_DEVICE;
  static DWORD dwOffset;
  static UINT32 u32Data;
  static PVOID pbuf_send;
  int nwrite,i,j, iprint;
  static int ifr=0;
  
  if (ifr == 0) {
    ifr=1;
    dwDMABufSize = 140000;
    dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
    if (WD_STATUS_SUCCESS != dwStatus) {
      printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
    }
    buf_send = pbuf_send;
  }
  iprint =0;
  if(mode ==1 ) {
    for (i=0; i< nword; i++) {
      *(buf_send+i) = *buff_send++;
      /*	printf("%d \n",*(buf_send+i));   */
    }
  }
  if(mode == 0) {
    nwrite = nword*4;
    /*setup transmiiter */
    dwAddrSpace =2;
    u32Data = 0x20000000;
    dwOffset = 0x18;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    dwAddrSpace =2;
    u32Data = 0x40000000+nwrite;
    dwOffset = 0x18;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    for (j=0; j< nword; j++) {
      dwAddrSpace =0;
      dwOffset = 0x0;
      u32Data = *buff_send++;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    }
    for (i=0; i<20000; i++) {
      dwAddrSpace =2;
      dwOffset = 0xC;
      WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
      if(iprint ==1) printf(" status reed %d %X \n", i, u32Data);
      if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" Data Transfer complete %d \n", i);
      if((u32Data & 0x80000000) == 0) break;
    }
  }
  if( mode ==1 ){
    nwrite = nword*4;
    WDC_DMASyncCpu(pDma_send);
    /*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
    */
    /*setup transmiiter */
    dwAddrSpace =2;
    u32Data = 0x20000000;
    dwOffset = 0x18;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    dwAddrSpace =2;
    u32Data = 0x40000000+nwrite;
    dwOffset = 0x18;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    
    /* set up sending DMA starting address */
    
    dwAddrSpace =2;
    u32Data = 0x20000000;
    dwOffset = 0x0;
    u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    
    dwAddrSpace =2;
    u32Data = 0x20000000;
    dwOffset = 0x4;
    u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    
    /* byte count */
    dwAddrSpace =2;
    dwOffset = 0x8;
    u32Data = nwrite;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    
    /* write this will start DMA */
    dwAddrSpace =2;
    dwOffset = 0xc;
    u32Data = 0x00100000;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    
    for (i=0; i<20000; i++) {
      dwAddrSpace =2;
      dwOffset = 0xC;
      WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
      if(iprint ==1) printf(" DMA status reed %d %X \n", i, u32Data);
      if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" DMA complete %d \n", i);
      if((u32Data & 0x80000000) == 0) break;
    }
    WDC_DMASyncIo(pDma_send);
  }
  return i;
}



static int pcie_rec(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
  /* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
  static DWORD dwAddrSpace;
  static DWORD dwDMABufSize;
  
  static UINT32 *buf_rec;
  static WD_DMA *pDma_rec;
  static DWORD dwStatus;
  static DWORD dwOptions_rec = DMA_FROM_DEVICE;
  static DWORD dwOffset;
  static UINT32 u32Data;
  static UINT64 u64Data;
  static PVOID pbuf_rec;
  int nread,i,j, iprint,icomp;
  static int ifr=0;
  
  if (ifr == 0) {
    ifr=1;
    dwDMABufSize = 140000;
    dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
    if (WD_STATUS_SUCCESS != dwStatus) {
      printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
    }
    buf_rec = pbuf_rec;
  }
  iprint =0;
  //    printf(" istart = %d\n", istart);
  //   printf(" mode   = %d\n", mode);
  /** set up the receiver **/
  if((istart == 1) | (istart == 3)) {
    // initalize transmitter mode register...
    //     printf(" nword = %d \n",nword);
    /*
      if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before set = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
    */
    dwAddrSpace =2;
    u32Data = 0xf0000008;
    dwOffset = 0x28;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    
    /*initialize the receiver */
    dwAddrSpace =2;
    u32Data = 0x20000000;
    dwOffset = 0x1c;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    /* write byte count **/
    dwAddrSpace =2;
    u32Data = 0x40000000+nword*4;
    dwOffset = 0x1c;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
    }
    
    return 0;
  }
  if ((istart == 2) | (istart == 3)) {
    //     if(ipr_status ==1) {
    //      dwAddrSpace =2;
    //      u64Data =0;
    //      dwOffset = 0x18;
    //      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
    //      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
    //     }
    if(mode == 0) {
      nread = nword/2+1;
      if(nword%2 == 0) nread = nword/2;
      for (j=0; j< nread; j++) {
	dwAddrSpace =0;
	dwOffset = 0x0;
	u64Data =0xbad;
	WDC_ReadAddr64(hDev,dwAddrSpace, dwOffset, &u64Data);
	//       printf("u64Data = %16X\n",u64Data);
	*buff_rec++ = (u64Data &0xffffffff);
	*buff_rec++ = u64Data >>32;
	//       printf("%x \n",(u64Data &0xffffffff));
	//       printf("%x \n",(u64Data >>32 ));
	//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
	//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
	dwAddrSpace =2;
	u64Data =0;
	dwOffset = 0x18;
	WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
	printf (" status word after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
    }
    if( mode ==1 ){
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
      /*
	printf(" nwrite = %d \n", nwrite);
	printf(" pcie_send hDev = %d\n", hDev);
	printf(" buf_send = %X\n",*buf_send);
      */
      /*setup receiver
	dwAddrSpace =2;
	u32Data = 0x20000000;
	dwOffset = 0x1c;
	WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
	dwAddrSpace =2;
	u32Data = 0x40000000+nread;
	dwOffset = 0x1c;
	WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      */
      /* set up sending DMA starting address */
      
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      
      /* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      
      /* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout\n");
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
	/*	printf("%d \n",*(buf_send+i));   */
      }
    }
  }
  return 0;
}// pcie_rec




/* -----------------------------------------------
    Read/write memory and I/O addresses
   ----------------------------------------------- */
/* Read/write address menu options */
enum {
    MENU_RW_ADDR_SET_ADDR_SPACE = 1,
    MENU_RW_ADDR_SET_MODE,
    MENU_RW_ADDR_SET_TRANS_TYPE,
    MENU_RW_ADDR_READ,
    MENU_RW_ADDR_WRITE,
    MENU_RW_ADDR_EXIT = DIAG_EXIT_MENU,
};

#define ACTIVE_ADDR_SPACE_NEEDS_INIT 0xFF


/* -----------------------------------------------
    Read/write the configuration space
   ----------------------------------------------- */
/* Read/write the configuration space menu options */
enum {
    MENU_RW_CFG_SPACE_READ_OFFSET = 1,
    MENU_RW_CFG_SPACE_WRITE_OFFSET,
    MENU_RW_CFG_SPACE_READ_ALL_REGS,
    MENU_RW_CFG_SPACE_READ_REG,
    MENU_RW_CFG_SPACE_WRITE_REG,
    MENU_RW_CFG_SPACE_EXIT = DIAG_EXIT_MENU,
};

/* -----------------------------------------------
    Read/write the run-time registers
   ----------------------------------------------- */
/* Read/write the run-time registers menu options */
enum {
    MENU_RW_REGS_READ_ALL = 1,
    MENU_RW_REGS_READ_REG,
    MENU_RW_REGS_WRITE_REG,
    MENU_RW_REGS_EXIT = DIAG_EXIT_MENU,
};

/* -----------------------------------------------
    Interrupt handling
   ----------------------------------------------- */
/* Interrupts menu options */
enum {
    MENU_INT_ENABLE_DISABLE = 1,
    MENU_INT_EXIT = DIAG_EXIT_MENU,
};


/* ----------------------------------------------------
    Plug-and-play and power management events handling
   ---------------------------------------------------- */
/* Events menu options */
enum {
    MENU_EVENTS_REGISTER_UNREGISTER = 1,
    MENU_EVENTS_EXIT = DIAG_EXIT_MENU,
};

