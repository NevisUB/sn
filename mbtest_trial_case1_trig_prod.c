/************************************************************************
*  File: pcie_diag.c
*
*  Sample user-mode diagnostics application for accessing PCIE
*  devices using WinDriver's API.
*  Code was generated by DriverWizard v10.21.
*
*  Jungo Confidential. Copyright (c) 2011 Jungo Ltd.  http://www.jungo.com
*************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include "wdc_defs.h"
#include "wdc_lib.h"
#include "utils.h"
#include "status_strings.h"
#include "samples/shared/diag_lib.h"
#include "samples/shared/wdc_diag_lib.h"
#include "samples/shared/pci_regs.h"
#include "pcie_lib.h"


/*************************************************************
  General definitions
 *************************************************************/
/* Error messages display */
#define PCIE_ERR printf

/*************************************************************
  Global variables
 *************************************************************/
/* User's input command */
static CHAR gsInput[256];

/* --------------------------------------------------
    PCIE configuration registers information
   -------------------------------------------------- */
/* Configuration registers information array */
const WDC_REG gPCIE_CfgRegs[] = {
    { WDC_AD_CFG_SPACE, PCI_VID, WDC_SIZE_16, WDC_READ_WRITE, "VID", "Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_DID, WDC_SIZE_16, WDC_READ_WRITE, "DID", "Device ID" },
    { WDC_AD_CFG_SPACE, PCI_CR, WDC_SIZE_16, WDC_READ_WRITE, "CMD", "Command" },
    { WDC_AD_CFG_SPACE, PCI_SR, WDC_SIZE_16, WDC_READ_WRITE, "STS", "Status" },
    { WDC_AD_CFG_SPACE, PCI_REV, WDC_SIZE_32, WDC_READ_WRITE, "RID_CLCD", "Revision ID & Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCSC, WDC_SIZE_8, WDC_READ_WRITE, "SCC", "Sub Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCBC, WDC_SIZE_8, WDC_READ_WRITE, "BCC", "Base Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CLSR, WDC_SIZE_8, WDC_READ_WRITE, "CALN", "Cache Line Size" },
    { WDC_AD_CFG_SPACE, PCI_LTR, WDC_SIZE_8, WDC_READ_WRITE, "LAT", "Latency Timer" },
    { WDC_AD_CFG_SPACE, PCI_HDR, WDC_SIZE_8, WDC_READ_WRITE, "HDR", "Header Type" },
    { WDC_AD_CFG_SPACE, PCI_BISTR, WDC_SIZE_8, WDC_READ_WRITE, "BIST", "Built-in Self Test" },
    { WDC_AD_CFG_SPACE, PCI_BAR0, WDC_SIZE_32, WDC_READ_WRITE, "BADDR0", "Base Address 0" },
    { WDC_AD_CFG_SPACE, PCI_BAR1, WDC_SIZE_32, WDC_READ_WRITE, "BADDR1", "Base Address 1" },
    { WDC_AD_CFG_SPACE, PCI_BAR2, WDC_SIZE_32, WDC_READ_WRITE, "BADDR2", "Base Address 2" },
    { WDC_AD_CFG_SPACE, PCI_BAR3, WDC_SIZE_32, WDC_READ_WRITE, "BADDR3", "Base Address 3" },
    { WDC_AD_CFG_SPACE, PCI_BAR4, WDC_SIZE_32, WDC_READ_WRITE, "BADDR4", "Base Address 4" },
    { WDC_AD_CFG_SPACE, PCI_BAR5, WDC_SIZE_32, WDC_READ_WRITE, "BADDR5", "Base Address 5" },
    { WDC_AD_CFG_SPACE, PCI_CIS, WDC_SIZE_32, WDC_READ_WRITE, "CIS", "CardBus CIS Pointer" },
    { WDC_AD_CFG_SPACE, PCI_SVID, WDC_SIZE_16, WDC_READ_WRITE, "SVID", "Sub-system Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_SDID, WDC_SIZE_16, WDC_READ_WRITE, "SDID", "Sub-system Device ID" },
    { WDC_AD_CFG_SPACE, PCI_EROM, WDC_SIZE_32, WDC_READ_WRITE, "EROM", "Expansion ROM Base Address" },
    { WDC_AD_CFG_SPACE, PCI_CAP, WDC_SIZE_8, WDC_READ_WRITE, "NEW_CAP", "New Capabilities Pointer" },
    { WDC_AD_CFG_SPACE, PCI_ILR, WDC_SIZE_32, WDC_READ_WRITE, "INTLN", "Interrupt Line" },
    { WDC_AD_CFG_SPACE, PCI_IPR, WDC_SIZE_32, WDC_READ_WRITE, "INTPIN", "Interrupt Pin" },
    { WDC_AD_CFG_SPACE, PCI_MGR, WDC_SIZE_32, WDC_READ_WRITE, "MINGNT", "Minimum Required Burst Period" },
    { WDC_AD_CFG_SPACE, PCI_MLR, WDC_SIZE_32, WDC_READ_WRITE, "MAXLAT", "Maximum Latency" },
    };
#define PCIE_CFG_REGS_NUM sizeof(gPCIE_CfgRegs) / sizeof(WDC_REG)
/* TODO: For read-only or write-only registers, change the direction field of
         the relevant registers in gPCIE_CfgRegs to WDC_READ or WDC_WRITE. */
/* NOTE: You can define additional configuration registers in gPCIE_CfgRegs. */
const WDC_REG *gpPCIE_CfgRegs = gPCIE_CfgRegs;

/* -----------------------------------------------
    PCIE run-time registers information
   ----------------------------------------------- */
/* Run-time registers information array */
/* const WDC_REG gPCIE_Regs[]; */
const WDC_REG *gpPCIE_Regs = NULL;
/* TODO: You can remove the comment from the gPCIE_Regs array declaration and
         fill the array with run-time registers information for your device,
         in which case be sure to set gpPCIE_Regs to point to gPCIE_Regs. */
#define PCIE_REGS_NUM 0

/*************************************************************
  Static functions prototypes
 *************************************************************/
/* -----------------------------------------------
    Main diagnostics menu
   ----------------------------------------------- */
static void MenuMain(WDC_DEVICE_HANDLE *phDev, WDC_DEVICE_HANDLE *phDev1, WDC_DEVICE_HANDLE *phDev2, 
		     WDC_DEVICE_HANDLE *phDev3, WDC_DEVICE_HANDLE *phDev4, WDC_DEVICE_HANDLE *phDev5,int min__, int max__);

/* static void MenuMain(WDC_DEVICE_HANDLE *phDev, WDC_DEVICE_HANDLE *phDev1, WDC_DEVICE_HANDLE *phDev2,  */
/* WDC_DEVICE_HANDLE *phDev3, WDC_DEVICE_HANDLE *phDev4, WDC_DEVICE_HANDLE *phDev5); */

/* -----------------------------------------------
    Device find, open and close
   ----------------------------------------------- */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId);
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot);
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot);
static void DeviceClose(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Read/write memory and I/O addresses
   ----------------------------------------------- */
static void MenuReadWriteAddr(WDC_DEVICE_HANDLE hDev);
static void SetAddrSpace(WDC_DEVICE_HANDLE hDev, PDWORD pdwAddrSpace);

/* -----------------------------------------------
    Read/write the configuration space
   ----------------------------------------------- */
static void MenuReadWriteCfgSpace(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Read/write the run-time registers
   ----------------------------------------------- */
static void MenuReadWriteRegs(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Interrupt handling
   ----------------------------------------------- */
static void MenuInterrupts(WDC_DEVICE_HANDLE hDev);
static void DiagIntHandler(WDC_DEVICE_HANDLE hDev, PCIE_INT_RESULT *pIntResult);

/* ----------------------------------------------------
    Plug-and-play and power management events handling
   ---------------------------------------------------- */
static void MenuEvents(WDC_DEVICE_HANDLE hDev);
static void DiagEventHandler(WDC_DEVICE_HANDLE hDev, DWORD dwAction);
static void Menujsebii_test(WDC_DEVICE_HANDLE hDev);
static void MenuMBtest(WDC_DEVICE_HANDLE hDev,WDC_DEVICE_HANDLE hDev1 ,WDC_DEVICE_HANDLE hDev2,
		       WDC_DEVICE_HANDLE hDev3, WDC_DEVICE_HANDLE hDev4, WDC_DEVICE_HANDLE hDev5, int min__, int max__);

/* static void MenuMBtest(WDC_DEVICE_HANDLE hDev,WDC_DEVICE_HANDLE hDev1 ,WDC_DEVICE_HANDLE hDev2, */
/* WDC_DEVICE_HANDLE hDev3, WDC_DEVICE_HANDLE hDev4, WDC_DEVICE_HANDLE hDev5); */


static int check_status(WDC_DEVICE_HANDLE hDevPMT,
			WDC_DEVICE_HANDLE hDevTPC,
			int imod_trig,
			int imod_fem_pmt_start,
			int imod_fem_pmt_end,
			int imod_fem_tpc_start,
			int imod_fem_tpc_end,
			int imod_xmit_pmt,
			int imod_xmit_tpc);


static int pcie_send(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send);
static int pcie_send_6_1(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send);
static int pcie_send_1(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send);
static int pcie_rec_16b(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int pcie_rec(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int pcie_rec_2(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int pcie_rec_6_1(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int pcie_rec_6_2(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int xmit_boot(WDC_DEVICE_HANDLE hDev, int imod_xmit);
static int fem_boot(WDC_DEVICE_HANDLE hDev, int imod_fem);
static void *pt_sn_filewrite(void *nword_write);
static void *pt_trig_filewrite(void *nword_write);
static void *pt_sn_filewrite_tpc(void *nword_write);
static void *pt_trig_filewrite_tpc(void *nword_write);
static int pmt_adc_setup(WDC_DEVICE_HANDLE hDev, int imod_fem, int iframe);
static int tpc_adc_setup(WDC_DEVICE_HANDLE hDev, int imod_fem, int iframe, int itpc_adc, int ihuff, int icom_factor, int timesize);
static int pmt_link_setup(WDC_DEVICE_HANDLE hDev, int imod_xmit, int imod_st, int supernova);
void *pt_trig_dma(void *threadarg);
void *pt_sn_dma(void *threadarg);
void trig_module_read(WDC_DEVICE_HANDLE hDev);
void *pt_trig_read(void *threadarg);
void *pt_trig_dma_tpc(void *threadarg);
void *pt_sn_dma_tpc(void *threadarg);
void *pcie_send_fake(void *threadarg);
//vic
int nwrite_2;


//
//     data storage
//
static int buff_snova[4000000];
static int buff_trig [4000000];
static int snova_pointer;
static int trig_pointer;
static int snova_wcount;
static int trig_wcount;
static int fd_trig_pt;
static int fd_sn_pt;
static int fd_trig_pt_m;
static int fd_monitor_pt;
//
static int fd_trig_pt_tpc;
static int fd_sn_pt_tpc;
static int fd_trig_pt_m_tpc;
static int fd_monitor_pt_tpc;
//
static DWORD dwDMABufSize;
static int itrig_m_d, itrig_m, ith_fr;

//
//#define dwDMABufSize = 1000000;
//
//
//

#define  jbuf_ev_size 1000000
pthread_mutex_t mutexlock;
static int write_point_n, read_point_n, write_point_s, read_point_s;
static int write_point_n_tpc, read_point_n_tpc, write_point_s_tpc, read_point_s_tpc;
//static int buffer_wc_n[jbuf_ev_size], buffer_wc_s[jbuf_ev_size];
static int buffer_ev_n[jbuf_ev_size], buffer_ev_s[jbuf_ev_size];
static int buffer_ev_n_tpc[jbuf_ev_size], buffer_ev_s_tpc[jbuf_ev_size];

//
//  for PMT
//
    PVOID pbuf_rec_n1;
    WD_DMA *pDma_rec_n1;

    PVOID pbuf_rec_n2;
    WD_DMA *pDma_rec_n2;
//georgia
static long tnum;
char name[150];

//variables for data checking
static int nc=0;
static int nwords=0;
static int ibin=1;
static int ih=0;
static int set=0;
static long long int adc1,adc2;
static long nmod;
static int femfakedata;
static UINT32 im,iwritem,iwrited,iline,dmasizewrite,firstokayk,icompare,ipause,firstokay,incomp,in;
static UINT32 evno,evnob4,frno,frnob4,ch,fevno[20],fevnob4[20],ffrno[20],ffrnob4[20];
static UINT32 read_arrayy[40000];
static UINT32 read_array_c[40000];
static UINT32 read_comp[40000];
static UINT32 read_array_compare[40000000],read_array_1st[40000000];
//geoergia


    PVOID pbuf_rec_s;
    WD_DMA *pDma_rec_s;
    PVOID pbuf_rec_s1;
    WD_DMA *pDma_rec_s1;
    PVOID pbuf_rec_s2;
    WD_DMA *pDma_rec_s2;
    PVOID pbuf_rec_s3;
    WD_DMA *pDma_rec_s3;
    PVOID pbuf_rec_s4;
    WD_DMA *pDma_rec_s4;
//
//  for TPC
//
    PVOID pbuf_rec_n1_tpc;
    WD_DMA *pDma_rec_n1_tpc;

    PVOID pbuf_rec_n2_tpc;
    WD_DMA *pDma_rec_n2_tpc;


    PVOID pbuf_rec_s_tpc;
    WD_DMA *pDma_rec_s_tpc;
    PVOID pbuf_rec_s1_tpc;
    WD_DMA *pDma_rec_s1_tpc;
    PVOID pbuf_rec_s2_tpc;
    WD_DMA *pDma_rec_s2_tpc;
    PVOID pbuf_rec_s3_tpc;
    WD_DMA *pDma_rec_s3_tpc;
    PVOID pbuf_rec_s4_tpc;
    WD_DMA *pDma_rec_s4_tpc;

    PVOID pbuf_send_fake;
    WD_DMA *pDma_send_fake;
//

/*************************************************************
  Functions implementation
 *************************************************************/
/* int main(void) */
int main(int argc, char **argv)
{

  int min__ = atoi(argv[1]);
  int max__ = atoi(argv[2]);

  struct timeval start;
  gettimeofday(&start,NULL);

  long seconds, useconds;
  seconds = start.tv_sec;
  useconds = start.tv_usec;

  printf("\nStart time of program: %ld sec %ld usec\n",seconds,useconds);


    WDC_DEVICE_HANDLE hDev = NULL;
    WDC_DEVICE_HANDLE hDev1 = NULL;
    WDC_DEVICE_HANDLE hDev2 = NULL;
    WDC_DEVICE_HANDLE hDev3 = NULL;
    WDC_DEVICE_HANDLE hDev4 = NULL;
    WDC_DEVICE_HANDLE hDev5 = NULL;

    DWORD dwStatus;

    printf("\n");
    printf("PCIE diagnostic utility.\n");
    printf("Application accesses hardware using " WD_PROD_NAME ".\n");

    /* Initialize the PCIE library */
    dwStatus = PCIE_LibInit();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        PCIE_ERR("pcie_diag: Failed to initialize the PCIE library: %s",
            PCIE_GetLastErr());
        return dwStatus;
    }

    /* Find and open a PCIE device (by default ID) */
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID);
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev1 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID+1);
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev2 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID+2);
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev3 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID+3);
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev4 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID+4);
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev5 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID+5);
    
    
    
    hDev3  = hDev;
    hDev5  = hDev1;


    /* Display main diagnostics menu for communicating with the device */
    /* MenuMain(&hDev, &hDev1, &hDev2, &hDev3, &hDev4, &hDev5); */
    MenuMain(&hDev, &hDev1, &hDev2, &hDev3, &hDev4, &hDev5,min__,max__);


    /* Perform necessary cleanup before exiting the program */
    if (hDev)
        DeviceClose(hDev);
        DeviceClose(hDev1);
        DeviceClose(hDev2);
        DeviceClose(hDev3);
        DeviceClose(hDev4);
        DeviceClose(hDev5);

    dwStatus = PCIE_LibUninit();
    if (WD_STATUS_SUCCESS != dwStatus)
        PCIE_ERR("pcie_diag: Failed to uninit the PCIE library: %s", PCIE_GetLastErr());
    
    return dwStatus;
}

/* -----------------------------------------------
    Main diagnostics menu
   ----------------------------------------------- */
/* Main menu options */
enum {
    MENU_MAIN_SCAN_PCI_BUS = 1,
    MENU_MAIN_FIND_AND_OPEN,
    MENU_MAIN_RW_ADDR,
    MENU_MAIN_RW_CFG_SPACE,
    MENU_MAIN_RW_REGS,
    MENU_MAIN_ENABLE_DISABLE_INT,
    MENU_MAIN_EVENTS,
    MENU_MAIN_MB_TEST, /* add new route for testing */
    MENU_MAIN_JSEBII_TEST, /* add new route for testing */
    MENU_MAIN_EXIT = DIAG_EXIT_MENU,
};

/* Main diagnostics menu */
static void MenuMain(WDC_DEVICE_HANDLE *phDev, WDC_DEVICE_HANDLE *phDev1, WDC_DEVICE_HANDLE *phDev2, 
		     WDC_DEVICE_HANDLE *phDev3, WDC_DEVICE_HANDLE *phDev4, WDC_DEVICE_HANDLE *phDev5,int min__,int max__)
  
/* static void MenuMain(WDC_DEVICE_HANDLE *phDev, WDC_DEVICE_HANDLE *phDev1, WDC_DEVICE_HANDLE *phDev2,  */
/* 		     WDC_DEVICE_HANDLE *phDev3, WDC_DEVICE_HANDLE *phDev4, WDC_DEVICE_HANDLE *phDev5) */
{

  MenuMBtest(*phDev, *phDev1, *phDev2, *phDev3, *phDev4, *phDev5,min__,max__);
  return;

  DWORD option;
    
    do
    {
        printf("\n");
        printf("PCIE main menu\n");
        printf("--------------\n");
        printf("%d. Scan PCI bus\n", MENU_MAIN_SCAN_PCI_BUS);
        printf("%d. Find and open a PCIE device\n", MENU_MAIN_FIND_AND_OPEN);
        if (*phDev)
        {
            printf("%d. Read/write memory and IO addresses on the device\n",
                MENU_MAIN_RW_ADDR);
            printf("%d. Read/write the device's configuration space\n",
                MENU_MAIN_RW_CFG_SPACE);
            if (PCIE_REGS_NUM)
            {
                printf("%d. Read/write the run-time registers\n",
                    MENU_MAIN_RW_REGS);
            }
            printf("%d. Enable/disable the device's interrupts\n",
                MENU_MAIN_ENABLE_DISABLE_INT);
            printf("%d. Register/unregister plug-and-play and power management "
                "events\n", MENU_MAIN_EVENTS);
            printf("%d. MicroBoone test\n", MENU_MAIN_MB_TEST);
            printf("%d. Test loop for PCIe\n", MENU_MAIN_JSEBII_TEST);
        }
        printf("%d. Exit\n", MENU_MAIN_EXIT);

	/**        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            *phDev ? MENU_MAIN_EVENTS : MENU_MAIN_FIND_AND_OPEN))
        {
            continue;
        }
	**/

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            *phDev ? MENU_MAIN_JSEBII_TEST : MENU_MAIN_FIND_AND_OPEN))
        {
            continue;
        }

        switch (option)
        {
        case MENU_MAIN_EXIT: /* Exit menu */
            break;
        case MENU_MAIN_SCAN_PCI_BUS: /* Scan PCI bus */
            WDC_DIAG_PciDevicesInfoPrintAll(FALSE);
            break;
        case MENU_MAIN_FIND_AND_OPEN: /* Find and open a PCIE device */
            if (*phDev)
                DeviceClose(*phDev);
            *phDev = DeviceFindAndOpen(0, 0);
            break;
        case MENU_MAIN_RW_ADDR: /* Read/write memory and I/O addresses */
            MenuReadWriteAddr(*phDev);
            break;
        case MENU_MAIN_RW_CFG_SPACE: /* Read/Write the PCIE configuration space */
            MenuReadWriteCfgSpace(*phDev);
            break;
        case MENU_MAIN_RW_REGS: /* Read/write the run-time registers */
            if (PCIE_REGS_NUM)
                MenuReadWriteRegs(*phDev);
            else
                printf("Invalid selection\n");
            break;
        case MENU_MAIN_ENABLE_DISABLE_INT: /* Enable/disable interrupts */
            MenuInterrupts(*phDev);
            break;
        case MENU_MAIN_EVENTS: /* Register/unregister plug-and-play and power management events */
            MenuEvents(*phDev);
            break;
        case MENU_MAIN_MB_TEST: /* my test loop DMA */
	  //MenuMBtest(*phDev, *phDev1, *phDev2, *phDev3, *phDev4, *phDev5);
            break;
        case MENU_MAIN_JSEBII_TEST: /* my test loop DMA */
            Menujsebii_test(*phDev);
            break;
        }
    } while (MENU_MAIN_EXIT != option);
}

/* -----------------------------------------------
    Device find, open and close
   ----------------------------------------------- */
/* Find and open a PCIE device */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId)
{
    WD_PCI_SLOT slot;
    
    if (!DeviceFind(dwVendorId, dwDeviceId, &slot))
        return NULL;

    return DeviceOpen(&slot);
}

/* Find a PCIE device */
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT *pSlot)
{
    DWORD dwStatus;
    DWORD i, dwNumDevices;
    WDC_PCI_SCAN_RESULT scanResult;

    if (dwVendorId == 0)
    {
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwVendorId,
            "Enter vendor ID", TRUE, 0, 0))
        {
            return FALSE;
        }

        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwDeviceId,
            "Enter device ID", TRUE, 0, 0))
        {
            return FALSE;
        }
    }

    BZERO(scanResult);
    dwStatus = WDC_PciScanDevices(dwVendorId, dwDeviceId, &scanResult);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        PCIE_ERR("DeviceFind: Failed scanning the PCI bus.\n"
            "Error: 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return FALSE;
    }

    dwNumDevices = scanResult.dwNumDevices;
    if (!dwNumDevices)
    {
        PCIE_ERR("No matching device was found for search criteria "
            "(Vendor ID 0x%lX, Device ID 0x%lX)\n",
            dwVendorId, dwDeviceId);

        return FALSE;
    }

    printf("\n");
    printf("Found %ld matching device%s [ Vendor ID 0x%lX%s, Device ID 0x%lX%s ]:\n",
        dwNumDevices, dwNumDevices > 1 ? "s" : "",
        dwVendorId, dwVendorId ? "" : " (ALL)",
        dwDeviceId, dwDeviceId ? "" : " (ALL)");

    for (i = 0; i < dwNumDevices; i++)
    {
        printf("\n");
        printf("%2ld. Vendor ID: 0x%lX, Device ID: 0x%lX\n",
            i + 1,
            scanResult.deviceId[i].dwVendorId,
            scanResult.deviceId[i].dwDeviceId);

        WDC_DIAG_PciDeviceInfoPrint(&scanResult.deviceSlot[i], FALSE);
    }
    printf("\n");

    if (dwNumDevices > 1)
    {
        sprintf(gsInput, "Select a device (1 - %ld): ", dwNumDevices);
        i = 0;
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&i,
            gsInput, FALSE, 1, dwNumDevices))
        {
            return FALSE;
        }
    }

    *pSlot = scanResult.deviceSlot[i - 1];

    return TRUE;
}

/* Open a handle to a PCIE device */
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot)
{
    WDC_DEVICE_HANDLE hDev;
    DWORD dwStatus;
    WD_PCI_CARD_INFO deviceInfo;

    /* Retrieve the device's resources information */
    BZERO(deviceInfo);
    deviceInfo.pciSlot = *pSlot;
    dwStatus = WDC_PciGetDeviceInfo(&deviceInfo);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        PCIE_ERR("DeviceOpen: Failed retrieving the device's resources information.\n"
            "Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return NULL;
    }

    /* NOTE: You can modify the device's resources information here, if
       necessary (mainly the deviceInfo.Card.Items array or the items number -
       deviceInfo.Card.dwItems) in order to register only some of the resources
       or register only a portion of a specific address space, for example. */

    /* Open a handle to the device */
    hDev = PCIE_DeviceOpen(&deviceInfo);
    if (!hDev)
    {
        PCIE_ERR("DeviceOpen: Failed opening a handle to the device: %s",
            PCIE_GetLastErr());
        return NULL;
    }

    return hDev;
}

/* Close handle to a PCIE device */
static void DeviceClose(WDC_DEVICE_HANDLE hDev)
{
    if (!hDev)
        return;

    if (!PCIE_DeviceClose(hDev))
    {
        PCIE_ERR("DeviceClose: Failed closing PCIE device: %s",
            PCIE_GetLastErr());
    }
}



/* Read/write memory or I/O space address menu */
//static void MenuMBtest(WDC_DEVICE_HANDLE hDev, WDC_DEVICE_HANDLE hDev1 ,WDC_DEVICE_HANDLE hDev2, 
//		       WDC_DEVICE_HANDLE hDev3, WDC_DEVICE_HANDLE hDev4, WDC_DEVICE_HANDLE hDev5)
static void MenuMBtest(WDC_DEVICE_HANDLE hDev, WDC_DEVICE_HANDLE hDev1 ,WDC_DEVICE_HANDLE hDev2, 
		       WDC_DEVICE_HANDLE hDev3, WDC_DEVICE_HANDLE hDev4, WDC_DEVICE_HANDLE hDev5,int min__, int max__)

{

#include "wdc_defs.h"
#define poweroff      0x0
#define poweron       0x1
#define configure_s30 0x2
#define configure_s60 0x3
#define configure_cont 0x20
#define rdstatus      0x80
#define loopback        0x04

#define dcm2_run_off  254
#define dcm2_run_on   255

#define dcm2_online   2
#define dcm2_setmask  3
#define dcm2_offline_busy 4
#define dcm2_load_packet_a 10
#define dcm2_load_packet_b 11
#define dcm2_offline_load 9
#define dcm2_status_read 20
#define dcm2_led_sel     29
#define dcm2_buffer_status_read 30
#define dcm2_status_read_inbuf 21
#define dcm2_status_read_evbuf 22
#define dcm2_status_read_noevnt 23
#define dcm2_zero 12
#define dcm2_compressor_hold 31

#define dcm2_5_readdata 4
#define dcm2_5_firstdcm 8
#define dcm2_5_lastdcm  9
#define dcm2_5_status_read 5
#define dcm2_5_source_id 25
#define dcm2_5_lastchnl 24

#define dcm2_packet_id_a 25
#define dcm2_packet_id_b 26
#define dcm2_hitformat_a 27
#define dcm2_hitformat_b 28

#define part_run_off  254
#define part_run_on   255
#define part_online   2
#define part_offline_busy 3
#define part_offline_hold 4
#define part_status_read 20
#define part_source_id 25


#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  mb_cntrl_add     0x1
#define  mb_cntrl_test_on 0x1
#define  mb_cntrl_test_off 0x0
#define  mb_cntrl_set_run_on 0x2
#define  mb_cntrl_set_run_off 0x3
#define  mb_cntrl_set_trig1 0x4
#define  mb_cntrl_set_trig2 0x5
#define  mb_cntrl_load_frame 0x6
#define  mb_cntrl_load_trig_pos 0x7

#define  mb_feb_power_add 0x1
#define  mb_feb_conf_add 0x2
#define  mb_feb_pass_add 0x3

#define  mb_feb_lst_on          1
#define  mb_feb_lst_off         0
#define  mb_feb_rxreset         2
#define  mb_feb_align           3
#define  mb_feb_pll_reset       5


#define  mb_feb_adc_align       1
#define  mb_feb_a_nocomp        2
#define  mb_feb_b_nocomp        3
#define  mb_feb_blocksize       4
#define  mb_feb_timesize        5
#define  mb_feb_mod_number      6
#define  mb_feb_a_id            7
#define  mb_feb_b_id            8
#define  mb_feb_max             9

#define  mb_feb_test_source    10
#define  mb_feb_test_sample    11
#define  mb_feb_test_frame     12
#define  mb_feb_test_channel   13
#define  mb_feb_test_ph        14
#define  mb_feb_test_base      15
#define  mb_feb_test_ram_data  16

#define  mb_feb_a_test         17
#define  mb_feb_b_test         18

#define  mb_feb_rd_status      20

#define  mb_feb_a_rdhed        21
#define  mb_feb_a_rdbuf        22
#define  mb_feb_b_rdhed        23
#define  mb_feb_b_rdbuf        24

#define  mb_feb_read_probe     30
#define  mb_feb_dram_reset     31
#define  mb_feb_adc_reset      33

#define  mb_a_buf_status       34
#define  mb_b_buf_status       35
#define  mb_a_ham_status       36
#define  mb_b_ham_status       37

#define  mb_feb_a_maxwords     40
#define  mb_feb_b_maxwords     41

#define  mb_feb_hold_enable    42

#define  mb_feb_tpc_load_threshold   100
#define  mb_feb_tpc_load_baseline    164
//#define  mb_feb_tpc_load_presample   230
//#define  mb_feb_tpc_load_postsample  231
#define  mb_feb_tpc_sel_combase     232
//#define  mb_feb_tpc_sel_comthres    233
#define  mb_feb_tpc_load_combase   234
#define  mb_feb_tpc_load_comthres   235
//#define  mb_feb_tpc_sel_bipolar   236

#define  mb_feb_tpc_load_thr_mean   164
#define  mb_feb_tpc_load_thr_vari   165
#define  mb_feb_tpc_load_common_thr 166
#define  mb_feb_tpc_sel_bipolar     167
#define  mb_feb_tpc_load_presample  168
#define  mb_feb_tpc_load_postsample 169
#define  mb_feb_tpc_sel_comthres    170

#define  mb_pmt_adc_reset       1
#define  mb_pmt_spi_add         2
#define  mb_pmt_adc_data_load   3

#define  mb_xmit_conf_add 0x2
#define  mb_xmit_pass_add 0x3

#define  mb_xmit_modcount 0x1
#define  mb_xmit_enable_1 0x2
#define  mb_xmit_enable_2 0x3
#define  mb_xmit_test1 0x4
#define  mb_xmit_test2 0x5

#define   mb_xmit_testdata  10

#define  mb_xmit_rdstatus 20
#define  mb_xmit_rdcounters 21
#define  mb_xmit_link_reset    22
#define  mb_opt_dig_reset   23
#define  mb_xmit_dpa_fifo_reset    24
#define  mb_xmit_dpa_word_align    25
#define  mb_xmit_link_pll_reset    26

#define  mb_trig_run                1
#define  mb_trig_frame_size         2
#define  mb_trig_deadtime_size      3
#define  mb_trig_active_size        4
#define  mb_trig_delay1_size        5
#define  mb_trig_delay2_size        6
#define  mb_trig_enable             7

#define  mb_trig_calib_delay        8

#define  mb_trig_prescale0         10
#define  mb_trig_prescale1         11
#define  mb_trig_prescale2         12
#define  mb_trig_prescale3         13
#define  mb_trig_prescale4         14
#define  mb_trig_prescale5         15
#define  mb_trig_prescale6         16
#define  mb_trig_prescale7         17
#define  mb_trig_prescale8         18

#define  mb_trig_mask0             20
#define  mb_trig_mask1             21
#define  mb_trig_mask2             22
#define  mb_trig_mask3             23
#define  mb_trig_mask4             24
#define  mb_trig_mask5             25
#define  mb_trig_mask6             26
#define  mb_trig_mask7             27
#define  mb_trig_mask8             28

#define  mb_trig_rd_param          30
#define  mb_trig_pctrig            31
#define  mb_trig_rd_status         32
#define  mb_trig_reset             33
#define  mb_trig_calib             34
#define  mb_trig_rd_gps            35

#define  mb_trig_sel1              40
#define  mb_trig_sel2              41
#define  mb_trig_sel3              42
#define  mb_trig_sel4              43

#define  mb_trig_p1_delay          50
#define  mb_trig_p1_width          51
#define  mb_trig_p2_delay          52
#define  mb_trig_p2_width          53
#define  mb_trig_p3_delay          54
#define  mb_trig_p3_width          55
#define  mb_trig_pulse_delay       58
#define  mb_trig_output_select     59

#define  mb_trig_pulse1            60
#define  mb_trig_pulse2            61
#define  mb_trig_pulse3            62

#define  mb_trig_frame_trig        63

#define  mb_trig_frame_trig_frm    83
#define  mb_trig_frame_trig_div    84

#define  mb_shaper_pulsetime        1
#define  mb_shaper_dac              2
#define  mb_shaper_pattern          3
#define  mb_shaper_write            4
#define  mb_shaper_pulse            5
#define  mb_shaper_entrig           6

#define  mb_feb_pmt_gate_size      47
#define  mb_feb_pmt_beam_delay     48
#define  mb_feb_pmt_beam_size      49

#define  mb_feb_pmt_ch_set         50
#define  mb_feb_pmt_delay0         51
#define  mb_feb_pmt_delay1         52
#define  mb_feb_pmt_precount       53
#define  mb_feb_pmt_thresh0        54
#define  mb_feb_pmt_thresh1        55
#define  mb_feb_pmt_thresh2        56
#define  mb_feb_pmt_thresh3        57
#define  mb_feb_pmt_width          58
#define  mb_feb_pmt_deadtime       59
#define  mb_feb_pmt_window         60
#define  mb_feb_pmt_words          61
#define  mb_feb_pmt_cos_mul        62
#define  mb_feb_pmt_cos_thres      63
#define  mb_feb_pmt_mich_mul       64
#define  mb_feb_pmt_mich_thres     65
#define  mb_feb_pmt_beam_mul       66
#define  mb_feb_pmt_beam_thres     67
#define  mb_feb_pmt_en_top         68
#define  mb_feb_pmt_en_upper       69
#define  mb_feb_pmt_en_lower       70
#define  mb_feb_pmt_blocksize      71

#define  mb_feb_pmt_test           80
#define  mb_feb_pmt_clear          81
#define  mb_feb_pmt_test_data      82
#define  mb_feb_pmt_pulse          83

#define  mb_feb_pmt_rxreset        84
#define  mb_feb_pmt_align_pulse    85
#define  mb_feb_pmt_rd_counters    86

#define  dma_buffer_size        40000000

  static DWORD dwAddrSpace;

  static UINT32 u32Data;
  static unsigned short u16Data;
  static unsigned long long u64Data, u64Data1;
  static DWORD dwOffset;
    static long imod,ichip;
    unsigned short *buffp;


    //vic
    char title1[100];
    char title[100];
    //vic
    
/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
    static UINT32 i,j,k,ifr,nread,iprint,iwrite,ik,il,is,checksum;
    static UINT32 istop,newcmd,irand,ioffset,kword,lastchnl,ib;
    static UINT32 send_array[40000][20],read_array[dma_buffer_size],read_array1[40000];
    static UINT32 read_array_c[40000];
    static UINT32 read_comp[8000];
    static UINT32 nmask,index,itmp,nword_tot,nevent,iv,ijk,islow_read;
    static UINT32 imod_p,imod_trig,imod_shaper;
    unsigned short idcm_read_array[40000],read_array_s[1600000];
    static UINT32 idcm_read_array32[40000];
    static UINT32 idcm_send_array[400000];
    static UINT32 idcm_verify_array[400000];
    static int icomp_l,comp_s,ia,ic,ihuff,sample_b,dis;
    UINT32 *idcm_send_p,*idcm_verify_p,*pbuffp_rec;
//    DWORD dwDMABufSize;
    PVOID pbuf;
    WD_DMA *pDma;
    DWORD dwStatus;
    DWORD dwOptions = DMA_FROM_DEVICE;
    UINT32 iread,icheck,izero;
    UINT32 buf_send[40000];
    static int   count,num,counta,nword,ireadback,nloop,ierror;
    static int   ij,nsend,iloop,inew,idma_readback,iadd,jevent;
    static int   itest,iframe,irun,ichip_c,dummy1,itrig_c;
    static int  idup,ihold,idouble,ihold_set,istatus_read;
    static int  idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
    static int   timesize,ipulse,ibase,a_id,itrig_delay;
    static int   iset,ncount,nsend_f,nwrite,itrig_ext;
    static int   imod_xmit,idiv,isample;
    static int   iframe_length, itrig,idrift_time,ijtrig;
    static int   idelay0, idelay1, threshold0, threshold1, pmt_words;
    static int   cos_mult, cos_thres, en_top, en_upper, en_lower;
    static int   irise, ifall, istart_time, use_pmt, pmt_testpulse;
    static int   ich_head, ich_sample, ich_frm,idebug,ntot_rec,nred;
    static int   ineu,ibusy_send,ibusy_test,ihold_word,ndma_loop;
    static int   irawprint, nwrite_byte,idis_c,idis_c1;
    static int   icomp_index, nword_comp, nk, ilast_check;
    static int   ic_ev, ic_fr, event_save, frame_save,frame_ev,event_ev;
    static int   imod_fem, imod_st, imod_last, itrig_type, last_dma_loop_size;
    static int   fd, n_read, n_write, pt_trig_wdone, pt_snova_wdone;
    static int   pt_trig_dmastart;
    static int   nremain, nread_dma,nremain_tran1, nremain_tran2,ig, nremain_dma;
    static int   rc_pt, nword_n, nwrite_byte_n, is1, event_head[100];
    static int   wait_min, wait_max;
    static int   iwait_usec,iwait_loop;
    static int   icom_factor,ifr_c2;
    static int   pmt_dac_scan,idac_shaper;
    static int   itrig_pulse,p1_delay,p1_width,p2_delay,p2_width, pulse_trig_delay;
    static int   icont,ibytec,n_trig, imulti,isuper, ipr_trig, imonitor;
    static int   ipmt_read, itpc_read, itpc_adc, imod_xmit_tpc, imod_st_tpc,imod_last_tpc;
    static int   islope, iwidth, ibeg, izero_sup, istart, istart_old;
    static int   iround, idir;
    static int   icount, idiff, adc_v;
    static int   ifake_kazu;
    static int   frame_trig_sample, frame_trig_div;
//
    struct timeval start;
    
    
    static int fd_sn,ooo;
    //
    void *status_pt;
    size_t stacksize;
//
//
    pthread_t threads[3];
//
    pthread_attr_t attr_pt_trig_dma, attr_pt_sn_dma;
    pthread_attr_t attr_pt_tr, attr_pt_sn;
//
    pthread_attr_t attr_pt_trig_dma_tpc, attr_pt_sn_dma_tpc;
    pthread_attr_t attr_pt_tr_tpc, attr_pt_sn_tpc;
//
    pthread_attr_t attr_pt_tr_m, attr_pt_trig_dma_m;
    pthread_attr_t attr_pt_fake;

//
    unsigned char    charchannel;
    unsigned char    carray[4000];
    struct timespec tim, tim2;
    tim.tv_sec = 0;
//    tim.tv_nsec =128000;
    tim.tv_nsec =172000; // extend the delay for 12 MHz clock

    PVOID pbuf_rec;
    WD_DMA *pDma_rec;
    PVOID pbuf_rec1;
    WD_DMA *pDma_rec1;
    PVOID pbuf_rec2;
    WD_DMA *pDma_rec2;

//    PVOID pbuf_rec_n;
//    WD_DMA *pDma_rec_n;

    DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_CACHE;
//    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_CACHE | DMA_ALLOW_64BIT_ADDRESS;
    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_64BIT_ADDRESS;

    static UINT64 *buffp_rec64;
    static UINT32 *buffp_rec32, *buffp_rec32_n;
    static UINT32 *buffp_send;
    UINT32 *px, *py, *py1;

    FILE *outf,*inpf,*outfile,*pFilee;

    struct thread_data
    {
      int id;
      WDC_DEVICE_HANDLE hdev;
      WDC_DEVICE_HANDLE hdevc;
    };

    struct thread_data thread_data_n;
    struct thread_data thread_data_sn;
//
    struct thread_data thread_data_n_tpc;
    struct thread_data thread_data_sn_tpc;
//
    struct thread_data thread_data_n_m;




    nread = 4096*2+6; /*16384 32768, 65536+4;  number of byte to be readout */
    ifr=0;
    iwrite =0;
    iprint =0;
    icheck =0;
    istop=0;

    printf("Input the command code for test......\n");

    printf("     (1) SuperNova readout test -- 2 buffer mode \n");
    printf("     (2) SuperNova readout test -- multiple boards \n");
    printf("     (3) Neutrino event readout -- multiple baotrds \n");
    printf("     (4) Dev1 -- Neutrino event readout -- multiple baotrds \n");
    printf("     (5) SuperNova readout test -- thread \n");

    //    scanf("%d",&newcmd);
    newcmd =1; // Jose: choose case 1
    switch(newcmd) {


    dwDMABufSize = 1000000;
    
    
    case 1:
      //idebug=1;
      //iprint=1;
      //irawprint=1;
      printf("Using trigger issued through the controller, and fake FEM data.\n");
     
      printf("\n-----------------------------\n");
      printf("RUN OPTIONS:\n");

      printf("\n\tEnter number of triggers (events):\t");
      scanf("%d",&nevent);

      printf("\n-----------------------------\n");
      printf("CRATE CONFIGURATION:\n");

      printf("\n\tHow many FEB modules?\t\t");
      scanf("%d",&nmod);
      //      nmod=17;//15 new FEMs at a time

      printf("\n\tXMIT slot number (count from right, starting at 1)?\t");
      scanf("%d",&imod_xmit);
      //      imod_xmit=1;

      imod_st=imod_xmit+nmod;
      
      printf("\n\tProceeding with module numbers:\n\t");
      for (i=0; i<nmod; i++){
	printf("%d\t",imod_xmit+1+i);
      }
      printf("\n\tLast FEM module: %d",imod_st);
      printf("\n");
      

      printf("\n-----------------------------\n");
      printf("DATA TYPE OPTIONS:\n");

      femfakedata=1;
      printf("\n\tUse random FEM data?\t");
      scanf("%d",&irand);
      //	irand=1;

      //      printf("\n\tUse huffman compression?\t");
      //      scanf("%d",&ihuff);
      //      ihuff =1; //xxxxx need to predict event size 
      ihuff=0;

      //      printf("\n\tDMA buffer size?\t");
      //      scanf("%d",&dwDMABufSize);
      dwDMABufSize = 4000000;

      printf("\n-----------------------------\n");
      printf("OUTPUT OPTIONS:\n");
      
      printf("\n\tWrite data to binary file?\t");
      scanf("%d",&iwrite);
      if(iwrite == 1) {
	printf("\n\tTest number (for output file name)?\t");
	scanf("%d",&tnum);
	//      tnum=0;	
	printf("\n\tWrite multiple binaries?\t");
	scanf("%d",&iwritem);
	//	iwritem=0;
	if (iwritem==0){
	  printf("\n\tWrite on every DMA?\t");
	  scanf("%d",&dmasizewrite);
	  sprintf(name,"output/fem_testing_xmitnu_%i.dat",tnum);
	  fd = creat(name,0755);
	  printf("\n\tOutput file: %s\n",name);
	}
      }

      printf("\n\tWrite data to text formated file?\t");
      scanf("%d",&iwrited);
      //      iwrited=0;

      if (iwrited==1){
	printf("\n\tTest number (for output file name)?\t");
	scanf("%d",&tnum);
	//      tnum=0;	
	sprintf(name,"output/fem_testing_xmitnu_txt_%i.dat",tnum);
	outf = fopen(name,"w");
	printf("\n\tOutput file: %s\n",name);
      }
	

      printf("\n-----------------------------\n");
      printf("DATA CHECKING OPTIONS:\n");
      
      //      printf("\n\tType 1 for print out debug information in dma loop:\t");
      //      scanf("%d",&idebug);
      //idebug=1;

      printf("\n\tType 1 to check data integrity during running:\t");
      scanf("%d",&irawprint);
      //      irawprint=1;
      
      if (irawprint==1){
	printf("\n\tCompare to first event? (Note: if not, new data will be generated for each event, which is slow.)\t");
	scanf("%d",&icompare);

	if (icompare==0){
	  printf("\n\tPause between events?\t");
	  scanf("%d",&ipause);
	}
	else {
	  ipause=0;
	}
      }

      if (icompare==1 && femfakedata==0){
	printf("\nWARNING: You are not using fake data. Events will differ! Enter 1 to acknowledge this.\n");
	scanf("%d",&ifr);
      }

      printf("\n*****************************************************\n");
      printf("*****************************************************\n");


      iframe_length = 25599; //25599 corresponds to nominal 1.6ms
      //iframe_length = 8191; //25599 corresponds to nominal 1.6ms
      itrig_delay = 16;//4112;//12,2064;//1610;//wraparound skipped
      timesize = 3199;//199; //3199 cprresponds to nominal 1.6ms

      printf("\nUsing:\n\t frame size = %d\n\t drift time = %d\n", iframe_length, timesize);

      icheck =0;
      ifr=0;
      //irand = 0;
      islow_read =0;
      //iprint = 1;

      nsend=500;

      //******************************************************
      //Initialize XMIT neutrino PCIe
      
      //god
      dwAddrSpace =2;
      u32Data = 0;
      dwOffset = 0x1c;
      WDC_ReadAddr32(hDev5, dwAddrSpace, dwOffset, &u32Data);
      printf ("\n\t==> status T1 word before config = %x ~ ",u32Data);
      dwAddrSpace = 2;
      u32Data =0;
      dwOffset = 0x24;
      WDC_ReadAddr32(hDev5, dwAddrSpace, dwOffset, &u32Data);
      printf ("status T2 word after before = %x\n\n",u32Data);
      //god

      
      
      dwAddrSpace =2;
      u32Data = 0x20000000;    // initial transmitter, no hold
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x20000000;    // initial transmitter, no hold
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
      
      dwAddrSpace =2;
      u32Data = 0x20000000;    // initial receiver
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x20000000;   // initial receiver
      dwOffset = 0x24;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);


      //god
      dwAddrSpace =2;
      u32Data = 0;
      dwOffset = 0x1c;
      WDC_ReadAddr32(hDev5, dwAddrSpace, dwOffset, &u32Data);
      printf ("\n\t==> status T1 word after config = %x ~ ",u32Data);
      dwAddrSpace = 2;
      u32Data =0;
      dwOffset = 0x24;
      WDC_ReadAddr32(hDev5, dwAddrSpace, dwOffset, &u32Data);
      printf ("status T2 word after config = %x\n\n",u32Data);
      //god

      
      dwAddrSpace =2;
      u32Data = 0xfff;    // set mode off with 0xfff...
      dwOffset = 0x28;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
      
     
      //******************************************************
      //lock buffers for i/o communication

      px = &buf_send;
      py = &read_array;
     

      //******************************************************
      //init controller module first

      imod =0;  /* controller module */

      //initialize      
      buf_send[0]=0x0;
      buf_send[1]=0x0;
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);

      // set offline test
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);

      //disable the run command, from the controller
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //trun off run
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);


      //******************************************************
      //    boot up xmit module 1st

      printf("\nBooting XMIT module...\n\n");
      /* inpf = fopen("/home/ub/config_files_041712/xmit_fpga_080612","r"); */
      inpf = fopen("/home/ub/config_files_040213/xmit_fpga_040213","r");
      imod=imod_xmit;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);

      /* read data as characters (28941) */
      usleep(1000);   // wait for a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
	carray[count] = charchannel;
	count++;
	counta++;
	if((count%(nsend*2)) == 0) {
	  buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
	  send_array[0][0] = buf_send[0];
	  if(dummy1 <= 5 ) if (iprint==1) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1] ,carray[2], carray[3]);
	  for (ij=0; ij< nsend; ij++) {
	    if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
	    else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
	    send_array[ij+1][0] = buf_send[ij+1];
	  }
	  nword =nsend+1;
	  i=1;
	  ij = pcie_send(hDev3, i, nword, px);
	  nanosleep(&tim , &tim2);
	  dummy1 = dummy1+1;
	  count =0;
	}
      }
      if(feof(inpf)) {
	if (iprint==1) printf(" You have reached the end-of-file word count= %d %d\n", counta, count);
	buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
	if ( count > 1) {
	  if( ((count-1)%2) ==0) {
	    ik =(count-1)/2;
	  }
	  else {
	    ik =(count-1)/2+1;
	  }
	  ik=ik+2;   // add one more for safety
	  if (iprint==1) printf(" ik= %d\n",ik);
	  for (ij=0; ij<ik; ij++){
	    if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
	    else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
	    send_array[ij+1][0] = buf_send[ij+1];
	  }
	}
	else ik=1;
	for (ij=ik-10; ij< ik+1; ij++) {
	  if (iprint==1) printf(" Last data = %d, %x\n",ij,buf_send[ij]);
	}
	nword =ik+1;
	i=1;
	i = pcie_send(hDev3, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
      
      printf("\n...XMIT booting DONE\n");


      //******************************************************
      //turn on Stratix III power supply
      printf("\n\nBooting FEBs...\n");


      for (imod_fem = (imod_xmit+1); imod_fem< (imod_st+1); imod_fem++) {//loop over module numbers

	imod = imod_fem;
	printf("\n Booting module in slot %d \n", imod);

	// turn on the Stratix III power supply
	ichip =1;
	buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
	i=1;
	k=1;
	i = pcie_send(hDev3, i, k, px);
	usleep(200000);  // wait for 200 ms

	// send configuration data
	/* inpf = fopen("/home/ub/config_files_041712/feb_fpga_080612","r"); */
	/* inpf = fopen("/home/ub/feb_tpc_fpga_sn_zero_test","r"); */
	inpf = fopen("/home/ub/module1x_140820_chi_12_8_2014.rbf","r");
	ichip=mb_feb_conf_add; //ichip=mb_feb_config_add(=2) is for configuration chip
	buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
	i=1;
	k=1;
	i = pcie_send(hDev3, i, k, px);

	usleep(1000);   // wait for a while

	count=0; //keeps track of config file data sent      
	counta=0; //keeps track of total config file data read
	ichip_c=7; //this chip number is actually a "ghost"; it doesn't exist; it's just there so the config chip 
	//doesn't treat the first data word i'll be sending as a command designated for the config chip (had i used ichip_c=1)

	nsend=500; //this defines number of 32bit-word-sized packets I'm allowed to use to send config file data
	dummy1 =0;

	//read info character by character
	while (fread(&charchannel,sizeof(char),1,inpf)==1) {
	  carray[count] = charchannel;
	  count++;
	  counta++;
	  if((count%(nsend*2)) == 0) {
	    buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
	    send_array[0][0] =buf_send[0];
	    if(dummy1 <= 5 ) if (iprint==1) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1], carray[2], carray[3]);
	    for (ij=0; ij< nsend; ij++) {
	      if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
	      else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
	      send_array[ij+1][0] = buf_send[ij+1];
	    }
	    nword =nsend+1;
	    i=1;
	    ij = pcie_send(hDev3, i, nword, px);
	    nanosleep(&tim , &tim2);
	    dummy1 = dummy1+1;
	    count =0;
	  }
	}
	if(feof(inpf)) {
	  if (iprint==1) printf(" You have reached the end-of-file word count= %d %d\n", counta, count);
	  buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
	  if ( count > 1) {
	    if( ((count-1)%2) ==0) {
	      ik =(count-1)/2;
	    }
	    else {
	      ik =(count-1)/2+1;
	    }
	    ik=ik+2;   // add one more for safety
	    if (iprint==1) printf(" ik= %d\n",ik);
	    for (ij=0; ij<ik; ij++){
	      if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
	      else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
	      send_array[ij+1][0] = buf_send[ij+1];
	    }
	  }
	  else ik=1;
	  
	  for (ij=ik-10; ij< ik+1; ij++) {
	    if (iprint==1) printf(" Last data = %d, %x\n",ij,buf_send[ij]);
	  }
	  
	  nword =ik+1;
	  i=1;
	  i = pcie_send(hDev3, i, nword, px);
	}
	usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time

	fclose(inpf);

	printf(" Configuration for module in slot %d COMPLETE.\n",imod);

      }
      printf("\n...FEB booting done \n");


      //******************************************************
      /* set tx mode register */

      u32Data = 0x00003fff;  // set up number of words hold coming back from the XMIT module
      if (iprint==1) printf("\nNumber of words for hold be send back = %x\n",u32Data);
      dwOffset = 0x28;
      dwAddrSpace =2;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);

      //   set up hold
      printf("Setting up hold condition \n");
      dwAddrSpace =2;
      u32Data = 0x8000000;    // set up transmitter to return the hold -- upper transciever
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x8000000;    // set up transmitter to return the hold -- lower transciever
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
      


      //******************************************************
      //Set frame information

      imod=0;
      ichip=1;
      iframe= iframe_length;    //1023
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);

      // load trig 1 position relative to the frame..
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);


      //******************************************************
      //FEB settings
      
      printf("\nSetting up FEB's...\n");

      for (imod_fem = (imod_xmit+1); imod_fem< (imod_st+1); imod_fem++) {

	imod=imod_fem;


	//reset FEB DRAM (step 1)
	ichip=3;
	buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_dram_reset+(0x1<<16);  // turm the DRAM reset on
	i=1;
	k=1;
	i = pcie_send(hDev3, i, k, px);

	//reset FEB DRAM (step 2)
	ichip=3;
	buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_dram_reset+(0x0<<16);  // turm the DRAM reset off
	i=1;
	k=1;
	i = pcie_send(hDev3, i, k, px);
	
	usleep(5000);    // wait for 5 ms for DRAM to be initialized

	//set module number
	ichip=3;
	buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_mod_number+(imod<<16);  // set module number
	i=1;
	k=1;
	i = pcie_send(hDev3, i, k, px);
	
	//******************************************************
	//set test mode
	ichip=mb_feb_pass_add;
	if (femfakedata==1) buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x2<<16);  // set test source to 2
	else buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x0<<16);
	i=1;
	k=1;
	i = pcie_send(hDev3, i, k, px);

	//Data map load moved to the beginning of each event

	/* //load fake FEM data or set up ADC */
	/* if (femfakedata==1){ */

	/*   printf("\nLoading fake FEM data, module %d\n",imod); */
	/*   //start loading the test 2 data memory */
	/*   ichip=3; */
	/*   for (is=0; is<64; is++) { */
	/*     ik = 0x4000+is;                        // load channel address */
	/*     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); // load channe address */
	/*     i = pcie_send(hDev3, 1, 1, px); */
	/*     ibase = 32*is; */
	/*     il = is%8; */
	/*     if(il == 0 && idebug==1) printf(" loading channel %d\n",is); */
	/*     for (ik=0; ik< 256; ik++) {                 // loop over all possible address */
	/*       if(irand ==1) ijk = (rand()) & 0xfff ;        // use random number */
	/*       else ijk= (ibase+ik*8) & 0xfff; */
	/*       //	      if(ihuff == 1) { */
	/* 	if((ik%4) ==0) ic =ijk;        // set data to repeat for 4 samples.... */
	/* 	ijk=ic; */
	/* 	//	      } */
	/*       k = 0x8000+ ijk;        // make sure bit 15-12 is clear for the data */
	/*       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); // load test data */
	/*       i = pcie_send(hDev3, 1, 1, px); */
	/*       send_array[is*256+ik][im]=ijk;           //load up data map */
	/*     } */
	/*   } */
	/* } */

	//******************************************************
	//set compression state    
	imod=imod_fem;
	ichip=3;
	if(ihuff == 1) buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x0<<16);  // turn the compression
	else buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x1<<16);  // set b channel no compression
	i=1;
	k=1;
	i = pcie_send(hDev3, i, k, px);
	
	//sn loop xxx
	imod=imod_fem;
	ichip=3;
	if(ihuff == 1) buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x0<<16);  // turn the compression
	else buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set b channel no compression
	i=1;
	k=1;
	i = pcie_send(hDev3, i, k, px);

	//******************************************************
	//set drift size
	ichip=3;
	buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
	i=1;
	k=1;
	i = pcie_send(hDev3, i, k, px);

	//set id
	a_id =0xf;
	ichip=3;
	buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set a_id
	i=1;
	k=1;
	i = pcie_send(hDev3, i, k, px);

	ichip=4;
	buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set b_id
	i=1;
	k=1;
	i = pcie_send(hDev3, i, k, px);

	//set max word in the pre-buffer memory
	ik=8000;
	ichip=3;
	buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_max+(ik<<16);  // set pre-buffer max word
	i=1;
	k=1;
	i = pcie_send(hDev3, i, k, px);

	//enable hold
	ichip=3;
	buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_hold_enable+(0x1<<16);  // enable the hold
	i=1;
	k=1;
	i = pcie_send(hDev3, i, k, px);

	//this was in SN loop
         if(imod == imod_st) {
	   if (iprint==1) printf(" set last module, module address %d\n", imod);
          ichip=4;
          buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x0<<16);    // set last module on
          i=1;
          k=1;
          i = pcie_send(hDev3, i, k, px);
         }  else {
	   if (iprint==1) printf(" set last module off, module address %d\n", imod);
          ichip=4;
          buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_off+(0x0<<16);    // set last module on
          i=1;
          k=1;
          i = pcie_send(hDev3, i, k, px);
         }


      }//end loop over FEMs
      

      //******************************************************     
      //     now reset all the link port receiver PLL
      for (imod_fem = (imod_st-1); imod_fem > imod_xmit; imod_fem--) {
	imod=imod_fem;
	printf("Resetting link PLL for module %x \n", imod);
	ichip=4;
	buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pll_reset+(0x0<<16);    // reset LINKIN PLL
	i=1;
	k=1;
	i = pcie_send(hDev3, i, k, px);
	usleep(1000);   // give PLL time to reset
      }

      //******************************************************
      //read back status
      for (imod_fem = (imod_xmit+1); imod_fem< (imod_st+1); imod_fem++) {
	for(ooo = 0; ooo < 5; ++ooo) {
	  i = pcie_rec(hDev3,0,1,nword,iprint,py);     // init the receiver
	  imod=imod_fem;
	  ichip=3;
	  buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
	  i=1;
	  k=1;
	  i = pcie_send(hDev3, i, k, px);
	  py = &read_array;
	  i = pcie_rec(hDev3,0,2,nword,iprint,py);     // read out 2 32 bits words
	  printf("\t Sleeping ooo = %d \n", ooo);
	  usleep(5000);
	}

	printf("\nReceived FEB %d (slot %d) status data word = %x, %x \n", imod, imod, read_array[0], read_array[1]);
	    
	printf("----------------------------\n");
	printf("FEB %d (slot %d) status \n", imod,imod);
	printf("----------------------------\n");
	printf("cmd return (20)       : %d\n",(read_array[0] & 0xFF)); //bits 7:0
	printf("check bits 10:8 (0)   : %d\n",((read_array[0]>>8) & 0x7)); //bits 10:8
	printf("module number (%d)    : %d\n",imod,((read_array[0]>>11) & 0x1F)); //bits 15:11
	printf("----------------------------\n");
	printf("check bit  0 (0)      : %d\n",(read_array[0]>>16) & 0x1);
	printf("Right ADC DPA locked  : %d\n",(read_array[0]>>17) & 0x1);
	printf("Left  ADC DPA locked  : %d\n",(read_array[0]>>18) & 0x1);
	printf("SN pre-buf err        : %d\n",(read_array[0]>>19) & 0x1);
	printf("Neutrino pre-buf err  : %d\n",(read_array[0]>>20) & 0x1);
	printf("PLL locked            : %d\n",(read_array[0]>>21) & 0x1);
	printf("SN memory ready       : %d\n",(read_array[0]>>22) & 0x1);
	printf("Neutrino memory ready : %d\n",(read_array[0]>>23) & 0x1);
	printf("ADC lock right        : %d\n",(read_array[0]>>24) & 0x1);
	printf("ADC lock left         : %d\n",(read_array[0]>>25) & 0x1);
	printf("ADC align right       : %d\n",(read_array[0]>>26) & 0x1);
	printf("ADC align left        : %d\n",(read_array[0]>>27) & 0x1);
	printf("check bits 15:12 (0)  : %d\n",(read_array[0]>>28) & 0xf);
	printf("----------------------------\n");
      }
      
      //this was in SN
//     now reset all the link port receiver
//
     for (imod_fem = (imod_st-1); imod_fem > imod_xmit; imod_fem--) {
       imod=imod_fem;
       if (iprint==1) printf(" reset the link for module %d \n", imod);
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rxreset+(0x0<<16);    // reset LINKIN DPA
       i=1;
       k=1;
       i = pcie_send(hDev3, i, k, px);
//
//
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_align+(0x0<<16);    // send alignment command
       i=1;
       k=1;
       i = pcie_send(hDev3, i, k, px);
      }

      printf("\n...FEB setup complete.\n\n");


      //******************************************************
      //XMIT setup

      printf("Setting up XMIT module\n");

      //     set up xmit module  -- module count
      imod=imod_xmit; 
      ichip=3;
      //                  -- number of FEM module -1, counting start at 0
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_modcount+((imod_st-imod_xmit-1)<<16);
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      printf("\t==> imod_st - imod_xmit - 1 = %d\n",imod_st-imod_xmit-1);
      
      //     reset optical
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_opt_dig_reset+(0x1<<16);  // set optical reset on
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);

      //     enable Neutrino Token Passing
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_1+(0x1<<16);  // enable token 1 pass
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);

      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_2+(0x0<<16);  // disable token 2 pass
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);

      //       reset XMIT LINK IN DPA
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_pll_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      usleep(1000);

      //     reset XMIT LINK IN DPA
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);

      //     wait for 10ms just in case
      usleep(10000);

      //     reset XMIT FIFO reset
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_fifo_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);

      /*       //    set up last module to the module next to XMIT */
      /*       imod=imod_xmit+1; */
      /*       //      printf(" set last module on, module address %d\n", imod); */
      /*       ichip=4; */
      /*       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x0<<16);    // set last module on */
      /*       i=1; */
      /*       k=1; */
      /*       i = pcie_send(hDev3, i, k, px); */
      
      for (is=0; is<1; is++) {

	//      test re-align circuit
        imod=imod_xmit;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_word_align+(0x1<<16);  //  send alignment pulse
        i=1;
        k=1;
        i = pcie_send(hDev3, i, k, px);

      }
      usleep(5000); //wait for 5 ms

      nword =1;
      i = pcie_rec(hDev3,0,1,nword,iprint,py);     // init the receiver
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_rdstatus+(0x0<<16);  // read out status

      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      py = &read_array;
      i = pcie_rec(hDev3,0,2,nword,iprint,py);     // read out 2 32 bits words
      printf("XMIT status word = %x, %x \n", read_array[0], read_array[1]);
      check_status(NULL,hDev3,99,99,99,3,3,99,2);

      /*      //\****************************************************** */
      /*       //    set up last module to the module next to XMIT */
      /*       imod=imod_xmit+1; */
      /*       //      printf(" set last module off, module address %d\n", imod); */
      /*       ichip=4; */
      /*       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_off+(0x0<<16);    // set last module off */
      /*       i=1; */
      /*       k=1; */
      /*       i = pcie_send(hDev3, i, k, px); */
      
      usleep(10000);
      

      //******************************************************
      //     now reset all the link port receiver
      
      imod_fem = imod_xmit+1;
      
      while (imod_fem < imod_st){
    	imod= imod_fem+1;
    	ichip=4;
    	buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x0<<16);    // set last module on
    	i=1;
    	k=1;
    	i = pcie_send(hDev3, i, k, px);
    	printf(" set last modulen, module address %d\n", imod);
    	imod =imod_fem;
    	printf(" reset the link for module %d \n", imod);
    	ichip=4;
    	buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rxreset+(0x0<<16);    // reset LINKIN DPA
    	i=1;
    	k=1;
    	i = pcie_send(hDev3, i, k, px);
	
    	ichip=4;
    	buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_align+(0x0<<16);    // send alignment command
    	i=1;
    	k=1;
    	i = pcie_send(hDev3, i, k, px);
    	usleep(1000);

    	imod=imod_fem+1;
    	if(imod != imod_st) {
    	  ichip=4;
    	  buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_off+(0x0<<16);    // set last module off
    	  i=1;
    	  k=1;
    	  i = pcie_send(hDev3, i, k, px);
    	  	  printf(" set last module off, module address %d\n", imod);
    	}
    	imod_fem=imod_fem+1;
      }
      
      printf("\n...XMIT setup complete\n");
      //check_status(NULL,hDev3,99,99,99,3,3,99,2);


      //******************************************************
      //      turn the run on to start data flow

      printf("\n*****************************************************\n");
      printf("*****************************************************\n");
      
      printf("\n=========> RUN ON!\n");

      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev3, i, k, px);
      
      usleep(10000);
      
      if (ihuff==0){
	nword = (((64*timesize*3)/2+5)*(imod_st-imod_xmit))+2;  //total number of 32 bits word
      }
      else {
	printf("I DON'T KNOW THE COMPRESSION FACTOR! :( ...\n");
	printf("I'm going to assume uncompressed data. You may get DMA timeouts. Enter 1 to acknowledge this.\n");
	scanf("%d",&ik);
	nword = (((64*timesize*3)/2+5)*(imod_st-imod_xmit))+2; 
      }

      printf(" Event length is %d words\n", nword); 
      last_dma_loop_size = (nword*4) % dwDMABufSize;          // last dma loop size
      //      ndma_loop = (nword*4)/dwDMABufSize;

      ndma_loop = nmod-1;
      //vic

      ifr=0;

      printf(" DMA will run %d loop(s) per event\n", (ndma_loop+1));
      printf("\t%d loops with %d words and %d loop with %d words\n\n",ndma_loop,dwDMABufSize/4,1,(nword)%(dwDMABufSize/4));

      //variables for data checking
      nc=0;
      iset=0;
      ncount=0;
      nwords=0;
      ibin=1;
      ic=0;      
      ih=0;
      set=0;
      
      //******************************************************	    
      for (ijk=0; ijk< nevent; ijk++) {
	
	if (ijk%100==0) printf("\n===================> EVENT No. %i\n\n",ijk+1);


	// load trig 1 position relative to the frame..
	/**
	   imod=0;
	   itrig_delay = ijk*256*8+16;
	   ichip=1;
	   buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
	   i=1;
	   k=1;
	   i = pcie_send(hDev3, i, k, px);
	**/

	ntot_rec=0;//keeps track of number of words received in event

	//god
	dwAddrSpace =2;
	u32Data =0;
	dwOffset = 0x1c;
	WDC_ReadAddr32(hDev5, dwAddrSpace, dwOffset, &u32Data);
	printf ("\n\t==> status T1 word before first DMA = %x ~ ",u32Data);
	dwAddrSpace =2;
	u32Data =0;
	dwOffset = 0x24;
	WDC_ReadAddr32(hDev5, dwAddrSpace, dwOffset, &u32Data);
	printf ("status T2 word before first DMA = %x\n\n",u32Data);
	//god

	for (iv=0; iv<(ndma_loop+1); iv++) {

	  if(ifr ==0) {//first dma

	    if (idebug==1) printf(" buffer allocation 1\n");
	    dwStatus = WDC_DMAContigBufLock(hDev5, &pbuf_rec1, dwOptions_rec, dwDMABufSize, &pDma_rec1);
	    if (WD_STATUS_SUCCESS != dwStatus) {
	      printf("Failed locking a rec 1 Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
	      printf("enter 1 to continue \n");
	      scanf("%d",&is);
	    }
	    else {
	      u32Data = pDma_rec1->Page->pPhysicalAddr & 0xffffffff;
	      if (idebug==1) printf(" buffer allocation lower address = %x\n", u32Data);
	      u32Data = (pDma_rec1->Page->pPhysicalAddr >> 32) & 0xffffffff;
	      if (idebug==1) printf(" buffer allocation higher address = %x\n", u32Data);
	    }

	    if (idebug==1) printf(" buffer allocation 2\n");
	    dwStatus = WDC_DMAContigBufLock(hDev5, &pbuf_rec2, dwOptions_rec, dwDMABufSize, &pDma_rec2);
	    if (WD_STATUS_SUCCESS != dwStatus) {
	      printf("Failed locking a rec 2 Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
	      printf("enter 1 to continue \n");
	      scanf("%d",&is);
	    }
	    else {
	      u32Data = pDma_rec2->Page->pPhysicalAddr & 0xffffffff;
	      if (idebug==1) printf(" buffer allocation 2 lower address = %x\n", u32Data);
	      u32Data = (pDma_rec2->Page->pPhysicalAddr >> 32) & 0xffffffff;
	      if (idebug==1) printf(" buffer allocation 2 higher address = %x\n", u32Data);
	    }
	    
	    /* set tx mode register */
	    u32Data = 0x00002000;
	    dwOffset = tx_md_reg;
	    dwAddrSpace =cs_bar;
	    WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	    
	    /* write this will abort previous DMA */
	    dwAddrSpace =2;
	    dwOffset = cs_dma_msi_abort;
	    u32Data = dma_abort;
	    WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	    
	    /* clear DMA register after the abort */
	    dwAddrSpace =2;
	    dwOffset = cs_dma_msi_abort;
	    u32Data = 0;
	    WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	    if (idebug==1) printf(" initial abort finished \n");
	    
	    
	    //god
	    dwAddrSpace =2;
	    u32Data = 0;
	    dwOffset = 0x1c;
	    WDC_ReadAddr32(hDev5, dwAddrSpace, dwOffset, &u32Data);
	    printf ("\n\t==> status T1 word after end first DMA = %x ~ ",u32Data);
	    dwAddrSpace = 2;
	    u32Data =0;
	    dwOffset = 0x24;
	    WDC_ReadAddr32(hDev5, dwAddrSpace, dwOffset, &u32Data);
	    printf ("status T2 word after end first DMA = %x\n\n",u32Data);
	    //god
      
	    
	  }//end if first dma
	  
	  if((iv%2) == 0) buffp_rec32 = pbuf_rec1;
	  else buffp_rec32 = pbuf_rec2;
	  
	  /* synch cache */
	  //not needed in SL6?
	  if((iv%2) ==0) WDC_DMASyncCpu(pDma_rec1);
	  else WDC_DMASyncCpu(pDma_rec2);	  
	  if(idebug ==1) printf(" synch CPU \n");

	  if(iv != ndma_loop) nwrite_byte = dwDMABufSize;
	  else nwrite_byte = last_dma_loop_size;
	  nwrite_byte = 307109*4;
	  if (iv==0 || iv==ndma_loop) nwrite_byte = 307110*4;

	  for (is=1; is<3; is++) {
	    tr_bar = t1_tr_bar;
	    r_cs_reg = r1_cs_reg;
	    dma_tr = dma_tr1;
	    if(is == 2) {
	      tr_bar = t2_tr_bar;
	      r_cs_reg = r2_cs_reg;
	      dma_tr = dma_tr2;
	    }
	    if(idebug ==1) printf(" is = %d\n",is);
	    /** initialize the receiver ***/
	    u32Data = cs_init;
	    dwOffset = r_cs_reg;
	    dwAddrSpace =cs_bar;

	    // receiver only gets initialize for the 1st time
	    if(ifr ==0) {
	      if (idebug==1) printf(" initialize the input fifo\n");
	      WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	    }
	    
	    /** start the receiver **/
	    dwAddrSpace = cs_bar;
	    u32Data = cs_start+nwrite_byte;   /* 32 bits mode == 4 bytes per word *2 fibers **/
	    if (idebug==1) printf(" DMA loop %d with DMA data length %d \n", iv, nwrite_byte);
	    dwOffset = r_cs_reg;
	    WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	    
	  }

	  ifr=1;

	  /** set up DMA for both transceiver together **/		
	  dwAddrSpace =cs_bar;
	  dwOffset = cs_dma_add_low_reg;
	  if((iv%2) == 0) u32Data = pDma_rec1->Page->pPhysicalAddr & 0xffffffff;
	  else u32Data = pDma_rec2->Page->pPhysicalAddr & 0xffffffff;
	  WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	  
	  dwAddrSpace =cs_bar;
	  dwOffset = cs_dma_add_high_reg;
	  if((iv%2) == 0) u32Data = (pDma_rec1->Page->pPhysicalAddr >> 32) & 0xffffffff;
	  else u32Data = (pDma_rec2->Page->pPhysicalAddr >> 32) & 0xffffffff;
	  WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	  
	  /* byte count */
	  dwAddrSpace =cs_bar;
	  dwOffset = cs_dma_by_cnt;
	  u32Data = nwrite_byte;
	  WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	  

	  /* write this will start DMA */
	  dwAddrSpace =2;
	  dwOffset = cs_dma_cntrl;
	  if((iv%2) == 0) is = (pDma_rec1->Page->pPhysicalAddr >> 32) & 0xffffffff;
	  else is = (pDma_rec2->Page->pPhysicalAddr >> 32) & 0xffffffff;
	  if(is == 0) {
	    if(idebug==1 ) printf(" use 3dw \n");
	    u32Data = dma_tr12+dma_3dw_rec;
	  }
	  else {
	    u32Data = dma_tr12+dma_4dw_rec;
	    //	    if(idebug==1 ) printf(" use 4dw \n");
	  }
	  WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	  printf(" DMA set up done, byte count = %d\n", nwrite_byte);

	  //send trigger on first dma loop
	  if(iv == 0) {


	    incomp=0; 

	    if (femfakedata==1 && ( (icompare==1 && ijk==0) || (icompare==0) ) ){//load fake data only for first event
	      
	      //for (im=0; im<nmod; im++){//loop over modules
	      
	      //******************************************************
	      //Load fake FEM data
	      imod = imod_fem;
	      printf("Loading fake data for module in slot number %d\n",imod);
		
	      ichip=3;
	      
	      for (il=0; il<64; il++) {
		
		ik = 0x4000+il;                        // load channel address
		buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); // load channe address
		i = pcie_send(hDev3, 1, 1, px);
		ibase = il+1;    // set the base value of the ADC data
		
		for (ik=0; ik< 256; ik++) {
		  if(iround == 3) idir =-1;
		  if(iround == 0) idir = 1;
		  iround = iround + idir;
		  in= ibase + iround;
		  if( (ik > 240) & (ik <247)) in=300+ibase;
		  
		  /* if(il%4 == 0) { */
		    //if(ik == 0) printf(" channel %d fake data \n",il);
		    /* printf(" %4d", in); */
		    //if(((ik+1)%16)==0) printf("\n");
		  /* } */

		  k = 0x8000+ in;        // make sure bit 15-12 il clear for the data
		  buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); // load test data
		  i = pcie_send(hDev3, 1, 1, px);
		  send_array[il*256+ik][im]=in;           //load up data map
			 
		}
	      }
	      
	      
	      //god
	      dwAddrSpace =2;
	      u32Data =0;
	      dwOffset = 0x1c;
	      WDC_ReadAddr32(hDev5, dwAddrSpace, dwOffset, &u32Data);
	      printf ("\n\t==> status T1 word before read = %x ~ ",u32Data);
	      dwAddrSpace =2;
	      u32Data =0;
	      dwOffset = 0x24;
	      WDC_ReadAddr32(hDev5, dwAddrSpace, dwOffset, &u32Data);
	      printf ("status T2 word before read = %x\n\n",u32Data);
	      //god

	      /* 	ik = 0x4000+il; */
	      /* 	if (iprint==1) printf("\nch begin %x\nch data\n",ik); */
	      /* 	buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); // load channe address */
	      /* 	i = pcie_send(hDev3, 1, 1, px); */
	      /* 	for (ik=0; ik<256; ik++) {                 // loop over all possible address */
	      /* 	  if (irand==1) in = (rand()) & 0xfff ;    // use random number */
	      /* 	  else in=(ik*1) & 0xfff; */
	      /* 	  //in = 0xaaa;  */
	      /* 	  //in = 0x555; */
	      /* 	  k = 0x8000+ in;        // make sure bit 15-12 is clear for the data */
	      /* 	  buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); // load test data */
	      /* 	  i = pcie_send(hDev3, 1, 1, px); */
	      /* 	  send_array[il*256+ik][im]=in;           //load up data map */
	      /* 	  if (iprint==1) printf("%x\t",in); */
	      /* 	} */
	      /* } */

	      //}
		
		//	      }//data map loaded
	  
	      usleep(5000);
	    }


	    imod=0;
	    ichip=1;
	    buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
	    i=1;
	    k=1;
	    i = pcie_send(hDev3, i, k, px);
	    if (idebug==1) printf(" trigger send  \n");
	    
	    usleep(10000);
	  
	  }


	  /***    check to see if DMA is done or not **/
	  idone =0;
	  for (is=0; is<6000000; is++) {;
	    
	    if (is == 0 || is%100000 == 0 ) {
	    //god
	    dwAddrSpace =2;
	    u32Data =0;
	    dwOffset = 0x1c;
	    WDC_ReadAddr32(hDev5, dwAddrSpace, dwOffset, &u32Data);
	    printf ("\n\t==> status T1 word before read = %x ~ ",u32Data);
	    dwAddrSpace =2;
	    u32Data =0;
	    dwOffset = 0x24;
	    WDC_ReadAddr32(hDev5, dwAddrSpace, dwOffset, &u32Data);
	    printf ("status T2 word before read = %x\n\n",u32Data);
	    //god
	    
	    }
	    
	    dwAddrSpace =cs_bar;
	    u32Data =0;
	    u64Data =0;
	    dwOffset = cs_dma_cntrl;
	    WDC_ReadAddr32(hDev5, dwAddrSpace, dwOffset, &u32Data);

	    
	    
	    
	    /* if(idebug ==1) printf(" receive DMA status word %d %X \n", is, u32Data); */
	    if((u32Data & dma_in_progress) == 0) {
	      idone =1;
	      if(idebug ==1) printf(" receive DMA complete %d \n", is);
	    }
	    if((u32Data & dma_in_progress) == 0) break;
	  }
	  if(idone == 0) {
	    printf("\n %%%%%%%%%%%% Event %d, loop %d, DMA is not finished \n", ijk+1,iv);
	    incomp=1;
	    dwAddrSpace =cs_bar;
	    dwOffset = cs_dma_by_cnt;
	    WDC_ReadAddr64(hDev5, dwAddrSpace, dwOffset, &u64Data);
	    printf (" DMA word count = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
	    

	    if((iv%2) == 0) WDC_DMASyncIo(pDma_rec1);
	    else WDC_DMASyncIo(pDma_rec2);

	    nred = (nwrite_byte-(u64Data &0xffff))/4;
	    printf(" number of 32-bit words received: %d (this DMA) + %d (total before this DMA)\n",nred, ntot_rec);
	    if (iwrite==1 || irawprint==1){
	      for (is=0; is<nred; is++) {
		read_array[is]= *buffp_rec32++;
		if (irawprint==1) read_array_compare[ntot_rec+is] = read_array[is];
		if (irawprint==1 && ijk==0) read_array_1st[ntot_rec+is] = read_array[is];
		if (iwrited==1){
		  fprintf(outf," %8x",read_array[is]);
		  if((((ntot_rec+is+1)%8) ==0)) fprintf(outf,"\n");
		}
	      }
	      scanf("%d",&ik);
	    }
	    ntot_rec=ntot_rec+nred;

	    if (iwritem==1){
	      sprintf(name,"output/fem_testing_xmitnu_%i_%i_%i.dat",tnum,ijk+1,iv);
	      fd = creat(name,0755);
	      n_write = write(fd,read_array,nred*4);
	      close(fd);
	    }
	    else if (iwrite==1 && dmasizewrite==1) {
	      n_write = write(fd,read_array,nred*4);
	    }

	    dwAddrSpace =cs_bar;
	    u64Data =0;
	    dwOffset = t1_cs_reg;
	    WDC_ReadAddr64(hDev5, dwAddrSpace, dwOffset, &u64Data);
	    printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
	    dwAddrSpace =cs_bar;
	    u64Data =0;
	    dwOffset = t2_cs_reg;
	    WDC_ReadAddr64(hDev5, dwAddrSpace, dwOffset, &u64Data);
	    printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));

	    	    
	    /* write this will abort previous DMA */
	    dwAddrSpace =2;
	    dwOffset = cs_dma_msi_abort;
	    u32Data = dma_abort;
	    WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);

	    /* clear DMA register after the abort */
	    dwAddrSpace =2;
	    dwOffset = cs_dma_msi_abort;
	    u32Data = 0;
	    WDC_WriteAddr32(hDev5, dwAddrSpace, dwOffset, u32Data);
	    if (idebug==1) printf(" before abort, type 1 to continue\n");
	    if (idebug==1) scanf("%d",&is);

	  }

	  if(idone == 0) break;
	  printf("\t==> Are we done? \n");
	  //god
	  dwAddrSpace =2;
	  u32Data =0;
	  dwOffset = 0x1c;
	  WDC_ReadAddr32(hDev5, dwAddrSpace, dwOffset, &u32Data);
	  printf ("\n\t==> status T1 word before read = %x ~ ",u32Data);
	  dwAddrSpace =2;
	  u32Data =0;
	  dwOffset = 0x24;
	  WDC_ReadAddr32(hDev5, dwAddrSpace, dwOffset, &u32Data);
	  printf ("status T2 word before read = %x\n\n",u32Data);
	  //god
	  

	  /* synch DMA i/O cache **/
	  //SL6
	  if((iv%2) == 0) WDC_DMASyncIo(pDma_rec1);
	  else WDC_DMASyncIo(pDma_rec2);

	  if(idebug == 1) {
	    dwAddrSpace =cs_bar;
	    u64Data =0;
	    dwOffset = t1_cs_reg;
	    WDC_ReadAddr64(hDev5, dwAddrSpace, dwOffset, &u64Data);
	    printf (" status word for channel 1 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
	    dwAddrSpace =cs_bar;
	    u64Data =0;
	    dwOffset = t2_cs_reg;
	    WDC_ReadAddr64(hDev5, dwAddrSpace, dwOffset, &u64Data);
	    printf (" status word for channel 2 after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
	  }
	  
	  nwrite = nwrite_byte/4;
	  if (iwrite==1 || irawprint==1){
	    for (is=0; is<nwrite; is++) {
	      read_array[is]= *buffp_rec32++;
	      if (irawprint==1) read_array_compare[ntot_rec+is] = read_array[is];
	      if (irawprint==1 && ijk==0) read_array_1st[ntot_rec+is] = read_array[is];
	      if (iwrited==1){
		fprintf(outf," %8x",read_array[is]);
		if((((ntot_rec+is+1)%8) ==0)) fprintf(outf,"\n");
	      }
	    }
	  }
	  if (iwritem==1){
	    sprintf(name,"output/fem_testing_xmitnu_%i_%i_%i.dat",tnum,ijk+1,iv);
	    fd = creat(name,0755);
	    n_write = write(fd,read_array,nwrite*4);
	    close(fd);
	  }
	  else if (iwrite==1 && dmasizewrite==1) {
	    n_write = write(fd,read_array,nwrite*4);
	  }

	  ntot_rec = ntot_rec+nwrite;
	   
	}//end dma loop
	
	printf("\t==> DMA loop is over\n");
	//write to file: full event
	if (iwrite==1 && dmasizewrite==0){
	  n_write = write(fd,read_array_compare,ntot_rec*4);
	}

	//*******************************************************
	//DATA INTEGRITY CHECKS

	//or check data integrity, and compare to first event, if selected
	if (irawprint==1){
	  
	  //*********
	  //check all events, or first event if comparing; no compression
	  if ( ihuff==0 && ((icompare==1 && ijk==0) || (icompare==0))){//first event. no compression!!
	    
	    //initialize auxiliary counters
	    nc=0; //channel counter
	    iset=0; //flag for adc values within a channel
	    ncount=0; //keeps track of words read for each fem
	    nwords=0; //number of words for each fem, from header
	    ic=0; //total words
	    
	    firstokay=1; //is set to 0 if errors found
	    
	    for (ic=0; ic<ntot_rec; ic++){
	      
	      if ((read_array_compare[ic] & 0xf0000000)==0xe0000000){
		if (ch!=64){
		  printf("\n%%%%%%%%ERROR: Missing channels\n");
		  firstokay=0;
		}		//event end last word
		printf("\n\nEvent end %x\n",read_array_compare[ic]);
		if (ic!=(ntot_rec-1)){
		  printf("\n%%%%%%%%ERROR: Missing words\n");
		  firstokay=0;
		}
	      }
	      
	      else if ((read_array_compare[ic] & 0xffffffff)==0xffffffff){
		//beginning of new event
		printf("\n================================================================");
		printf("\nEvent start: %x\n",read_array_compare[ic]);
		set=0;//keeps track of number of fems
		if (ic!=0){
		  printf("\n%%%%%%%%ERROR: ic not 0\n");
		  firstokay=0;
		}
	      }
	      
	      else {
		
		if ((read_array_compare[ic]&0xffff)==0xffff){
		  if (ch!=64 && set!=0){
		    printf("\n%%%%%%%%ERROR: Missing channels\n");
		    firstokay=0;
		  }
		  ch=0;
		  //first FEM header word
		  printf("\n\nFEM first header word\n");
		  printf(" module address (%d)   %d <====\n",imod_xmit+set+1,((read_array_compare[ic]>>16) & 0xfff) & 0x1f);
		  imod=((read_array_compare[ic]>>16) & 0xfff) & 0x1f;
		  printf(" module ID            %d\n", (((read_array_compare[ic]>>16) & 0xfff) >>5) & 0x7f);
		  ih=0;
		  set++;
		}//end if first header word
		else if ((read_array_compare[ic]&0xf000)==0xf000){
		  ih++;
		  if (ih==1){
		    printf("\nHeader words\n");
		    printf(" nwords to read     %d\n", ((read_array_compare[ic] >>16) & 0xfff)+((read_array_compare[ic] & 0xfff)<<12));
		    ncount=0;
		    nwords = ((read_array_compare[ic] >>16) & 0xfff)+((read_array_compare[ic] & 0xfff)<<12);
		  }
		  else if (ih==2){
		    printf(" event number (%d)   %d <====\n",ijk+1,((read_array_compare[ic] >>16) & 0xfff) + ((read_array_compare[ic] & 0xfff) <<12));
		    if (ijk==1) fevnob4[set] = ((read_array_1st[ic] >>16) & 0xfff) + ((read_array_1st[ic] & 0xfff) <<12);
		    else fevnob4[set] = fevno[set];
		    fevno[set] = ((read_array_compare[ic] >>16) & 0xfff) + ((read_array_compare[ic] & 0xfff) <<12);
		    if (fevno[set]-fevnob4[set]!=1 && ijk!=0){
		      printf("%%%%%%%%ERROR: EVENT NOT INCREMENTED!\n");
		      firstokay=0;
		      printf("Enter 1 to continue\t");
		      scanf("%d",&ik);
		    }
		  }
		  else if (ih==3){
		    printf(" frame number       %d\n",((read_array_compare[ic] >>16) & 0xfff) + ((read_array_compare[ic] & 0xfff) <<12));
		    if (ijk==1) ffrnob4[set] = ((read_array_1st[ic] >>16) & 0xfff) + ((read_array_1st[ic] & 0xfff) <<12);
		    else ffrnob4[set] = ffrno[set];
		    ffrno[set] = ((read_array_compare[ic] >>16) & 0xfff) + ((read_array_compare[ic] & 0xfff) <<12);
		    if (ffrno[set]<=ffrnob4[set]  && ijk!=0){
		      printf("%%%%%%%%ERROR: FRAME NOT INCREMENTED!\n");
		      firstokay=0;
		      printf("Enter 1 to continue\t");
		      scanf("%d",&ik);
		    }
		  }
		  else if (ih==4){
		    printf(" checksum           %x\n",    ((read_array_compare[ic] >>16) & 0xfff) + ((read_array_compare[ic] & 0xfff) <<12));
		  }
		  else {
		    printf("%%%%%%%%ERROR: Bad header info!\n");
		    firstokay=0;
		  }
		}//end if header word
		
		else{//adc word
		  
		  if ( ncount<=nwords ){ //while reading lines for this event
		    
		    adc1 = read_array_compare[ic] & 0xffff;
		    adc2 = (read_array_compare[ic] >> 16) & 0xffff;
		      
		    //		    printf("%x\t\%x\n",adc1,adc2);
		    
		    if((adc1 & 0xf000) == 0x4000) { //first word       
		      iset=1;
		      nc=0;
		      ncount=ncount+1;
		      if ((adc1&0xfff)%8==0) printf("\n");
		      printf("\t//%d",(adc1 & 0xfff)); 
		      il = (adc1 & 0xfff);
		      if (il!=ch){
			printf("%%%%%%%%ERROR: bad channel number %d. Should be %d.\n",il,ch);
			firstokay=0;
		      }
		    }
		    
		    else if ((adc1 & 0xf000) == 0x5000) { //last word
		      iset=0;
		      //printf(" %d",(adc1 & 0xfff));
		      ch++;
		      ncount = ncount+1;
		    }
		      
		    else if (iset ==1) { //neither first nor last word; intermediate adc values
		      if ( ihuff==0 && ((adc1&0xf000) != 0x0000)) {
			printf("%%%%%%%%ERROR: adc value is 16-bit\n");
			  firstokay=0;
		      }
		      if (ihuff==0 && femfakedata==1){
			//compare against loaded data map
			if (iprint==1) printf("%x|%x\t",send_array[ch*256+(nc%3200)%256][set-1],read_array_compare[ic] & 0xffff);
			if (send_array[ch*256+(nc%3200)%256][set-1]!=(read_array_compare[ic] & 0xffff)){
			  printf("%%%%%%%%ERROR: DATA mismatch found! Event %i, ch %i, data word %d, counter %d: %x|%x\n",ijk+1,ch,nc,ch*256+(nc%3200)%256,send_array[ch*256+(nc%3200)%256][set-1],(read_array_compare[ic] & 0xffff));
			  if (nc%9600==0) scanf("%d",&ik);
			  //			  printf("mismatch");
			  firstokay=0;
			}
			//			else printf("%%%%%%%%ERROR: DATA match found! Event %i, ch %i, data word %d: %x|%x\n",ijk+1,ch,nc,send_array[ch*256+nc%256][set-1],(read_array_compare[ic] & 0xffff));
			//			else if (nc==0 || nc==1)  printf("%%%%%%%%CHECK: Event %i, ch %i, data word %d: %x|%x\n",ijk+1,ch,nc,send_array[ch*256+(nc%3200)%256][set-1],(read_array_compare[ic] & 0xffff));
		      }
		      ncount = ncount+1;
		      nc=nc+1;//increment adc value counter
		    }
		    
		    else {
		      printf("%%%%%%%%ERROR: I don't know what to do with this word!\n");              
		      printf("%d\t %x\n",ncount,adc1);
		      firstokay=0;
		    }
		    
		    
		    if((adc2 & 0xf000) == 0x4000) { //first word       
		      nc=0;
		      iset=1;
		      ncount=ncount+1;
		      if ((adc2&0xfff)%8==0) printf("\n");
		      printf("\t//%d",(adc2 & 0xfff));
		      il = (adc2 & 0xfff);
		      if (il!=ch){
			printf("%%%%%%%%ERROR: bad channel number %d. Should be %d.\n",il,ch);
			firstokay=0;
		      }
		    }
		    
		    else if ((adc2 & 0xf000) == 0x5000) { //last word
		      iset=0;
		      //printf(" %d",(adc2 & 0xfff));
		      ch++;
		      ncount = ncount+1;
		    }
		    
		    else if (iset ==1) { //neither first nor last word; intermediate adc values
		      if ( ihuff==0 && ((adc2 & 0xf000) != 0x0000)) {
			printf("%%%%%%%%ERROR: adc value is 16-bit\n");
			firstokay=0;
		      }
		      if (ihuff==0 && femfakedata==1){
			//compare against loaded data map
			if (iprint==1) printf("%x|%x\t",send_array[ch*256+(nc%3200)%256][set-1],((read_array_compare[ic]>>16) & 0xffff));
			if (send_array[ch*256+(nc%3200)%256][set-1]!=((read_array_compare[ic]>>16) & 0xffff)){
			  printf("%%%%%%%%ERROR: DATA mismatch found! Event %i, ch %i, data word %d, counter %d: %x|%x\n",ijk+1,ch,nc,ch*256+(nc%3200)%256,send_array[ch*256+(nc%3200)%256][set-1],((read_array_compare[ic]>>16) & 0xffff));
			  if (nc%9600==0) scanf("%d",&ik);
			  //			  printf("mismatch ");
			  firstokay=0;
			}
			//			else printf("%%%%%%%%ERROR: DATA match found! Event %i, ch %i, data word %d: %x|%x\n",ijk+1,ch,nc,send_array[ch*256+nc%256][set-1],((read_array_compare[ic]>>16) & 0xffff));
			//			else if (nc==0 || nc==1)  printf("%%%%%%%%CHECK: Event %i, ch %i, data word %d: %x|%x\n",ijk+1,ch,nc,send_array[ch*256+(nc%3200)%256][set-1],((read_array_compare[ic]>>16) & 0xffff));
		      }
		      ncount = ncount+1;
		      nc=nc+1;//increment adc value counter
		    }
		    
		    else {
		      printf("%%%%%%%%ERROR: I don't know what to do with this word!\n");              
		      printf("%d\t %x\n",ncount,adc2);
		      firstokay=0;
		    }
		    
		  }//end if word is within limit from fem
		  
		}//else if not header word
		
	      }//else if not first or last word
	      
	    }//end loop over words in array
	    
	    
	    if (set!=nmod){
	      printf("\n%%%%%%%%ERROR: Missing FEMs\n");
	      firstokay=0;
	    }
	    
	    if (firstokay!=1){ 
	      printf("\n%%%%%%%%ERROR: Event is not okay!\n");
	      printf("Enter 1 to continue\t");
	      scanf("%d",&ik);
	    }
	    else {
	      printf("\nEVENT %d IS OK!\n\n",ijk+1);
	    }
	    
	    if (ipause==1){
	      printf("Enter 1 to continue\t");
	      scanf("%d",&ik);
	    }
	    
	  }//end if compare and first event, or if just checking all events
	  
	  //*******************************************
	  //if this isn't the first event, and first event is okay check that subsequent events agree with first event
	  if (icompare==1 && ijk!=0){
	    
	    if ((ijk%100)==0) printf("Checked %d events.\n",ijk);
	    
	    for (ic=0; ic<ntot_rec; ic++){

	      if (read_array_compare[ic]!= read_array_1st[ic]){
		
		if (ic==3){//event number
		  if (ijk==1) evnob4 = ((read_array_1st[ic] >>16) & 0xfff) + ((read_array_1st[ic] & 0xfff) <<12);
		  else evnob4 = evno;
		  evno = ((read_array_compare[ic] >>16) & 0xfff) + ((read_array_compare[ic] & 0xfff) <<12);
		  if (evno-evnob4!=1){
		    printf("%%%%%%%%ERROR: EVENT NOT INCREMENTED!\n");
		  }
		}
		else if (ic==4){//frame number
		  if (ijk==1) frnob4 = ((read_array_1st[ic] >>16) & 0xfff) + ((read_array_1st[ic] & 0xfff) <<12);
		  else frnob4 = frno;
		  frno = ((read_array_compare[ic] >>16) & 0xfff) + ((read_array_compare[ic] & 0xfff) <<12);
		  if (frno<=frnob4){
		    printf("%%%%%%%%ERROR: FRAME NOT INCREMENTED!\n");
		  }
		}
		else {
		  
		  if ( (((read_array_compare[ic] >>16) & 0xfff) + ((read_array_compare[ic] & 0xfff) <<12)) ==evno ||
		       (((read_array_compare[ic] >>16) & 0xfff) + ((read_array_compare[ic] & 0xfff) <<12)) ==frno ){
		    //		    printf("event number and frame number\n");
		    //		    printf("word %d\t %x\t current: %x\n",ic,(((read_array_1st[ic] >>16) & 0xfff) + ((read_array_1st[ic] & 0xfff) <<12)),(((read_array_compare[ic] >>16) & 0xfff) + ((read_array_compare[ic] & 0xfff) <<12)));
		  }
		  else if (ic<100){
		    printf("UNEXPECTED DIFFERENCE!!\n");
		    printf("Event %d\n",ijk+1);
		    printf("word %d\t %x\t current: %x\n",ic,read_array_1st[ic],read_array_compare[ic]);
		    if (ic%20==0){
		      printf("Enter 1 to continue\t");
		      scanf("%d",&is);
		    }
		  }
		}
	      }
	    }
	    
	  }//if comparing, and this is not the first event, and first event was okay
	  
	}//if checking data (irawprint==1)
		
      }//end loop over events

      if (irawprint==1) printf("\nData checking complete.\n");
      if (icompare==1) printf("Compared %d events to first event.\n\n",ijk-1);

      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run off
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);


      if (iwrite==1 && iwritem==0) close(fd);
      if (iwrited==1) fclose(outf);


      
      break;

    }



}
     //&&&&&&&&&&&&&&&&&&&






void trig_module_read(WDC_DEVICE_HANDLE hDev)
{
#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

   static DWORD dwAddrSpace;
   static UINT32 u32Data;
   static unsigned long long u64Data;
   static DWORD dwOffset;
   static UINT32 read_array[100];

   static int is,iused,nwrite,nwrite_byte_n, taskid;
   static int icopy, idebug, read_point_n_tmp;
   static int idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
   static int neu_buf_filled[2], dis, ik;
   static UINT32 *buffp_rec32_n;
   static int ifr=0;
   static int ifr1=0;
   static int i,j,iold;
   static int ipr_trig = 1;
   struct timeval start;


   dwDMABufSize = 1000000;
//
//
//
   if(ifr == 0){
     ifr=1;
     iold = 0xffffff;
   }
   dwAddrSpace =cs_bar;
   dwOffset = t2_cs_reg;
   WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
   i=(u64Data>>32) & 0xffffff;

//
//
   while ((iold - i) >= 16) {
    dwAddrSpace =cs_bar;
    dwOffset = t2_cs_reg;
    WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
    i=(u64Data>>32) & 0xffffff;
//    printf (" receiver 2 status = %8X \n",i);

    if((iold - i) >= 16) {
     if(ifr1 == 0) {
      gettimeofday(&start,NULL);
      read_array[0] = start.tv_sec;
      read_array[1] = start.tv_usec;
      ifr1= 1;
      i= write(fd_trig_pt_m, read_array, 8);
     }
     dwAddrSpace =t2_tr_bar;
     dwOffset = 0x0;
     u64Data =0xbad;
     WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
     read_array[0] = u64Data & 0xffffffff;
     read_array[1] = (u64Data>> 32);
     WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
     read_array[2] = u64Data & 0xffffffff;
     read_array[3] = (u64Data>> 32);

     iold = iold-16;
//
//
     if(ith_fr == 1){
      i= write(fd_trig_pt_m, read_array, 16);
     }
     if(ipr_trig == 1) {
      printf("optical receive data word = %x, %x, %x, %x\n", read_array[0], read_array[1],read_array[2], read_array[3]);
      printf("busy   %d \n", (read_array[0] & 0x1));
      printf("sample number %d \n", ((read_array[0]>>4) & 0xfff));
      printf("16 MHz clock remine %d\n", ((read_array[0]>>1) & 0x7));
      ik = ((read_array[1] & 0xff)<<16) + ((read_array[0] >>16));
      printf("frame number %x \n",ik);
      ik = (read_array[1] >> 8);
      printf("trigger number %x\n",ik);
      printf("PMT trigger data %x\n", (read_array[2] & 0xff));
      printf("PC trig          %x\n", ((read_array[2]>>8) & 0x1));
      printf("External Trig    %x\n", ((read_array[2]>>9) & 0x1));
      printf("Active           %x\n", ((read_array[2]>>10) & 0x1));
      printf("Gate2 In         %x\n", ((read_array[2]>>11) & 0x1));
      printf("Gate1 In         %x\n", ((read_array[2]>>12) & 0x1));
      printf("Veto in          %x\n", ((read_array[2]>>13) & 0x1));
      printf("Calib trig       %x\n", ((read_array[2]>>14) & 0x1));
      printf("64MHz remine     %x\n", ((read_array[2]>>15) & 0x3));
     }
    }
    usleep(200);
    if(iold == i) break;
   }
   return;
}


void  *pt_trig_read(void *threadarg)
{
#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

   static DWORD dwAddrSpace;
   static UINT32 u32Data;
   static unsigned long long u64Data;
   static DWORD dwOffset;
   static UINT32 read_array[100];

   static int is,iused,nwrite,nwrite_byte_n, taskid;
   static int icopy, idebug, read_point_n_tmp;
   static int idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
   static int neu_buf_filled[2], dis, ik;
   static UINT32 *buffp_rec32_n;
   static int ifr=0;
   static int ifr1=0;
   static int i,j,iold;
   static int ipr_trig = 0;
   struct timeval start;

   WDC_DEVICE_HANDLE hDev,hDev1;

   struct thread_data
   {
    int thread_id;
    WDC_DEVICE_HANDLE hDev;
    WDC_DEVICE_HANDLE hDevc;
   };

   struct thread_data *my_data;


   dwDMABufSize = 1000000;
//
//
//
   printf("trigger thread started \n");
   my_data = (struct thread_data *) threadarg;
   taskid = my_data->thread_id;
   hDev = my_data->hDev;
   hDev1 = my_data->hDevc;




   if(ifr == 0){
     ifr=1;
     iold = 0xffffff;
   }
   dwAddrSpace =cs_bar;
   dwOffset = t2_cs_reg;
   WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
   i=(u64Data>>32) & 0xffffff;


//
//
   while (1) {
    dwAddrSpace =cs_bar;
    dwOffset = t2_cs_reg;
    WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
    i=(u64Data>>32) & 0xffffff;
//    printf (" receiver 2 status = %8X \n",i);

    if((iold - i) >= 16) {
     if(ifr1 == 0) {
      gettimeofday(&start,NULL);
      read_array[0] = start.tv_sec;
      read_array[1] = start.tv_usec;
      ifr1= 1;
      i= write(fd_trig_pt_m, read_array, 8);
     }
     dwAddrSpace =t2_tr_bar;
     dwOffset = 0x0;
     u64Data =0xbad;
     WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
     read_array[0] = u64Data & 0xffffffff;
     read_array[1] = (u64Data>> 32);
     WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
     read_array[2] = u64Data & 0xffffffff;
     read_array[3] = (u64Data>> 32);


     iold = iold-16;
//
//
     if(ith_fr == 1){
      i= write(fd_trig_pt_m, read_array, 16);
     }
     if(ipr_trig == 1) {
      printf("optical receive data word = %x, %x, %x, %x\n", read_array[0], read_array[1],read_array[2], read_array[3]);
      printf("busy   %d \n", (read_array[0] & 0x1));
      printf("sample number %d \n", ((read_array[0]>>4) & 0xfff));
      printf("16 MHz clock remine %d\n", ((read_array[0]>>1) & 0x7));
      ik = ((read_array[1] & 0xff)<<16) + ((read_array[0] >>16));
      printf("frame number %x \n",ik);
      ik = (read_array[1] >> 8);
      printf("trigger number %x\n",ik);
      printf("PMT trigger data %x\n", (read_array[2] & 0xff));
      printf("PC trig          %x\n", ((read_array[2]>>8) & 0x1));
      printf("External Trig    %x\n", ((read_array[2]>>9) & 0x1));
      printf("Active           %x\n", ((read_array[2]>>10) & 0x1));
      printf("Gate2 In         %x\n", ((read_array[2]>>11) & 0x1));
      printf("Gate1 In         %x\n", ((read_array[2]>>12) & 0x1));
      printf("Veto in          %x\n", ((read_array[2]>>13) & 0x1));
      printf("Calib trig       %x\n", ((read_array[2]>>14) & 0x1));
      printf("64MHz remine     %x\n", ((read_array[2]>>15) & 0x3));
     }
    }
    usleep(200);
   }
}



void *pt_sn_dma(void *threadarg)
{

#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  mb_cntrl_set_trig1 0x4

     static DWORD dwAddrSpace;
     static UINT32 u32Data, u32Data_h;
     static DWORD dwOffset;

     static int ifr,is,iused,nwrite,nwrite_byte_s, taskid;
     static int icopy, idebug, read_point_s_tmp;
     static int idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
     static int sn_buf_filled[2], dis, ik;
     static int i,k,imod,ichip;
     static UINT32 *buffp_rec32_s;
     UINT32 *px;
     UINT32 buf_send[40];

     WDC_DEVICE_HANDLE hDev,hDev2;

     struct thread_data
     {
      int thread_id;
      WDC_DEVICE_HANDLE hDev;
      WDC_DEVICE_HANDLE hDevc;
     };

     struct thread_data *my_data;


//
//
//
    printf("sn thread started \n");
    dwDMABufSize = 1000000;
    px = &buf_send;
    my_data = (struct thread_data *) threadarg;
    taskid = my_data->thread_id;
    hDev2 = my_data->hDev;
    hDev = my_data->hDevc;
//    printf("\nReceived event notification (device handle 0x%p): ", hDev);
//    printf("\nReceived event notification (device handle 0x%p): ", hDev2);
//
//
     idebug =1;
     ifr = 0;
     for (is=0; is< 2; is++) {
      sn_buf_filled[is] = 0;
     }
     iused =0;
     nwrite_byte_s = dwDMABufSize;
     nwrite = nwrite_byte_s/4;
     write_point_s = 0;
     read_point_s = 0;
     while (1) {
      for (is=1; is<3; is++) {
       tr_bar = t1_tr_bar;
       r_cs_reg = r1_cs_reg;
       dma_tr = dma_tr1;
       if(is == 2) {
        tr_bar = t2_tr_bar;
        r_cs_reg = r2_cs_reg;
        dma_tr = dma_tr2;
       }
       if(idebug ==1) printf(" is = %d\n",is);
/** initialize the receiver ***/
       u32Data = cs_init;
       dwOffset = r_cs_reg;
       dwAddrSpace =cs_bar;
//
// rreceiver only get initialize for the 1st time
//
       if(ifr ==0) {
        printf(" initialize the input fifo -- SN\n");
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       }
//       if(idebug ==1) printf(" SN -- DMA data length %d \n", nwrite_byte_s);
/** start the receiver **/
       dwAddrSpace = cs_bar;
       u32Data = cs_start+nwrite_byte_s;   /* 32 bits mode == 4 bytes per word *2 fibers **/
       if(idebug ==1) printf(" SN -- DMA data length %d \n", nwrite_byte_s);
       dwOffset = r_cs_reg;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      }
      ifr =1;
//
//
/** set up DMA for both transceiver together **/

      if(sn_buf_filled[iused] == 0) {
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_low_reg;
       if(iused ==0)  u32Data = pDma_rec_s1->Page->pPhysicalAddr & 0xffffffff;
       else u32Data = pDma_rec_s2->Page->pPhysicalAddr & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_high_reg;
       if(iused ==0)  u32Data_h = (pDma_rec_s1->Page->pPhysicalAddr >>32) & 0xffffffff;
       else u32Data_h = (pDma_rec_s2->Page->pPhysicalAddr >> 32) & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data_h);


/* byte count */
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_by_cnt;
//       u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
       u32Data = nwrite_byte_s;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


/* write this will start DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_cntrl;
//        is = (pDma_rec_n->Page->pPhysicalAddr >> 32) & 0xffffffff;
       if(u32Data_h == 0) {
//        if(idebug ==1) printf(" use 3dw \n");
        u32Data = dma_tr12+dma_3dw_rec;
       }
       else {
        u32Data = dma_tr12+dma_4dw_rec;
//        if(idebug ==1) printf(" use 4dw \n");
       }
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
//       if(idebug ==1) printf(" trigger ---> DMA set up done, byte count = %d\n", nwrite_byte_s);
//
//
//
       if(ith_fr == 1) {
        if (iused == 0) {
         icopy = 1;
         buffp_rec32_s = pbuf_rec_s2;
        }
        else {
         buffp_rec32_s = pbuf_rec_s1;
         icopy = 0;
        }
        if (sn_buf_filled[icopy] == 1) {
//         printf("start array copy --- SN %d, %d\n",icopy,sn_buf_filled[icopy]);
         pthread_mutex_lock (&mutexlock);
         if(write_point_s >= read_point_s) dis =  jbuf_ev_size - (write_point_s - read_point_s);
         else dis = read_point_s - write_point_s;
         pthread_mutex_unlock (&mutexlock);
//
//       wait for the space to open
//
         while (dis < nwrite) {
          usleep(300);
          pthread_mutex_lock (&mutexlock);
          if(write_point_s >= read_point_s) dis =  jbuf_ev_size - (write_point_s - read_point_s);
          else dis = read_point_s - write_point_s;
          pthread_mutex_unlock (&mutexlock);
         }
//
//
//
//         printf("enter array copy --SN %d %d %d %d\n", iused, icopy, write_point_s, read_point_s);
         read_point_s_tmp =  read_point_s;
         if(write_point_s >= read_point_s_tmp) {
          if((jbuf_ev_size - write_point_s) >= nwrite) {
           for (ik=0; ik< nwrite; ik++) {
            buffer_ev_s[write_point_s+ik] = *buffp_rec32_s++;
           }
           write_point_s = write_point_s+ nwrite;
          }
          else {
           for (ik=0; ik< (jbuf_ev_size-write_point_s); ik++) {
            buffer_ev_s[write_point_s+ik] = *buffp_rec32_s++;
           }
           for (ik=0; ik< (nwrite-(jbuf_ev_size-write_point_s)); ik++) {
            buffer_ev_s[ik] = *buffp_rec32_s++;
           }
           write_point_s = write_point_s+ nwrite- jbuf_ev_size;
          }
         }
         else {
          for (ik=0; ik< nwrite; ik++) {
           buffer_ev_s[write_point_s+ik] = *buffp_rec32_s++;
          }
          write_point_s = write_point_s+ nwrite;
         }
         sn_buf_filled[icopy] = 0;
        }
       }
      }
//
//
//
      idone =0;
      while (idone == 0) {
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_cntrl;
       WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
       if((u32Data & dma_in_progress) == 0) {
        idone =1;
        if(ith_fr == 1) {
         sn_buf_filled[iused] = 1;
         if(iused == 1) iused =0;
         else iused=1;
        }
       }
      }
      printf(" DMA done --SN\n");
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
     }

}


void *pt_trig_dma(void *threadarg)
{

#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

     static DWORD dwAddrSpace;
     static UINT32 u32Data, u32Data_h;
     static DWORD dwOffset;

     static int ifr,is,iused,nwrite,nwrite_byte_n, taskid;
     static int icopy, idebug, read_point_n_tmp;
     static int idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
     static int neu_buf_filled[2], dis, ik;
     static UINT32 *buffp_rec32_n;

     WDC_DEVICE_HANDLE hDev,hDev1;

     struct thread_data
     {
      int thread_id;
      WDC_DEVICE_HANDLE hDev;
      WDC_DEVICE_HANDLE hDevc;
     };

     struct thread_data *my_data;


     dwDMABufSize = 1000000;
//
//
//
     printf("trigger thread started \n");
     my_data = (struct thread_data *) threadarg;
     taskid = my_data->thread_id;
     hDev1 = my_data->hDev;
     hDev = my_data->hDevc;
//
//
//
     idebug =0;
     ifr = 0;
     for (is=0; is< 2; is++) {
      neu_buf_filled[is] = 0;
     }
     iused =0;
     nwrite_byte_n = dwDMABufSize;
     nwrite = nwrite_byte_n/4;
     write_point_n = 0;
     read_point_n = 0;

     while (1) {
      for (is=1; is<3; is++) {
       tr_bar = t1_tr_bar;
       r_cs_reg = r1_cs_reg;
       dma_tr = dma_tr1;
       if(is == 2) {
        tr_bar = t2_tr_bar;
        r_cs_reg = r2_cs_reg;
        dma_tr = dma_tr2;
       }
       if(idebug ==1) printf(" is = %d\n",is);
/** initialize the receiver ***/
       u32Data = cs_init;
       dwOffset = r_cs_reg;
       dwAddrSpace =cs_bar;
//
// rreceiver only get initialize for the 1st time
//
       if(ifr ==0) {
        printf(" initialize the input fifo -- Tr\n");
        WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
       }
/** start the receiver **/
       dwAddrSpace = cs_bar;
       u32Data = cs_start+nwrite_byte_n;   /* 32 bits mode == 4 bytes per word *2 fibers **/
       if(idebug == 1) printf(" trigger -- DMA loop with DMA data length %d \n", nwrite_byte_n);
       dwOffset = r_cs_reg;
       WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);

      }
      ifr =1;
//
//
/** set up DMA for both transceiver together **/

      if(neu_buf_filled[iused] == 0) {
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_low_reg;
       if(iused ==0)  u32Data = pDma_rec_n1->Page->pPhysicalAddr & 0xffffffff;
       else u32Data = pDma_rec_n2->Page->pPhysicalAddr & 0xffffffff;
       WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_high_reg;
       if(iused ==0)  u32Data_h = (pDma_rec_n1->Page->pPhysicalAddr >>32) & 0xffffffff;
       else u32Data_h = (pDma_rec_n2->Page->pPhysicalAddr >> 32) & 0xffffffff;
       WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data_h);


/* byte count */
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_by_cnt;
//       u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
       u32Data = nwrite_byte_n;
       WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);


/* write this will start DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_cntrl;
//        is = (pDma_rec_n->Page->pPhysicalAddr >> 32) & 0xffffffff;
       if(u32Data_h == 0) {
        if(idebug ==1) printf(" use 3dw \n");
        u32Data = dma_tr12+dma_3dw_rec;
       }
       else {
        u32Data = dma_tr12+dma_4dw_rec;
        if(idebug ==1) printf(" use 4dw \n");
       }
       WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
       if(idebug ==1) printf(" trigger ---> DMA set up done, byte count = %d\n", nwrite_byte_n);
//
//
//
       if(ith_fr == 1) {
        if (iused == 0) {
         icopy = 1;
         buffp_rec32_n = pbuf_rec_n2;
        }
        else {
         buffp_rec32_n = pbuf_rec_n1;
         icopy = 0;
        }
        if (neu_buf_filled[icopy] == 1) {
         pthread_mutex_lock (&mutexlock);
         if(write_point_n >= read_point_n) dis =  jbuf_ev_size - (write_point_n - read_point_n);
         else dis = read_point_n - write_point_n;
         pthread_mutex_unlock (&mutexlock);
//
//       wait for the space to open
//
         while (dis < nwrite) {
          usleep(300);
          pthread_mutex_lock (&mutexlock);
          if(write_point_n >= read_point_n) dis =  jbuf_ev_size - (write_point_n - read_point_n);
          else dis = read_point_n - write_point_n;
          pthread_mutex_unlock (&mutexlock);
         }
//
//
//
         read_point_n_tmp =  read_point_n;
         if(write_point_n >= read_point_n_tmp) {
          if((jbuf_ev_size - write_point_n) >= nwrite) {
           for (ik=0; ik< nwrite; ik++) {
            buffer_ev_n[write_point_n+ik] = *buffp_rec32_n++;
           }
           write_point_n = write_point_n+ nwrite;
          }
          else {
           for (ik=0; ik< (jbuf_ev_size-write_point_n); ik++) {
            buffer_ev_n[write_point_n+ik] = *buffp_rec32_n++;
           }
           for (ik=0; ik< (nwrite-(jbuf_ev_size-write_point_n)); ik++) {
            buffer_ev_n[ik] = *buffp_rec32_n++;
           }
           write_point_n = write_point_n+ nwrite- jbuf_ev_size;
          }
         }
         else {
          for (ik=0; ik< nwrite; ik++) {
           buffer_ev_n[write_point_n+ik] = *buffp_rec32_n++;
          }
          write_point_n = write_point_n+ nwrite;
         }
         neu_buf_filled[icopy] = 0;
        }
       }
      }
//
//
//
      idone =0;
      while (idone == 0) {
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_cntrl;
       WDC_ReadAddr32(hDev1, dwAddrSpace, dwOffset, &u32Data);
//       printf(" u32Data = %x \n",u32Data);
       if((u32Data & dma_in_progress) == 0) {
        idone =1;
        if(ith_fr == 1) {
         neu_buf_filled[iused] = 1;
         if(iused == 0) iused =1;
         else iused = 0;
        }
       }
      }
      printf(" DMA done --TR\n");
     }

}





void *pt_trig_filewrite(void *nword_write)
{
   static int file_buf[250000];
   static int w_t1,r_t1,nwrite,dis,is, index, n_write;
   static int read_point_tmp;
   static UINT32 send_array[2];

   dwDMABufSize = 1000000;
   printf("trigger file write thread started \n");
   while (1) {
    w_t1 = write_point_n;
    r_t1 = read_point_n;
    nwrite = dwDMABufSize/4;
    dis =w_t1 - r_t1;
    while (dis< nwrite) {
     w_t1 = write_point_n;
     r_t1 = read_point_n;
     dis =w_t1 - r_t1;
     if (dis < 0) dis = jbuf_ev_size + dis;
     usleep(300);
    }

    if((w_t1 > r_t1) | ((jbuf_ev_size -r_t1)>nwrite)) {
     for (is=0; is<nwrite; is++) {
      file_buf[is] = buffer_ev_n[is+r_t1];
     }
//     read_point_n = read_point_n+nwrite;
     read_point_tmp = read_point_n+nwrite;
    }
    else {
     for (is=0; is<(jbuf_ev_size-r_t1); is++) {
      file_buf[is] = buffer_ev_n[is+r_t1];
     }
     index =0;
     for (is=(jbuf_ev_size-r_t1); is< (nwrite- (jbuf_ev_size-r_t1)); is++) {
      file_buf[is] = buffer_ev_n[index];
      index = index+1;
     }
//     read_point_n = index;
     read_point_tmp = index;
    }
    send_array[0] = nwrite;
    n_write = write(fd_trig_pt,send_array,4);
    n_write = write(fd_trig_pt,file_buf,(nwrite*4));
    read_point_n = read_point_tmp;
    printf(" Neutrino write point = %d, read point %d\n", write_point_n, read_point_n);
   }
}


void *pt_sn_filewrite(void *nword_write)
{
   static int file_buf[250000];
   static int w_t1,r_t1,nwrite,dis,is, index, n_write;
   static int read_point_tmp;
   static UINT32 send_array[2];

   dwDMABufSize = 1000000;
   printf("sn file write thread started \n");
   while (1) {
    w_t1 = write_point_s;
    r_t1 = read_point_s;
    nwrite = dwDMABufSize/4;
    dis =w_t1 - r_t1;
    while (dis< nwrite) {
     w_t1 = write_point_s;
     r_t1 = read_point_s;
     dis =w_t1 - r_t1;
     if (dis < 0) dis = jbuf_ev_size + dis;
     usleep(300);
    }
//    printf("wp, rp %d, %d \n",write_point_s, read_point_s);
    if((w_t1 > r_t1) | ((jbuf_ev_size -r_t1)>nwrite)) {
     for (is=0; is<nwrite; is++) {
      file_buf[is] = buffer_ev_s[is+r_t1];
     }
//     read_point_s = read_point_s+nwrite;
     read_point_tmp = read_point_s+nwrite;
    }
    else {
     for (is=0; is<(jbuf_ev_size-r_t1); is++) {
      file_buf[is] = buffer_ev_s[is+r_t1];
     }
     index =0;
     for (is=(jbuf_ev_size-r_t1); is< (nwrite- (jbuf_ev_size-r_t1)); is++) {
      file_buf[is] = buffer_ev_s[index];
      index = index+1;
     }
//     read_point_s = index;
     read_point_tmp = index;
    }
    send_array[0] = nwrite;
    n_write = write(fd_sn_pt,send_array,4);
    n_write = write(fd_sn_pt,file_buf,(nwrite*4));
    read_point_s = read_point_tmp;
    printf(" SuperNova write point = %d, read point %d\n", write_point_s, read_point_s);
   }
}
//
//
//
void *pt_sn_dma_tpc(void *threadarg)
{

#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  mb_cntrl_set_trig1 0x4

     static DWORD dwAddrSpace;
     static UINT32 u32Data, u32Data_h;
     static DWORD dwOffset;

     static int ifr,is,iused,nwrite,nwrite_byte_s, taskid;
     static int icopy, idebug, read_point_s_tmp;
     static int idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
     static int sn_buf_filled[2], dis, ik;
     static int i,k,imod,ichip;
     static UINT32 *buffp_rec32_s;
     UINT32 *px;
     UINT32 buf_send[40];

     WDC_DEVICE_HANDLE hDev,hDev2;

     struct thread_data
     {
      int thread_id;
      WDC_DEVICE_HANDLE hDev;
      WDC_DEVICE_HANDLE hDevc;
     };

     struct thread_data *my_data;


//
//
//
    printf("sn thread started \n");
    dwDMABufSize = 1000000;
    px = &buf_send;
    my_data = (struct thread_data *) threadarg;
    taskid = my_data->thread_id;
    hDev2 = my_data->hDev;
    hDev = my_data->hDevc;
//    printf("\nReceived event notification (device handle 0x%p): ", hDev);
//    printf("\nReceived event notification (device handle 0x%p): ", hDev2);
//
//
     idebug =1;
     ifr = 0;
     for (is=0; is< 2; is++) {
      sn_buf_filled[is] = 0;
     }
     iused =0;
     nwrite_byte_s = dwDMABufSize;
     nwrite = nwrite_byte_s/4;
     write_point_s_tpc = 0;
     read_point_s_tpc = 0;
     while (1) {
      for (is=1; is<3; is++) {
       tr_bar = t1_tr_bar;
       r_cs_reg = r1_cs_reg;
       dma_tr = dma_tr1;
       if(is == 2) {
        tr_bar = t2_tr_bar;
        r_cs_reg = r2_cs_reg;
        dma_tr = dma_tr2;
       }
       if(idebug ==1) printf(" is = %d\n",is);
/** initialize the receiver ***/
       u32Data = cs_init;
       dwOffset = r_cs_reg;
       dwAddrSpace =cs_bar;
//
// rreceiver only get initialize for the 1st time
//
       if(ifr ==0) {
        printf(" initialize the input fifo -- SN\n");
        WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
       }
//       if(idebug ==1) printf(" SN -- DMA data length %d \n", nwrite_byte_s);
/** start the receiver **/
       dwAddrSpace = cs_bar;
       u32Data = cs_start+nwrite_byte_s;   /* 32 bits mode == 4 bytes per word *2 fibers **/
       if(idebug ==1) printf(" SN -- DMA data length %d \n", nwrite_byte_s);
       dwOffset = r_cs_reg;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      }
      ifr =1;
//
//
/** set up DMA for both transceiver together **/

      if(sn_buf_filled[iused] == 0) {
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_low_reg;
       if(iused ==0)  u32Data = pDma_rec_s1_tpc->Page->pPhysicalAddr & 0xffffffff;
       else u32Data = pDma_rec_s2_tpc->Page->pPhysicalAddr & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_high_reg;
       if(iused ==0)  u32Data_h = (pDma_rec_s1_tpc->Page->pPhysicalAddr >>32) & 0xffffffff;
       else u32Data_h = (pDma_rec_s2_tpc->Page->pPhysicalAddr >> 32) & 0xffffffff;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data_h);


/* byte count */
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_by_cnt;
//       u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
       u32Data = nwrite_byte_s;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);


/* write this will start DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_cntrl;
//        is = (pDma_rec_n->Page->pPhysicalAddr >> 32) & 0xffffffff;
       if(u32Data_h == 0) {
//        if(idebug ==1) printf(" use 3dw \n");
        u32Data = dma_tr12+dma_3dw_rec;
       }
       else {
        u32Data = dma_tr12+dma_4dw_rec;
//        if(idebug ==1) printf(" use 4dw \n");
       }
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
//       if(idebug ==1) printf(" trigger ---> DMA set up done, byte count = %d\n", nwrite_byte_s);
//
//
//
       if(ith_fr == 1) {
        if (iused == 0) {
         icopy = 1;
         buffp_rec32_s = pbuf_rec_s2_tpc;
        }
        else {
         buffp_rec32_s = pbuf_rec_s1_tpc;
         icopy = 0;
        }
        if (sn_buf_filled[icopy] == 1) {
//         printf("start array copy --- SN %d, %d\n",icopy,sn_buf_filled[icopy]);
         pthread_mutex_lock (&mutexlock);
         if(write_point_s_tpc >= read_point_s_tpc) dis =  jbuf_ev_size - (write_point_s_tpc - read_point_s_tpc);
         else dis = read_point_s_tpc - write_point_s_tpc;
         pthread_mutex_unlock (&mutexlock);
//
//       wait for the space to open
//
         while (dis < nwrite) {
          usleep(300);
          pthread_mutex_lock (&mutexlock);
          if(write_point_s_tpc >= read_point_s_tpc) dis =  jbuf_ev_size - (write_point_s_tpc - read_point_s_tpc);
          else dis = read_point_s_tpc - write_point_s_tpc;
          pthread_mutex_unlock (&mutexlock);
         }
//
//
//
//         printf("enter array copy --SN %d %d %d %d\n", iused, icopy, write_point_s, read_point_s);
         read_point_s_tmp =  read_point_s_tpc;
         if(write_point_s_tpc >= read_point_s_tmp) {
          if((jbuf_ev_size - write_point_s_tpc) >= nwrite) {
           for (ik=0; ik< nwrite; ik++) {
            buffer_ev_s_tpc[write_point_s_tpc+ik] = *buffp_rec32_s++;
           }
           write_point_s_tpc = write_point_s_tpc+ nwrite;
          }
          else {
           for (ik=0; ik< (jbuf_ev_size-write_point_s_tpc); ik++) {
            buffer_ev_s_tpc[write_point_s_tpc+ik] = *buffp_rec32_s++;
           }
           for (ik=0; ik< (nwrite-(jbuf_ev_size-write_point_s_tpc)); ik++) {
            buffer_ev_s_tpc[ik] = *buffp_rec32_s++;
           }
           write_point_s_tpc = write_point_s_tpc+ nwrite- jbuf_ev_size;
          }
         }
         else {
          for (ik=0; ik< nwrite; ik++) {
           buffer_ev_s_tpc[write_point_s_tpc+ik] = *buffp_rec32_s++;
          }
          write_point_s_tpc = write_point_s_tpc+ nwrite;
         }
         sn_buf_filled[icopy] = 0;
        }
       }
      }
//
//
//
      idone =0;
      while (idone == 0) {
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_cntrl;
       WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
       if((u32Data & dma_in_progress) == 0) {
        idone =1;
        if(ith_fr == 1) {
         sn_buf_filled[iused] = 1;
         if(iused == 1) iused =0;
         else iused=1;
        }
       }
      }
      printf(" DMA done --SN\n");
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
     }

}


void *pt_trig_dma_tpc(void *threadarg)
{

#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

     static DWORD dwAddrSpace;
     static UINT32 u32Data, u32Data_h;
     static DWORD dwOffset;

     static int ifr,is,iused,nwrite,nwrite_byte_n, taskid;
     static int icopy, idebug, read_point_n_tmp;
     static int idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
     static int neu_buf_filled[2], dis, ik;
     static UINT32 *buffp_rec32_n;

     WDC_DEVICE_HANDLE hDev,hDev1;

     struct thread_data
     {
      int thread_id;
      WDC_DEVICE_HANDLE hDev;
      WDC_DEVICE_HANDLE hDevc;
     };

     struct thread_data *my_data;


     dwDMABufSize = 1000000;
//
//
//
     printf("TPC trigger thread started \n");
     my_data = (struct thread_data *) threadarg;
     taskid = my_data->thread_id;
     hDev1 = my_data->hDev;
     hDev = my_data->hDevc;
//
//
//
     idebug =0;
     ifr = 0;
     for (is=0; is< 2; is++) {
      neu_buf_filled[is] = 0;
     }
     iused =0;
     nwrite_byte_n = dwDMABufSize;
     nwrite = nwrite_byte_n/4;
     write_point_n_tpc = 0;
     read_point_n_tpc = 0;

     while (1) {
      for (is=1; is<3; is++) {
       tr_bar = t1_tr_bar;
       r_cs_reg = r1_cs_reg;
       dma_tr = dma_tr1;
       if(is == 2) {
        tr_bar = t2_tr_bar;
        r_cs_reg = r2_cs_reg;
        dma_tr = dma_tr2;
       }
       if(idebug ==1) printf(" is = %d\n",is);
/** initialize the receiver ***/
       u32Data = cs_init;
       dwOffset = r_cs_reg;
       dwAddrSpace =cs_bar;
//
// rreceiver only get initialize for the 1st time
//
       if(ifr ==0) {
        printf(" initialize the input fifo -- Tr\n");
        WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
       }
/** start the receiver **/
       dwAddrSpace = cs_bar;
       u32Data = cs_start+nwrite_byte_n;   /* 32 bits mode == 4 bytes per word *2 fibers **/
       if(idebug == 1) printf(" trigger -- DMA loop with DMA data length %d \n", nwrite_byte_n);
       dwOffset = r_cs_reg;
       WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);

      }
      ifr =1;
//
//
/** set up DMA for both transceiver together **/

      if(neu_buf_filled[iused] == 0) {
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_low_reg;
       if(iused ==0)  u32Data = pDma_rec_n1_tpc->Page->pPhysicalAddr & 0xffffffff;
       else u32Data = pDma_rec_n2_tpc->Page->pPhysicalAddr & 0xffffffff;
       WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);

       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_add_high_reg;
       if(iused ==0)  u32Data_h = (pDma_rec_n1_tpc->Page->pPhysicalAddr >>32) & 0xffffffff;
       else u32Data_h = (pDma_rec_n2_tpc->Page->pPhysicalAddr >> 32) & 0xffffffff;
       WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data_h);


/* byte count */
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_by_cnt;
//       u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
       u32Data = nwrite_byte_n;
       WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);


/* write this will start DMA */
       dwAddrSpace =2;
       dwOffset = cs_dma_cntrl;
//        is = (pDma_rec_n->Page->pPhysicalAddr >> 32) & 0xffffffff;
       if(u32Data_h == 0) {
        if(idebug ==1) printf(" use 3dw \n");
        u32Data = dma_tr12+dma_3dw_rec;
       }
       else {
        u32Data = dma_tr12+dma_4dw_rec;
        if(idebug ==1) printf(" use 4dw \n");
       }
       WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
       if(idebug ==1) printf(" trigger ---> DMA set up done, byte count = %d\n", nwrite_byte_n);
//
//
//
       if(ith_fr == 1) {
        if (iused == 0) {
         icopy = 1;
         buffp_rec32_n = pbuf_rec_n2_tpc;
        }
        else {
         buffp_rec32_n = pbuf_rec_n1_tpc;
         icopy = 0;
        }
        if (neu_buf_filled[icopy] == 1) {
         pthread_mutex_lock (&mutexlock);
         if(write_point_n_tpc >= read_point_n_tpc) dis =  jbuf_ev_size - (write_point_n_tpc - read_point_n_tpc);
         else dis = read_point_n_tpc - write_point_n_tpc;
         pthread_mutex_unlock (&mutexlock);
//
//       wait for the space to open
//
         while (dis < nwrite) {
          usleep(300);
          pthread_mutex_lock (&mutexlock);
          if(write_point_n_tpc >= read_point_n_tpc) dis =  jbuf_ev_size - (write_point_n_tpc - read_point_n_tpc);
          else dis = read_point_n_tpc - write_point_n_tpc;
          pthread_mutex_unlock (&mutexlock);
         }
//
//
//
         read_point_n_tmp =  read_point_n_tpc;
//         printf(" icopy = %d, neu_buf_filled[icopy] = %d, write_point_n_tpc \n", icopy, neu_buf_filled[icopy], write_point_n_tpc );
//         printf(" %x, %x, %x, %x \n", buffp_rec32_n[0], buffp_rec32_n[1],  buffp_rec32_n[2],  buffp_rec32_n[3]);
         if(write_point_n_tpc >= read_point_n_tmp) {
          if((jbuf_ev_size - write_point_n_tpc) >= nwrite) {
           for (ik=0; ik< nwrite; ik++) {
            buffer_ev_n_tpc[write_point_n_tpc+ik] = *buffp_rec32_n++;
           }
           write_point_n_tpc = write_point_n_tpc+ nwrite;
          }
          else {
           for (ik=0; ik< (jbuf_ev_size-write_point_n_tpc); ik++) {
            buffer_ev_n_tpc[write_point_n_tpc+ik] = *buffp_rec32_n++;
           }
           for (ik=0; ik< (nwrite-(jbuf_ev_size-write_point_n_tpc)); ik++) {
            buffer_ev_n_tpc[ik] = *buffp_rec32_n++;
           }
           write_point_n_tpc = write_point_n_tpc+ nwrite- jbuf_ev_size;
          }
         }
         else {
          for (ik=0; ik< nwrite; ik++) {
           buffer_ev_n_tpc[write_point_n_tpc+ik] = *buffp_rec32_n++;
          }
          write_point_n_tpc = write_point_n_tpc+ nwrite;
         }
         neu_buf_filled[icopy] = 0;
//         printf(" %x, %x, %x, %x \n", buffer_ev_n_tpc[0], buffer_ev_n_tpc[1],  buffer_ev_n_tpc[2],  buffer_ev_n_tpc[3]);
        }
       }
      }
//
//
//
      idone =0;
      while (idone == 0) {
       dwAddrSpace =cs_bar;
       dwOffset = cs_dma_cntrl;
       WDC_ReadAddr32(hDev1, dwAddrSpace, dwOffset, &u32Data);
//       printf(" u32Data = %x \n",u32Data);
       if((u32Data & dma_in_progress) == 0) {
        buffp_rec32_n = pbuf_rec_n1_tpc;
//        printf(" %x, %x, %x, %x \n", buffp_rec32_n[0], buffp_rec32_n[1],  buffp_rec32_n[2],  buffp_rec32_n[3]);
//        printf(" %x, %x, %x, %x \n", buffer_ev_n_tpc[0], buffer_ev_n_tpc[1],  buffer_ev_n_tpc[2],  buffer_ev_n_tpc[3]);
        idone =1;
        if(ith_fr == 1) {
         neu_buf_filled[iused] = 1;
         if(iused == 0) iused =1;
         else iused = 0;
//         printf(" iused = %d, neu_buf_filled[iused] = %d, icopy = %d\n", iused, neu_buf_filled[iused], icopy);
//         printf(" write_point_n_tpc = %d , read_point_n_tpc = %d \n", write_point_n_tpc, read_point_n_tpc);
        }
       }
      }
      printf(" DMA done --TR-- TPC\n");
     }

}





void *pt_trig_filewrite_tpc(void *nword_write)
{
   static int file_buf[250000];
   static int w_t1,r_t1,nwrite,dis,is, index, n_write;
   static int read_point_tmp;
   static UINT32 send_array[2];

   dwDMABufSize = 1000000;
   printf("trigger file write thread started \n");
   while (1) {
    w_t1 = write_point_n_tpc;
    r_t1 = read_point_n_tpc;
    nwrite = dwDMABufSize/4;
    dis =w_t1 - r_t1;
    while (dis< nwrite) {
     w_t1 = write_point_n_tpc;
     r_t1 = read_point_n_tpc;
     dis =w_t1 - r_t1;
     if (dis < 0) dis = jbuf_ev_size + dis;
     usleep(300);
    }

    if((w_t1 > r_t1) | ((jbuf_ev_size -r_t1)>nwrite)) {
     for (is=0; is<nwrite; is++) {
      file_buf[is] = buffer_ev_n_tpc[is+r_t1];
     }
//     read_point_n = read_point_n+nwrite;
     read_point_tmp = read_point_n_tpc+nwrite;
    }
    else {
     for (is=0; is<(jbuf_ev_size-r_t1); is++) {
      file_buf[is] = buffer_ev_n_tpc[is+r_t1];
     }
     index =0;
     for (is=(jbuf_ev_size-r_t1); is< (nwrite- (jbuf_ev_size-r_t1)); is++) {
      file_buf[is] = buffer_ev_n_tpc[index];
      index = index+1;
     }
//     read_point_n = index;
     read_point_tmp = index;
    }
    send_array[0] = nwrite;
    n_write = write(fd_trig_pt_tpc,send_array,4);
    n_write = write(fd_trig_pt_tpc,file_buf,(nwrite*4));
    read_point_n_tpc = read_point_tmp;
    printf(" Neutrino write point TPC = %d, read point %d\n", write_point_n_tpc, read_point_n_tpc);
//    printf(" file_write_tpc %x, %x, %x, %x \n", file_buf[0], file_buf[1], file_buf[2], file_buf[3]);
//    printf(" file_write_tpc %x, %x, %x, %x \n", buffer_ev_n_tpc[0], buffer_ev_n_tpc[1], buffer_ev_n_tpc[2], buffer_ev_n_tpc[3]);
   }
}


void *pt_sn_filewrite_tpc(void *nword_write)
{
   static int file_buf[250000];
   static int w_t1,r_t1,nwrite,dis,is, index, n_write;
   static int read_point_tmp;
   static UINT32 send_array[2];

   dwDMABufSize = 1000000;
   printf("sn file write thread started \n");
   while (1) {
    w_t1 = write_point_s_tpc;
    r_t1 = read_point_s_tpc;
    nwrite = dwDMABufSize/4;
    dis =w_t1 - r_t1;
    while (dis< nwrite) {
     w_t1 = write_point_s_tpc;
     r_t1 = read_point_s_tpc;
     dis =w_t1 - r_t1;
     if (dis < 0) dis = jbuf_ev_size + dis;
     usleep(300);
    }
//    printf("wp, rp %d, %d \n",write_point_s, read_point_s);
    if((w_t1 > r_t1) | ((jbuf_ev_size -r_t1)>nwrite)) {
     for (is=0; is<nwrite; is++) {
      file_buf[is] = buffer_ev_s_tpc[is+r_t1];
     }
//     read_point_s = read_point_s+nwrite;
     read_point_tmp = read_point_s_tpc+nwrite;
    }
    else {
     for (is=0; is<(jbuf_ev_size-r_t1); is++) {
      file_buf[is] = buffer_ev_s_tpc[is+r_t1];
     }
     index =0;
     for (is=(jbuf_ev_size-r_t1); is< (nwrite- (jbuf_ev_size-r_t1)); is++) {
      file_buf[is] = buffer_ev_s_tpc[index];
      index = index+1;
     }
//     read_point_s = index;
     read_point_tmp = index;
    }
    send_array[0] = nwrite;
    n_write = write(fd_sn_pt_tpc,send_array,4);
    n_write = write(fd_sn_pt_tpc,file_buf,(nwrite*4));
    read_point_s_tpc = read_point_tmp;
    printf(" SuperNova write point = %d, read point %d\n", write_point_s_tpc, read_point_s_tpc);
   }
}


//
//
//

int tpc_adc_setup(WDC_DEVICE_HANDLE hDev, int imod_fem, int iframe, int itpc_adc, int ihuff, int icom_factor, int timesize)
{
  
#include "wdc_defs.h"
#define poweroff      0x0
#define poweron       0x1
#define configure_s30 0x2
#define configure_s60 0x3
#define configure_cont 0x20
#define rdstatus      0x80
#define loopback        0x04

#define dcm2_run_off  254
#define dcm2_run_on   255

#define dcm2_online   2
#define dcm2_setmask  3
#define dcm2_offline_busy 4
#define dcm2_load_packet_a 10
#define dcm2_load_packet_b 11
#define dcm2_offline_load 9
#define dcm2_status_read 20
#define dcm2_led_sel     29
#define dcm2_buffer_status_read 30
#define dcm2_status_read_inbuf 21
#define dcm2_status_read_evbuf 22
#define dcm2_status_read_noevnt 23
#define dcm2_zero 12
#define dcm2_compressor_hold 31

#define dcm2_5_readdata 4
#define dcm2_5_firstdcm 8
#define dcm2_5_lastdcm  9
#define dcm2_5_status_read 5
#define dcm2_5_source_id 25
#define dcm2_5_lastchnl 24

#define dcm2_packet_id_a 25
#define dcm2_packet_id_b 26
#define dcm2_hitformat_a 27
#define dcm2_hitformat_b 28

#define part_run_off  254
#define part_run_on   255
#define part_online   2
#define part_offline_busy 3
#define part_offline_hold 4
#define part_status_read 20
#define part_source_id 25


#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  mb_cntrl_add     0x1
#define  mb_cntrl_test_on 0x1
#define  mb_cntrl_test_off 0x0
#define  mb_cntrl_set_run_on 0x2
#define  mb_cntrl_set_run_off 0x3
#define  mb_cntrl_set_trig1 0x4
#define  mb_cntrl_set_trig2 0x5
#define  mb_cntrl_load_frame 0x6
#define  mb_cntrl_load_trig_pos 0x7

#define  mb_feb_power_add 0x1
#define  mb_feb_conf_add 0x2
#define  mb_feb_pass_add 0x3

#define  mb_feb_lst_on          1
#define  mb_feb_lst_off         0
#define  mb_feb_rxreset         2
#define  mb_feb_align           3
#define  mb_feb_pll_reset       5


#define  mb_feb_adc_align       1
#define  mb_feb_a_nocomp        2
#define  mb_feb_b_nocomp        3
#define  mb_feb_blocksize       4
#define  mb_feb_timesize        5
#define  mb_feb_mod_number      6
#define  mb_feb_a_id            7
#define  mb_feb_b_id            8
#define  mb_feb_max             9

#define  mb_feb_test_source    10
#define  mb_feb_test_sample    11
#define  mb_feb_test_frame     12
#define  mb_feb_test_channel   13
#define  mb_feb_test_ph        14
#define  mb_feb_test_base      15
#define  mb_feb_test_ram_data  16

#define  mb_feb_a_test         17
#define  mb_feb_b_test         18

#define  mb_feb_rd_status      20

#define  mb_feb_a_rdhed        21
#define  mb_feb_a_rdbuf        22
#define  mb_feb_b_rdhed        23
#define  mb_feb_b_rdbuf        24

#define  mb_feb_read_probe     30
#define  mb_feb_dram_reset     31
#define  mb_feb_adc_reset      33

#define  mb_a_buf_status       34
#define  mb_b_buf_status       35
#define  mb_a_ham_status       36
#define  mb_b_ham_status       37

#define  mb_feb_a_maxwords     40
#define  mb_feb_b_maxwords     41

#define  mb_feb_hold_enable    42

#define  mb_pmt_adc_reset       1
#define  mb_pmt_spi_add         2
#define  mb_pmt_adc_data_load   3

#define  mb_xmit_conf_add 0x2
#define  mb_xmit_pass_add 0x3

#define  mb_xmit_modcount 0x1
#define  mb_xmit_enable_1 0x2
#define  mb_xmit_enable_2 0x3
#define  mb_xmit_test1 0x4
#define  mb_xmit_test2 0x5

#define   mb_xmit_testdata  10

#define  mb_xmit_rdstatus 20
#define  mb_xmit_rdcounters 21
#define  mb_xmit_link_reset    22
#define  mb_opt_dig_reset   23
#define  mb_xmit_dpa_fifo_reset    24
#define  mb_xmit_dpa_word_align    25

#define  mb_trig_run                1
#define  mb_trig_frame_size         2
#define  mb_trig_deadtime_size      3
#define  mb_trig_active_size        4
#define  mb_trig_delay1_size        5
#define  mb_trig_delay2_size        6

#define  mb_trig_calib_delay        8

#define  mb_trig_prescale0         10
#define  mb_trig_prescale1         11
#define  mb_trig_prescale2         12
#define  mb_trig_prescale3         13
#define  mb_trig_prescale4         14
#define  mb_trig_prescale5         15
#define  mb_trig_prescale6         16
#define  mb_trig_prescale7         17
#define  mb_trig_prescale8         18

#define  mb_trig_mask0             20
#define  mb_trig_mask1             21
#define  mb_trig_mask2             22
#define  mb_trig_mask3             23
#define  mb_trig_mask4             24
#define  mb_trig_mask5             25
#define  mb_trig_mask6             26
#define  mb_trig_mask7             27
#define  mb_trig_mask8             28

#define  mb_trig_rd_param          30
#define  mb_trig_pctrig            31
#define  mb_trig_rd_status         32
#define  mb_trig_reset             33
#define  mb_trig_calib             34
#define  mb_trig_rd_gps            35

#define  mb_trig_sel1              40
#define  mb_trig_sel2              41
#define  mb_trig_sel3              42
#define  mb_trig_sel4              43

#define  mb_trig_p1_delay          50
#define  mb_trig_p1_width          51
#define  mb_trig_p2_delay          52
#define  mb_trig_p2_width          53
#define  mb_trig_p3_delay          54
#define  mb_trig_p3_width          55
#define  mb_trig_pulse_delay       58

#define  mb_trig_pulse1            60
#define  mb_trig_pulse2            61
#define  mb_trig_pulse3            62

#define  mb_shaper_pulsetime        1
#define  mb_shaper_dac              2
#define  mb_shaper_pattern          3
#define  mb_shaper_write            4
#define  mb_shaper_pulse            5
#define  mb_shaper_entrig           6

#define  mb_feb_pmt_gate_size      47
#define  mb_feb_pmt_beam_delay     48
#define  mb_feb_pmt_beam_size      49

#define  mb_feb_pmt_ch_set         50
#define  mb_feb_pmt_delay0         51
#define  mb_feb_pmt_delay1         52
#define  mb_feb_pmt_precount       53
#define  mb_feb_pmt_thresh0        54
#define  mb_feb_pmt_thresh1        55
#define  mb_feb_pmt_thresh2        56
#define  mb_feb_pmt_thresh3        57
#define  mb_feb_pmt_width          58
#define  mb_feb_pmt_deadtime       59
#define  mb_feb_pmt_window         60
#define  mb_feb_pmt_words          61
#define  mb_feb_pmt_cos_mul        62
#define  mb_feb_pmt_cos_thres      63
#define  mb_feb_pmt_mich_mul       64
#define  mb_feb_pmt_mich_thres     65
#define  mb_feb_pmt_beam_mul       66
#define  mb_feb_pmt_beam_thres     67
#define  mb_feb_pmt_en_top         68
#define  mb_feb_pmt_en_upper       69
#define  mb_feb_pmt_en_lower       70
#define  mb_feb_pmt_blocksize      71

#define  mb_feb_pmt_test           80
#define  mb_feb_pmt_clear          81
#define  mb_feb_pmt_test_data      82
#define  mb_feb_pmt_pulse          83

#define  mb_feb_pmt_rxreset        84
#define  mb_feb_pmt_align_pulse    85
#define  mb_feb_pmt_rd_counters    86

#define  dma_buffer_size        10000000


    static UINT32 u32Data;
    static unsigned short u16Data;

    static long imod,ichip;
    unsigned short *buffp;


    static UINT32 i,j,k,ifr,nread,iprint,iwrite,ik,il,is,checksum;

    static UINT32 send_array[40000],read_array[1000];

    static UINT32 nmask,index,itmp,nword_tot,nevent,iv,ijk,islow_read;
    static UINT32 imod_p,imod_trig,imod_shaper;

    static int icomp_l,comp_s,ia,ic;

    DWORD dwStatus;
    DWORD dwOptions = DMA_FROM_DEVICE;
    UINT32 iread,icheck,izero;
    UINT32 buf_send[40000];
    static int   count,num,counta,nword,ireadback,nloop,ierror;
    static int   ij,nsend,iloop,inew,idma_readback,iadd,jevent;
    static int   itest,irun,ichip_c,dummy1,itrig_c;
    static int   idup,ihold,idouble,ihold_set,istatus_read;
    static int   idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
    static int   ipulse,ibase,a_id,itrig_delay;
    static int   iset,ncount,nsend_f,nwrite,itrig_ext;
    static int   imod_xmit,idiv,isample,irand;
    static int   iframe_length, itrig,idrift_time,ijtrig;
    static int   idelay0, idelay1, threshold0, threshold1, pmt_words;
    static int   cos_mult, cos_thres, en_top, en_upper, en_lower;
    static int   irise, ifall, istart_time, use_pmt, pmt_testpulse;
    static int   ich_head, ich_sample, ich_frm,idebug,ntot_rec,nred;
    static int   ineu,ibusy_send,ibusy_test,ihold_word,ndma_loop;
    static int   irawprint,ifem_fst,ifem_lst,ifem_loop;
    static int   pmt_deadtime,pmt_mich_window;
    static int   oframe,osample,odiv,cframe,csample,cdiv;
    static int   idac_shaper, pmt_dac_scan, pmt_precount;
    unsigned char    charchannel;
    unsigned char    carray[4000];
    struct timespec tim, tim2;
    tim.tv_sec = 0;
    tim.tv_nsec =128000;


    PVOID pbuf_rec;
    WD_DMA *pDma_rec;
    DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_CACHE;
//    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_CACHE | DMA_ALLOW_64BIT_ADDRESS;
    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_64BIT_ADDRESS;


    UINT32 *px, *py, *py1;

    FILE *outf,*inpf;
//
//
//
    px = &buf_send;
    py = &read_array;

    irand =1;
    imod = imod_fem;
    ichip =1;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);

    usleep(200000);  // wait for 200 ms
//
    usleep(10000);   // wait for 10ms
    inpf = fopen("/home/ub/feb_fpga_test_new_head","r");
    printf(" start booting FEM %d\n", imod);
    ichip=mb_feb_conf_add;
    buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
    usleep(1000);   // wait fior a while
    nsend = 500;
    count = 0;
    counta= 0;
    ichip_c = 7; // set ichip_c to stay away from any other command in the
    dummy1 =0;
    while (fread(&charchannel,sizeof(char),1,inpf)==1) {
     carray[count] = charchannel;
     count++;
     counta++;
     if((count%(nsend*2)) == 0) {
      buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
      send_array[0] =buf_send[0];
      if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
     ,carray[2], carray[3]);
      for (ij=0; ij< nsend; ij++) {
       if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
       else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//      buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
       send_array[ij+1] = buf_send[ij+1];
      }
      nword =nsend+1;
      i=1;
//       if(dummy1 == 0)
      ij = pcie_send(hDev, i, nword, px);
      nanosleep(&tim , &tim2);
      dummy1 = dummy1+1;
      count =0;
     }
    }
    if(feof(inpf)) {
     printf("You have reached the end-of-file word count= %d %d\n", counta, count);
     buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
     if ( count > 1) {
      if( ((count-1)%2) ==0) {
       ik =(count-1)/2;
      }
      else {
       ik =(count-1)/2+1;
      }
      ik=ik+2;   // add one more for safety
      printf("ik= %d\n",ik);
      for (ij=0; ij<ik; ij++){
       if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
       else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
       send_array[ij+1] = buf_send[ij+1];
      }
     }
     else ik=1;

     for (ij=ik-10; ij< ik+1; ij++) {
      printf("Last data = %d, %x\n",ij,buf_send[ij]);
     }
     nword =ik+1;
     i=1;
     i = pcie_send(hDev, i, nword, px);
    }
    usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
    fclose(inpf);
//
//
//
    printf(" enter 1 to continue \n");
    scanf("%d",&ik);
//
//
//
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_dram_reset+(0x1<<16);  // turm the DRAM reset on
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//        imod=3;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_dram_reset+(0x0<<16);  // turm the DRAM reset off
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);

    usleep(5000);    // wait for 5 ms for DRAM to be initialized

//         imod=3;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_mod_number+(imod<<16);  // set module number
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//
    nword =1;

    i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

//         imod=3;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rd_status+(0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    py = &read_array;
    i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
    printf("receive data word = %x, %x \n", read_array[0], read_array[1]);

    if(itpc_adc == 1) {
//
//      readback status
//
     i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     py = &read_array;
     i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
//
//
     printf("receiv e data word -- after reset = %x, %x \n", read_array[0], read_array[1]);
     printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
     printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
     printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
     printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
     printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
     printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
     printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
     printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
     printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
     printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
     printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
     printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
     printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
     printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
     printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
     printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));

//
//    the ADC spi stream.. The 16 bits data before the last word is r/w, w1, w2 and 13 bits address
//                         the last 16 bits.upper byte = 8 bits data and lower 8 bits ignored.
//
     for (is=0; is<8; is++) {
//      imod=3;
      ichip=5;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(2000);   // sleep for 2ms
      printf(" spi port %d \n",is);
//       scanf("%d",&ik);

//      imod=3;
      ichip=5;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
      buf_send[1]=(((0x0)<<13)+(0xd))+((0xc)<<24)+((0x0)<<16);
//        buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xb;
//

      i=1;
      k=2;
      i = pcie_send(hDev, i, k, px);
      usleep(2000);   // sleep for 2ms
      printf(" spi port 2nd command %d \n",is);
//       scanf("%d",&ik);

//      imod=3;
      ichip=5;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
      buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xff, data =0x1;
//  write to transfer register
//

      i=1;
      k=2;
      i = pcie_send(hDev, i, k, px);
      usleep(2000);   // sleep for 2ms

     }

//       printf(" enter 1 to continue FPGA ADC receiver reset\n");
//       scanf("%d",&ik);
//
//    send FPGA ADC receiver reset
//
//      imod=3;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_reset+(0x1<<16);  // FPGA ADC receiver reset on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);


//       printf(" enter 1 to continue FPGA ADC receiver align\n");
//       scanf("%d",&ik);
//
//    send FPGA ADC align
//
//      imod=3;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_adc_align+(0x0<<16);  // FPGA ADC receiver reset off
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     usleep(1000);
//
//
//
//
//     scanf("%d", &i);
//
     nword = 2;
     i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
//
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//     scanf("%d", &i);
     usleep(10);
     py = &read_array;
     read_array[0] =0;
     i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
     usleep(10);
//
     printf("receiv e data word -- after reset = %x, %x \n", read_array[0], read_array[1]);
     printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
     printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
     printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
     printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
     printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
     printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
     printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
     printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
     printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
     printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
     printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
     printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
     printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
     printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
     printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
     printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));

//       printf(" finish align \n");
//       scanf("%d",&ik);
//
//    the ADC spi stream.. The 16 bits data before the last word is r/w, w1, w2 and 13 bits address
//                         the last 16 bits.upper byte = 8 bits data and lower 8 bits ignored.
//
     for (is=0; is<8; is++) {
//        imod=3;
      ichip=5;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(2000);   // sleep for 2ms
      printf(" spi port %d \n",is);
//       scanf("%d",&ik);

//        imod=3;
      ichip=5;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
//        buf_send[1]=(((0x0)<<13)+(0xd))+((0x9)<<24)+((0x0)<<16);
      buf_send[1]=(((0x0)<<13)+(0xd))+((0x0)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xd, data =0xb;
//

      i=1;
      k=2;
      i = pcie_send(hDev, i, k, px);
      usleep(2000);   // sleep for 2ms
      printf(" spi port 2nd command %d \n",is);
//       scanf("%d",&ik);

//       imod=3;
      ichip=5;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //1st next word will be overwrite by the next next word
      buf_send[1]=(((0x0)<<13)+(0xff))+((0x1)<<24)+((0x0)<<16);
//
//  set /w =0, w1,w2 =0, a12-a0 = 0xff, data =0x1;
//  write to transfer register
//

      i=1;
      k=2;
      i = pcie_send(hDev, i, k, px);
      usleep(2000);   // sleep for 2ms

     }
    }
    else {
     nword =1;
//
// set to use test generator 2, set test =2
//
//       imod=3;
     ichip=mb_feb_pass_add;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_test_source+(0x2<<16);  // set test source to 2
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);


//
//    start loading the test 2 data memory
//
//       imod =11;
     ichip=3;
     for (is=0; is<64; is++) {
      ik = 0x4000+is;                        // load channel address
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((ik & 0xffff)<<16); // load channe address
      i = pcie_send(hDev, 1, 1, px);
      ibase = 32*is;
      il = is%8;
      if(il == 0) printf(" loading channel %d\n",is);
      for (ik=0; ik< 256; ik++) {                 // loop over all possible address
       if(irand ==1) ijk = rand() & 0xfff ;        // use random number
       else ijk= (ibase+ik*8) & 0xfff;
//          else {
//            if(ik ==0) ijk =0x111;
//            else ijk= (ibase+ik*8) & 0xfff;
//           }
       if(ihuff == 1) {
        if((ik%icom_factor) ==0) ic =ijk;        // set data to repeat for 4 samples....
         ijk=ic;
       }
       k = 0x8000+ ijk;        // make sure bit 15-12 is clear for the data
       buf_send[0]=(imod<<11)+(ichip<<8)+(mb_feb_test_ram_data)+((k & 0xffff)<<16); // load test data
       i = pcie_send(hDev, 1, 1, px);
       send_array[is*256+ik]=ijk;           //load up data map
      }
     }
     ichip=3;
     if(ihuff == 1) buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x0<<16);  // turn the compression
     else buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x1<<16);  // set b channel no compression
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
    }
//
//
//    set compression or not
//
    ichip =3;
    if(ihuff == 1)buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x0<<16);  // turn the compression
    else buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_nocomp+(0x1<<16);  // set b channel no compression
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//    printf(" type 1 to continue, ihuff = %d\n", ihuff);
//    scanf("%d", &i);
//    if(ihuff == 1) buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x0<<16);  // turn the compression
//    else buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x1<<16);  // set b channel no compression

    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_nocomp+(0x0<<16); // always turn on supernova compression
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    
//         timesize =4;
//         imod=3;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_timesize+(timesize<<16);  // set drift time size
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);

    a_id =0xf;
//         imod=3;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set a_id
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);

//       imod=11;
    ichip=4;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_b_id+(a_id<<16);  // set b_id
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     set max word in the pre-buffer memory
//
    ik=8000;
//         imod=11;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_max+(ik<<16);  // set pre-buffer max word
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//
//
//     enable hold
//
//         imod=11;
    imod = imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_hold_enable+(0x1<<16);  // enable the hold
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    return i;



}

static int pmt_adc_setup(WDC_DEVICE_HANDLE hDev, int imod_fem, int iframe)
{

#include "wdc_defs.h"
#define poweroff      0x0
#define poweron       0x1
#define configure_s30 0x2
#define configure_s60 0x3
#define configure_cont 0x20
#define rdstatus      0x80
#define loopback        0x04

#define dcm2_run_off  254
#define dcm2_run_on   255

#define dcm2_online   2
#define dcm2_setmask  3
#define dcm2_offline_busy 4
#define dcm2_load_packet_a 10
#define dcm2_load_packet_b 11
#define dcm2_offline_load 9
#define dcm2_status_read 20
#define dcm2_led_sel     29
#define dcm2_buffer_status_read 30
#define dcm2_status_read_inbuf 21
#define dcm2_status_read_evbuf 22
#define dcm2_status_read_noevnt 23
#define dcm2_zero 12
#define dcm2_compressor_hold 31

#define dcm2_5_readdata 4
#define dcm2_5_firstdcm 8
#define dcm2_5_lastdcm  9
#define dcm2_5_status_read 5
#define dcm2_5_source_id 25
#define dcm2_5_lastchnl 24

#define dcm2_packet_id_a 25
#define dcm2_packet_id_b 26
#define dcm2_hitformat_a 27
#define dcm2_hitformat_b 28

#define part_run_off  254
#define part_run_on   255
#define part_online   2
#define part_offline_busy 3
#define part_offline_hold 4
#define part_status_read 20
#define part_source_id 25


#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  mb_cntrl_add     0x1
#define  mb_cntrl_test_on 0x1
#define  mb_cntrl_test_off 0x0
#define  mb_cntrl_set_run_on 0x2
#define  mb_cntrl_set_run_off 0x3
#define  mb_cntrl_set_trig1 0x4
#define  mb_cntrl_set_trig2 0x5
#define  mb_cntrl_load_frame 0x6
#define  mb_cntrl_load_trig_pos 0x7

#define  mb_feb_power_add 0x1
#define  mb_feb_conf_add 0x2
#define  mb_feb_pass_add 0x3

#define  mb_feb_lst_on          1
#define  mb_feb_lst_off         0
#define  mb_feb_rxreset         2
#define  mb_feb_align           3
#define  mb_feb_pll_reset       5


#define  mb_feb_adc_align       1
#define  mb_feb_a_nocomp        2
#define  mb_feb_b_nocomp        3
#define  mb_feb_blocksize       4
#define  mb_feb_timesize        5
#define  mb_feb_mod_number      6
#define  mb_feb_a_id            7
#define  mb_feb_b_id            8
#define  mb_feb_max             9

#define  mb_feb_test_source    10
#define  mb_feb_test_sample    11
#define  mb_feb_test_frame     12
#define  mb_feb_test_channel   13
#define  mb_feb_test_ph        14
#define  mb_feb_test_base      15
#define  mb_feb_test_ram_data  16

#define  mb_feb_a_test         17
#define  mb_feb_b_test         18

#define  mb_feb_rd_status      20

#define  mb_feb_a_rdhed        21
#define  mb_feb_a_rdbuf        22
#define  mb_feb_b_rdhed        23
#define  mb_feb_b_rdbuf        24

#define  mb_feb_read_probe     30
#define  mb_feb_dram_reset     31
#define  mb_feb_adc_reset      33

#define  mb_a_buf_status       34
#define  mb_b_buf_status       35
#define  mb_a_ham_status       36
#define  mb_b_ham_status       37

#define  mb_feb_a_maxwords     40
#define  mb_feb_b_maxwords     41

#define  mb_feb_hold_enable    42

#define  mb_pmt_adc_reset       1
#define  mb_pmt_spi_add         2
#define  mb_pmt_adc_data_load   3

#define  mb_xmit_conf_add 0x2
#define  mb_xmit_pass_add 0x3

#define  mb_xmit_modcount 0x1
#define  mb_xmit_enable_1 0x2
#define  mb_xmit_enable_2 0x3
#define  mb_xmit_test1 0x4
#define  mb_xmit_test2 0x5

#define   mb_xmit_testdata  10

#define  mb_xmit_rdstatus 20
#define  mb_xmit_rdcounters 21
#define  mb_xmit_link_reset    22
#define  mb_opt_dig_reset   23
#define  mb_xmit_dpa_fifo_reset    24
#define  mb_xmit_dpa_word_align    25

#define  mb_trig_run                1
#define  mb_trig_frame_size         2
#define  mb_trig_deadtime_size      3
#define  mb_trig_active_size        4
#define  mb_trig_delay1_size        5
#define  mb_trig_delay2_size        6

#define  mb_trig_calib_delay        8

#define  mb_trig_prescale0         10
#define  mb_trig_prescale1         11
#define  mb_trig_prescale2         12
#define  mb_trig_prescale3         13
#define  mb_trig_prescale4         14
#define  mb_trig_prescale5         15
#define  mb_trig_prescale6         16
#define  mb_trig_prescale7         17
#define  mb_trig_prescale8         18

#define  mb_trig_mask0             20
#define  mb_trig_mask1             21
#define  mb_trig_mask2             22
#define  mb_trig_mask3             23
#define  mb_trig_mask4             24
#define  mb_trig_mask5             25
#define  mb_trig_mask6             26
#define  mb_trig_mask7             27
#define  mb_trig_mask8             28

#define  mb_trig_rd_param          30
#define  mb_trig_pctrig            31
#define  mb_trig_rd_status         32
#define  mb_trig_reset             33
#define  mb_trig_calib             34
#define  mb_trig_rd_gps            35

#define  mb_trig_sel1              40
#define  mb_trig_sel2              41
#define  mb_trig_sel3              42
#define  mb_trig_sel4              43

#define  mb_trig_p1_delay          50
#define  mb_trig_p1_width          51
#define  mb_trig_p2_delay          52
#define  mb_trig_p2_width          53
#define  mb_trig_p3_delay          54
#define  mb_trig_p3_width          55
#define  mb_trig_pulse_delay       58

#define  mb_trig_pulse1            60
#define  mb_trig_pulse2            61
#define  mb_trig_pulse3            62

#define  mb_shaper_pulsetime        1
#define  mb_shaper_dac              2
#define  mb_shaper_pattern          3
#define  mb_shaper_write            4
#define  mb_shaper_pulse            5
#define  mb_shaper_entrig           6

#define  mb_feb_pmt_gate_size      47
#define  mb_feb_pmt_beam_delay     48
#define  mb_feb_pmt_beam_size      49

#define  mb_feb_pmt_ch_set         50
#define  mb_feb_pmt_delay0         51
#define  mb_feb_pmt_delay1         52
#define  mb_feb_pmt_precount       53
#define  mb_feb_pmt_thresh0        54
#define  mb_feb_pmt_thresh1        55
#define  mb_feb_pmt_thresh2        56
#define  mb_feb_pmt_thresh3        57
#define  mb_feb_pmt_width          58
#define  mb_feb_pmt_deadtime       59
#define  mb_feb_pmt_window         60
#define  mb_feb_pmt_words          61
#define  mb_feb_pmt_cos_mul        62
#define  mb_feb_pmt_cos_thres      63
#define  mb_feb_pmt_mich_mul       64
#define  mb_feb_pmt_mich_thres     65
#define  mb_feb_pmt_beam_mul       66
#define  mb_feb_pmt_beam_thres     67
#define  mb_feb_pmt_en_top         68
#define  mb_feb_pmt_en_upper       69
#define  mb_feb_pmt_en_lower       70
#define  mb_feb_pmt_blocksize      71

#define  mb_feb_pmt_test           80
#define  mb_feb_pmt_clear          81
#define  mb_feb_pmt_test_data      82
#define  mb_feb_pmt_pulse          83

#define  mb_feb_pmt_rxreset        84
#define  mb_feb_pmt_align_pulse    85
#define  mb_feb_pmt_rd_counters    86

#define  dma_buffer_size        10000000

//    static DWORD dwAddrSpace;

    static UINT32 u32Data;
    static unsigned short u16Data;
//    static unsigned long long u64Data, u64Data1;
//    static DWORD dwOffset;
    static long imod,ichip;
    unsigned short *buffp;

/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
    static UINT32 i,j,k,ifr,nread,iprint,iwrite,ik,il,is,checksum;
//    static UINT32 istop,newcmd,irand,ioffset,kword,lastchnl,ib;
    static UINT32 send_array[40000],read_array[1000];
//    ,read_array1[40000];
//    static UINT32 read_array_c[40000];
//    static UINT32 read_comp[8000];
    static UINT32 nmask,index,itmp,nword_tot,nevent,iv,ijk,islow_read;
    static UINT32 imod_p,imod_trig,imod_shaper;
//    unsigned short idcm_read_array[40000],read_array_s[1600000];
//    static UINT32 idcm_read_array32[40000];
//    static UINT32 idcm_send_array[400000];
//    static UINT32 idcm_verify_array[400000];
    static int icomp_l,comp_s,ia,ic,ihuff;
//    UINT32 *idcm_send_p,*idcm_verify_p,*pbuffp_rec;
//    DWORD dwDMABufSize;
//    PVOID pbuf;
//    WD_DMA *pDma;
    DWORD dwStatus;
    DWORD dwOptions = DMA_FROM_DEVICE;
    UINT32 iread,icheck,izero;
    UINT32 buf_send[40000];
    static int   count,num,counta,nword,ireadback,nloop,ierror;
    static int   ij,nsend,iloop,inew,idma_readback,iadd,jevent;
    static int   itest,irun,ichip_c,dummy1,itrig_c;
    static int  idup,ihold,idouble,ihold_set,istatus_read;
    static int  idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
    static int   timesize,ipulse,ibase,a_id,itrig_delay;
    static int   iset,ncount,nsend_f,nwrite,itrig_ext;
    static int   imod_xmit,idiv,isample;
    static int   iframe_length, itrig,idrift_time,ijtrig;
    static int   idelay0, idelay1, threshold0, threshold1, pmt_words;
    static int   cos_mult, cos_thres, en_top, en_upper, en_lower;
    static int   irise, ifall, istart_time, use_pmt, pmt_testpulse;
    static int   ich_head, ich_sample, ich_frm,idebug,ntot_rec,nred;
    static int   ineu,ibusy_send,ibusy_test,ihold_word,ndma_loop;
    static int   irawprint,ifem_fst,ifem_lst,ifem_loop;
    static int   pmt_deadtime,pmt_mich_window;
    static int   oframe,osample,odiv,cframe,csample,cdiv;
    static int   idac_shaper, pmt_dac_scan, pmt_precount;
    unsigned char    charchannel;
    unsigned char    carray[4000];
    struct timespec tim, tim2;
    tim.tv_sec = 0;
    tim.tv_nsec =128000;


    PVOID pbuf_rec;
    WD_DMA *pDma_rec;
    DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_CACHE;
//    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_CACHE | DMA_ALLOW_64BIT_ADDRESS;
    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_64BIT_ADDRESS;


    UINT32 *px, *py, *py1;

    FILE *outf,*inpf;

//
//
//
    pmt_deadtime = 41; ///set deadtime long so it will not double fired on trailling edge
    pmt_mich_window = 2;
//
//
    threshold0 = 10;   // 100 discriminator threshold 0
    threshold1 = 15;   // 150 discriminator threshold 1
    cos_mult = 1;       // cosmic ray multiplicity threshold
    cos_thres = 20;    // cosmic ray sum ph threshold
    pmt_precount = 1; // set PMT precount
    pmt_words=40;      // number of word to read

//
//
//
 // turn on the Stratix III power supply

    px = &buf_send;
    py = &read_array;

    imod=imod_fem;
    ichip =1;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
    usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);

    usleep(10000); // wait for 10ms
    inpf = fopen("/home/ub/feb_pmt_fpga_test_new_head","r");
    imod=imod_fem;
    ichip=mb_feb_conf_add;
    buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }

             /* read data as characters (28941) */
    usleep(1000);   // wait fior a while
    nsend = 500;
    count = 0;
    counta= 0;
    ichip_c = 7; // set ichip_c to stay away from any other command in the
    dummy1 =0;
    while (fread(&charchannel,sizeof(char),1,inpf)==1) {
     carray[count] = charchannel;
     count++;
     counta++;
     if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
      buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
      send_array[0] =buf_send[0];
      if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
      ,carray[2], carray[3]);
      for (ij=0; ij< nsend; ij++) {
       if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
       else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
       send_array[ij+1] = buf_send[ij+1];
      }
      nword =nsend+1;
      i=1;
//       if(dummy1 == 0)
      ij = pcie_send(hDev, i, nword, px);
      nanosleep(&tim , &tim2);
      dummy1 = dummy1+1;
      count =0;
     }
    }
    if(feof(inpf)) {
     printf("You have reached the end-of-file word count= %d %d\n", counta, count);
     buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
     if ( count > 1) {
      if( ((count-1)%2) ==0) {
       ik =(count-1)/2;
      }
      else {
       ik =(count-1)/2+1;
      }
      ik=ik+2;   // add one more for safety
      printf("ik= %d\n",ik);
      for (ij=0; ij<ik; ij++){
       if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
       else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
       send_array[ij+1] = buf_send[ij+1];
      }
     }
     else ik=1;

     for (ij=ik-10; ij< ik+1; ij++) {
       printf("Last data = %d, %x\n",ij,buf_send[ij]);
     }

     nword =ik+1;
     i=1;
     i = pcie_send(hDev, i, nword, px);
    }
    usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
    fclose(inpf);
//
//
//
    printf(" enter 1 to reset the dram in module %d \n", imod);
    scanf("%d",&ik);
 //      ik =1;
    if(ik ==1) {
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     usleep(5000);    // wait for 5 ms for DRAM to be initialized
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);


    }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);

    nword =1;
    i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    py = &read_array;
    i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
    printf("receive data word = %x, %x \n", read_array[0], read_array[1]);

//
//     set PMT inhibit size to 625
//
//    imod=imod_fem;
//    ichip=3;
//    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_inhib_size+(625<<16);  // set module number
//    i=1;
//    k=1;
//    i = pcie_send(hDev, i, k, px);
//
//     set PMT delay 0 to 4
//
    for (ik=0; ik<40; ik++) {

     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_ch_set+(ik<<16);  // set channel number to be download
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

      usleep(100);

     imod=imod_fem;
     ichip=3;
     idelay0=4;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_delay0+(idelay0<<16);  // set delay0
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//     set PMT delay1 to 12
//
     imod=imod_fem;
     ichip=3;
     idelay1=12;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_delay1+(idelay1<<16);  // set delay 1
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//     set PMT precount
//
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_precount+(pmt_precount<<16);  // set pmt precount
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//     set PMT threshold 0 to 10
//
     imod=imod_fem;
     ichip=3;
//      threshold0=100;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_thresh0+(threshold0<<16);  // set threshold 0
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//     set PMT threshold 1 to 20
//
     imod=imod_fem;
     ichip=3;
//      threshold1=150;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_thresh1+(threshold1<<16);  // set threshold 1
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//     set PMT data words to 40
//
     imod=imod_fem;
     ichip=3;
//    pmt_words=40;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_words+(pmt_words<<16);  // set pmt_words
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

//
//     set PMT deadtime
//
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_deadtime+(pmt_deadtime<<16);  // set pmt dead timr
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//     set PMT Michael window
//
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_window+(pmt_mich_window<<16);  // set pmt Michael window
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
    }
//
//     set PMT cosmic ray trigger multiplicity to 2
//
    imod=imod_fem;
    ichip=3;
//      cos_mult=2;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_cos_mul+(cos_mult<<16);  // set cosmic ray trigger mul
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     set PMT cosmic ray trigger pulse height
//
    imod=imod_fem;
    ichip=3;
//      cos_thres=20;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_cos_thres+(cos_mult<<16);  // set cosmic ray trigger peak
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     disable the top chanell
//
    imod=imod_fem;
    ichip=3;
    en_top=0xff;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_en_top+(en_top<<16);  // enable/disable channel
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     disable the upper chanell
//
    imod=imod_fem;
    ichip=3;
    en_upper=0xffff;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_en_upper+(en_upper<<16);  // enable/disable channel
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     enable all lower channel
//
    imod=imod_fem;
    ichip=3;
    en_lower=0xffff;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_en_lower+(en_lower<<16);  // enable/disable channel
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     set maximum block size
//
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_blocksize+(0xffff<<16);  // set max block size
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_gate_size+(0x50<<16);  // set gate size
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//    set beam delay
//
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_beam_delay+(0x5<<16);  // set gate size
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//    set beam size window
//
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_beam_size+(0x40<<16);  // set gate size
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);


//
//
//     &&&&&&&&&&&&&&&
//
//     set a_id
//
    a_id =0x20;
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     enable hold
//
//         imod=11;
    imod = imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_hold_enable+(0x1<<16);  // enable the hold
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);


//
//     work on the ADC -- set reset pulse
//
    imod=imod_fem;
    ichip=5;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); // reset goes high
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    imod=imod_fem;
    ichip=5;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x1<<16); // reset goes low
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    imod=imod_fem;
    ichip=5;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); // reset goes high
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//      enable ADC clock,
//
    imod=imod_fem;
    ichip=5;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+(0x7<<16); //set spi address
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    imod=imod_fem;
    ichip=5;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0xffff<<16); //load spi data, clock gate enable
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//        load ADC sync data pattern  + set MSB 1st
//
    for (is=1; is<7; is++) {
     imod=imod_fem;
     ichip=5;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     imod=imod_fem;
     ichip=5;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0b00<<16); //sync pattern, b for sync, 7 for skew, 3 for normal
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     imod=imod_fem;
     ichip=5;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x1400<<16); //msb 1st
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
    }
    printf(" enter 1 to continue FPGA ADC receiver reset\n");
//    scanf("%d",&ik);
//
//    send FPGA ADC receiver reset
//
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_rxreset+(0x1<<16);  // FPGA ADC receiver reset on
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//      readback status
//
    i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    py = &read_array;
    i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
    printf("receiv e data word -- after reset = %x, %x \n", read_array[0], read_array[1]);
    printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
    printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
    printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
    printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
    printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
    printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
    printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
    printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
    printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
    printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
    printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
    printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
    printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
    printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
    printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
    printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));
//
//
//
    printf(" enter 1 to continue FPGA ADC receiver align\n");
//    scanf("%d",&ik);
//
//    send FPGA ADC align
//
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_align_pulse+(0x0<<16);  // FPGA ADC receiver reset off
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);

    usleep(5000); // wait for 5ms

//
//      readback status
//
    i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    py = &read_array;
    i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
    printf("receive data word -- after align = %x, %x \n", read_array[0], read_array[1]);
    printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
    printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
    printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
    printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
    printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
    printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
    printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
    printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
    printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
    printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
    printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
    printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
    printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
    printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
    printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
    printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
    printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));
//
//
//
//
    printf(" enter 1 to continue after ADC alignment \n");
//    scanf("%d",&ik);
//
//
//
    for (is=1; is<7; is++) {
     imod=imod_fem;
     ichip=5;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     imod=imod_fem;
     ichip=5;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //sync pattern, b for sync, 7 for skew, 3 for normal
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
    }
    return i;





}

static pmt_link_setup(WDC_DEVICE_HANDLE hDev, int imod_xmit, int imod_st, int supernova)
{
#include "wdc_defs.h"
#include "wdc_defs.h"
#define poweroff      0x0
#define poweron       0x1
#define configure_s30 0x2
#define configure_s60 0x3
#define configure_cont 0x20
#define rdstatus      0x80
#define loopback        0x04

#define dcm2_run_off  254
#define dcm2_run_on   255

#define dcm2_online   2
#define dcm2_setmask  3
#define dcm2_offline_busy 4
#define dcm2_load_packet_a 10
#define dcm2_load_packet_b 11
#define dcm2_offline_load 9
#define dcm2_status_read 20
#define dcm2_led_sel     29
#define dcm2_buffer_status_read 30
#define dcm2_status_read_inbuf 21
#define dcm2_status_read_evbuf 22
#define dcm2_status_read_noevnt 23
#define dcm2_zero 12
#define dcm2_compressor_hold 31

#define dcm2_5_readdata 4
#define dcm2_5_firstdcm 8
#define dcm2_5_lastdcm  9
#define dcm2_5_status_read 5
#define dcm2_5_source_id 25
#define dcm2_5_lastchnl 24

#define dcm2_packet_id_a 25
#define dcm2_packet_id_b 26
#define dcm2_hitformat_a 27
#define dcm2_hitformat_b 28

#define part_run_off  254
#define part_run_on   255
#define part_online   2
#define part_offline_busy 3
#define part_offline_hold 4
#define part_status_read 20
#define part_source_id 25


#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  mb_cntrl_add     0x1
#define  mb_cntrl_test_on 0x1
#define  mb_cntrl_test_off 0x0
#define  mb_cntrl_set_run_on 0x2
#define  mb_cntrl_set_run_off 0x3
#define  mb_cntrl_set_trig1 0x4
#define  mb_cntrl_set_trig2 0x5
#define  mb_cntrl_load_frame 0x6
#define  mb_cntrl_load_trig_pos 0x7

#define  mb_feb_power_add 0x1
#define  mb_feb_conf_add 0x2
#define  mb_feb_pass_add 0x3

#define  mb_feb_lst_on          1
#define  mb_feb_lst_off         0
#define  mb_feb_rxreset         2
#define  mb_feb_align           3
#define  mb_feb_pll_reset       5


#define  mb_feb_adc_align       1
#define  mb_feb_a_nocomp        2
#define  mb_feb_b_nocomp        3
#define  mb_feb_blocksize       4
#define  mb_feb_timesize        5
#define  mb_feb_mod_number      6
#define  mb_feb_a_id            7
#define  mb_feb_b_id            8
#define  mb_feb_max             9

#define  mb_feb_test_source    10
#define  mb_feb_test_sample    11
#define  mb_feb_test_frame     12
#define  mb_feb_test_channel   13
#define  mb_feb_test_ph        14
#define  mb_feb_test_base      15
#define  mb_feb_test_ram_data  16

#define  mb_feb_a_test         17
#define  mb_feb_b_test         18

#define  mb_feb_rd_status      20

#define  mb_feb_a_rdhed        21
#define  mb_feb_a_rdbuf        22
#define  mb_feb_b_rdhed        23
#define  mb_feb_b_rdbuf        24

#define  mb_feb_read_probe     30
#define  mb_feb_adc_reset      33

#define  mb_a_buf_status       34
#define  mb_b_buf_status       35
#define  mb_a_ham_status       36
#define  mb_b_ham_status       37

#define  mb_feb_a_maxwords     40
#define  mb_feb_b_maxwords     41

#define  mb_feb_hold_enable    42

#define  mb_pmt_adc_reset       1
#define  mb_pmt_spi_add         2
#define  mb_pmt_adc_data_load   3

#define  mb_xmit_conf_add 0x2
#define  mb_xmit_pass_add 0x3

#define  mb_xmit_modcount 0x1
#define  mb_xmit_enable_1 0x2
#define  mb_xmit_enable_2 0x3
#define  mb_xmit_test1 0x4
#define  mb_xmit_test2 0x5

#define   mb_xmit_testdata  10

#define  mb_xmit_rdstatus 20
#define  mb_xmit_rdcounters 21
#define  mb_xmit_link_reset    22
#define  mb_opt_dig_reset   23
#define  mb_xmit_dpa_fifo_reset    24
#define  mb_xmit_dpa_word_align    25
#define  mb_xmit_link_pll_reset    26

#define  mb_trig_run                1
#define  mb_trig_frame_size         2
#define  mb_trig_deadtime_size      3
#define  mb_trig_active_size        4
#define  mb_trig_delay1_size        5
#define  mb_trig_delay2_size        6

#define  mb_trig_calib_delay        8

#define  mb_trig_prescale0         10
#define  mb_trig_prescale1         11
#define  mb_trig_prescale2         12
#define  mb_trig_prescale3         13
#define  mb_trig_prescale4         14
#define  mb_trig_prescale5         15
#define  mb_trig_prescale6         16
#define  mb_trig_prescale7         17
#define  mb_trig_prescale8         18

#define  mb_trig_mask0             20
#define  mb_trig_mask1             21
#define  mb_trig_mask2             22
#define  mb_trig_mask3             23
#define  mb_trig_mask4             24
#define  mb_trig_mask5             25
#define  mb_trig_mask6             26
#define  mb_trig_mask7             27
#define  mb_trig_mask8             28

#define  mb_trig_rd_param          30
#define  mb_trig_pctrig            31
#define  mb_trig_rd_status         32
#define  mb_trig_reset             33
#define  mb_trig_calib             34
#define  mb_trig_rd_gps            35

#define  mb_trig_sel1              40
#define  mb_trig_sel2              41
#define  mb_trig_sel3              42
#define  mb_trig_sel4              43

#define  mb_trig_p1_delay          50
#define  mb_trig_p1_width          51
#define  mb_trig_p2_delay          52
#define  mb_trig_p2_width          53
#define  mb_trig_p3_delay          54
#define  mb_trig_p3_width          55
#define  mb_trig_pulse_delay       58

#define  mb_trig_pulse1            60
#define  mb_trig_pulse2            61
#define  mb_trig_pulse3            62

#define  mb_shaper_pulsetime        1
#define  mb_shaper_dac              2
#define  mb_shaper_pattern          3
#define  mb_shaper_write            4
#define  mb_shaper_pulse            5
#define  mb_shaper_entrig           6

#define  mb_feb_pmt_gate_size      47
#define  mb_feb_pmt_beam_delay     48
#define  mb_feb_pmt_beam_size      49

#define  mb_feb_pmt_ch_set         50
#define  mb_feb_pmt_delay0         51
#define  mb_feb_pmt_delay1         52
#define  mb_feb_pmt_precount       53
#define  mb_feb_pmt_thresh0        54
#define  mb_feb_pmt_thresh1        55
#define  mb_feb_pmt_thresh2        56
#define  mb_feb_pmt_thresh3        57
#define  mb_feb_pmt_width          58
#define  mb_feb_pmt_deadtime       59
#define  mb_feb_pmt_window         60
#define  mb_feb_pmt_words          61
#define  mb_feb_pmt_cos_mul        62
#define  mb_feb_pmt_cos_thres      63
#define  mb_feb_pmt_mich_mul       64
#define  mb_feb_pmt_mich_thres     65
#define  mb_feb_pmt_beam_mul       66
#define  mb_feb_pmt_beam_thres     67
#define  mb_feb_pmt_en_top         68
#define  mb_feb_pmt_en_upper       69
#define  mb_feb_pmt_en_lower       70
#define  mb_feb_pmt_blocksize      71

#define  mb_feb_pmt_test           80
#define  mb_feb_pmt_clear          81
#define  mb_feb_pmt_test_data      82
#define  mb_feb_pmt_pulse          83

#define  mb_feb_pmt_rxreset        84
#define  mb_feb_pmt_align_pulse    85
#define  mb_feb_pmt_rd_counters    86

#define  dma_buffer_size        10000000

//    static DWORD dwAddrSpace;

    static UINT32 u32Data;
    static unsigned short u16Data;
//    static unsigned long long u64Data, u64Data1;
//    static DWORD dwOffset;
    static long imod,ichip;
    unsigned short *buffp;

/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
    static UINT32 i,j,k,ifr,nread,iprint,iwrite,ik,il,is,checksum;
//    static UINT32 istop,newcmd,irand,ioffset,kword,lastchnl,ib;
    static UINT32 send_array[40000],read_array[1000];
//    ,read_array1[40000];
//    static UINT32 read_array_c[40000];
//    static UINT32 read_comp[8000];
    static UINT32 nmask,index,itmp,nword_tot,nevent,iv,ijk,islow_read;
    static UINT32 imod_p,imod_trig,imod_shaper;
//    unsigned short idcm_read_array[40000],read_array_s[1600000];
//    static UINT32 idcm_read_array32[40000];
//    static UINT32 idcm_send_array[400000];
//    static UINT32 idcm_verify_array[400000];
    static int icomp_l,comp_s,ia,ic,ihuff;
//    UINT32 *idcm_send_p,*idcm_verify_p,*pbuffp_rec;
//    DWORD dwDMABufSize;
//    PVOID pbuf;
//    WD_DMA *pDma;
    DWORD dwStatus;
    DWORD dwOptions = DMA_FROM_DEVICE;
    UINT32 iread,icheck,izero;
    UINT32 buf_send[40000];
    static int   count,num,counta,nword,ireadback,nloop,ierror;
    static int   ij,nsend,iloop,inew,idma_readback,iadd,jevent;
    static int   itest,irun,ichip_c,dummy1,itrig_c;
    static int  idup,ihold,idouble,ihold_set,istatus_read;
    static int  idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
    static int   timesize,ipulse,ibase,a_id,itrig_delay;
    static int   iset,ncount,nsend_f,nwrite,itrig_ext;
    static int   imod_fem,idiv,isample;
    static int   iframe_length, itrig,idrift_time,ijtrig;
    static int   idelay0, idelay1, threshold0, threshold1, pmt_words;
    static int   cos_mult, cos_thres, en_top, en_upper, en_lower;
    static int   irise, ifall, istart_time, use_pmt, pmt_testpulse;
    static int   ich_head, ich_sample, ich_frm,idebug,ntot_rec,nred;
    static int   ineu,ibusy_send,ibusy_test,ihold_word,ndma_loop;
    static int   irawprint,ifem_fst,ifem_lst,ifem_loop;
    static int   pmt_deadtime,pmt_mich_window;
    static int   oframe,osample,odiv,cframe,csample,cdiv;
    static int   idac_shaper, pmt_dac_scan;
    unsigned char    charchannel;
    unsigned char    carray[4000];
    struct timespec tim, tim2;
    tim.tv_sec = 0;
    tim.tv_nsec =128000;


    PVOID pbuf_rec;
    WD_DMA *pDma_rec;
    DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_CACHE;
//    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_CACHE | DMA_ALLOW_64BIT_ADDRESS;
    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_64BIT_ADDRESS;


    UINT32 *px, *py, *py1;
//
//
     px = &buf_send;
     py = &read_array;
     iprint == 1;
     printf(" link setup imod_st =%d, imod_xmit %d \n", imod_st, imod_xmit);
//
//     now reset all the link port receiver PLL
//
     for (imod_fem = (imod_st-1); imod_fem > imod_xmit; imod_fem--) {
       imod=imod_fem;
       printf(" reset the link PLL for module %x \n", imod);
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pll_reset+(0x0<<16);    // reset LINKIN PLL
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       usleep(1000);   // give PLL time to reset
      }
//
//
//

     for (imod_fem = (imod_xmit+1); imod_fem< (imod_st+1); imod_fem++) {
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       py = &read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iprint == 1) printf("FEM module %d status word after PLL reset = %x, %x \n", imod, read_array[0], read_array[1]);
     }


//
//     now reset all the link port receiver
//
//-     for (imod_fem = (imod_st-1); imod_fem > imod_xmit; imod_fem--) {
//-       imod=imod_fem;
//-       printf(" reset the link for module %d \n", imod);
//-       ichip=4;
//-       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rxreset+(0x0<<16);    // reset LINKIN DPA
//-       i=1;
//-       k=1;
//-       i = pcie_send(hDev, i, k, px);
//
//
//-       ichip=4;
//-       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_align+(0x0<<16);    // send alignment command
//-       i=1;
//-       k=1;
//-       i = pcie_send(hDev, i, k, px);
//-      }

 //
 //
 //
 //
//     set up xmit module  -- module count
//
      imod=imod_xmit;
      ichip=3;
//                  -- number of FEM module -1, counting start at 0
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_modcount+((imod_st-imod_xmit-1)<<16);
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     rest optical
//
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_opt_dig_reset+(0x1<<16);  // set optical reset on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     enable Neutrino/superNova Token Passing
//
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_1+(0x1<<16);  // enable token 1 pass
//      if(supernova == 0) buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_1+(0x1<<16);  // enable token 1 pass
//      else buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_1+(0x0<<16);  // edisable token 1 pass
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
      if(supernova == 0) buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_2+(0x0<<16);  // disable token 2 pass
      else buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_2+(0x1<<16);  // enable token 2 pass
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//
//       printf(" enter 1 to reset the DPA \n");
//       scanf("%d",&ik);

//
//
//       reset XMIT LINK IN DPA
//
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_pll_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(1000);
//
//     reset XMIT LINK IN DPA
//
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     wait for 10ms just in case
//
      usleep(10000);
      printf(" XMIT FIFO reset \n");
//
//     reset XMIT FIFO reset
//
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_fifo_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

//
//    set up last module to the module next to XMIT
//
      imod=imod_xmit+1;
      printf(" set last module on, module address %d\n", imod);
      ichip=4;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x0<<16);    // set last module on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      for (is=0; is<1; is++) {
//
//      test re-align circuit
//
        imod=imod_xmit;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_word_align+(0x1<<16);  //  send alignment pulse
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

//        printf(" enter 1 to set continue on re-align circuit \n");
//        scanf("%d",&ik);
      }
      usleep(5000); //wait for 5 ms
//      printf(" XMIT re-align done \n");
//      scanf("%d",&ik);

      nword =1;

      i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod_xmit<<11)+(ichip<<8)+mb_xmit_rdstatus+(0x0<<16);  // read out status

      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      py = &read_array;
      i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
      printf("xmit status word = %x, %x \n", read_array[0], read_array[1]);


//
//    set up last module to the module next to XMIT
//
      imod=imod_xmit+1;
      printf(" set last module off, module address %d\n", imod);
      ichip=4;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_off+(0x0<<16);    // set last module off
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//
      printf(" finish XMIT alignment \n");
      scanf("%d",&ik);
//
//
//
//

//
//
//     now reset all the link port receiver
//
      imod_fem = imod_xmit+1;
      while (imod_fem < imod_st){
       imod= imod_fem+1;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x0<<16);    // set last module on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       printf(" set last modulen, module address -- alignment %d\n", imod);
       imod =imod_fem;
       printf(" reset the link for module %d \n", imod);
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rxreset+(0x0<<16);    // reset LINKIN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_align+(0x0<<16);    // send alignment command
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       usleep(1000);
//
//
//       printf(" finish FEM module %d alignment \n", imod);
//       scanf("%d",&ik);
//
       imod=imod_fem+1;
       if(imod != imod_st) {
        ichip=4;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_off+(0x0<<16);    // set last module off
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        printf(" set last module off, module address -- alignment%d\n", imod);
       }
       imod_fem=imod_fem+1;
      }





//


     for (imod_fem = (imod_xmit+1); imod_fem< (imod_st+1); imod_fem++) {
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       py = &read_array;
       usleep(100);
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iprint == 1) printf("FEM module %d status word = %x, %x \n", imod, read_array[0], read_array[1]);
     }
     return i;

}




/* -----------------------------------------------
    Read/write memory and I/O addresses -- TEST
   ----------------------------------------------- */
/* Read/write memory or I/O space address menu options */
static void Menujsebii_test(WDC_DEVICE_HANDLE hDev)
{
/*  pci express bar setting
bar 0,1 is for transceiver 1
bar 2,3 is for command
bar 4,5 is for transceiver 2
*/

#include "wdc_defs.h"

#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/
/** GKQ: are these specific to a pcie? **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

  /** bunch of variable initializations **/
  static DWORD dwAddrSpace;

  static UINT32 u32Data, u32Data_send;
  static unsigned long long u64Data;
  static DWORD dwOffset;
  static unsigned long long buff[10000];
/*    PVOID buff_p; */
  static UINT32 *buffp_send;
  static UINT32 *buffp_rec;
  static UINT64 *buffp_rec64;
/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
  static UINT32 i,j,k,ifr,jk,nwrite,iprint,nread;
  int newcmd,itr,tr_bar,icheck,istop,iloop,t_cs_reg,r_cs_reg;
  int idone,iseq,incomp,dma_tr,isweep,nsize_sw,irand,nwrite_max,nwrite_min;
  int kwrite;
  UINT32 write_array[100000],read_array[100000];
  int n_written;
  DWORD dwDMABufSize;
  PVOID pbuf_send;
  PVOID pbuf_rec;
  WD_DMA *pDma_send;
  WD_DMA *pDma_rec;
  DWORD dwStatus;
  DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_64BIT_ADDRESS;
  DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_64BIT_ADDRESS;

  iprint =1;
  ifr =0;
  istop =0;
  icheck =1;
  
    /** main menu (options) of routine **/
  printf(" PCIe board testing routing \n");
  printf(" type 1 to use random number \n");
  scanf("%d",&irand);
  printf(" which transceiver to test (1,2 ) \n");
  scanf("%d", &itr);
  printf(" input testing method \n");
  printf(" 1) for slave loop back test \n");
  printf(" 2) DMA loop back test \n");
  //  printf(" 3) combine optical DMA test \n");
  printf(" 3) write-to-file test \n");
  scanf("%d",&newcmd);
  switch(newcmd) {

  case 1:
    if(icheck == 1) printf(" data checking on \n");
    printf("enter number words per packet, -1 for sequence test \n");
    scanf("%d",&kwrite);
    if(kwrite == -1) {
      printf("enter min number of word \n");
      scanf("%d",&nwrite_min);
      printf("enter max number of word \n");
      scanf("%d",&nwrite_max);
      nwrite=nwrite_min;
    }
    else nwrite = kwrite;
    printf("enter number loops \n");
    scanf("%d",&iloop);
    
    tr_bar = t1_tr_bar;
    t_cs_reg = t1_cs_reg;
    r_cs_reg = r1_cs_reg;
    if(itr == 2) {
      tr_bar = t2_tr_bar;
      t_cs_reg = t2_cs_reg;
      r_cs_reg = r2_cs_reg;
    }
    
/* write this will abort previous DMA */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = dma_abort;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* clear DMA register after the abort */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = 0;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);


      /** begin timer **/
    struct timeval starttest1, endtest1;
    gettimeofday(&starttest1,NULL);
    long mytime1, seconds1, useconds1;
    seconds1 = starttest1.tv_sec;
    useconds1 = starttest1.tv_usec;

    printf("\n\nStart time of test: %ld sec %ld usec\n",seconds1,useconds1);
      //get a fresh timestamp
    gettimeofday(&starttest1,NULL);


    for (j=0; j<iloop; j++) {
	//GSK
	//       printf("started loop = %d \n",j);
/* set tx mode register */
      u32Data = 0xf0000fff;
      dwOffset = tx_md_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** initialize the tranmission ***/
      u32Data = cs_init;
      dwOffset = t_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the tranmitter **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      dwOffset = t_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up transmitter \n");

/** initialize the receiver ***/
      u32Data = cs_init;
      dwOffset = r_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      /** start the receiver **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      dwOffset = r_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if (iprint ==1 && j < 2) printf(" set up receiver \n");

       //GSK
       //       if(icheck == 1) {
       //         dwAddrSpace =cs_bar;
       //         u64Data =0;
       //         dwOffset = t_cs_reg;
       //         WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //         if(iprint==1 && j < 2) {
       //          u32Data=u64Data;
       //          printf (" transmitter status before send  = %8X \n",u32Data);
       //          u32Data=u64Data>>32;
       //          printf (" receiver status before send  = %8X \n",u32Data);
       //         }
       //       }

       //GSK
      u32Data = 0x22211; 

      for (i=0; i< nwrite; i++) {
        dwAddrSpace = tr_bar;
	//GSK
	//        if(irand == 1) u32Data=rand();
	//        else u32Data = i;
/*        if(i%2 == 0) u32Data =~i;   */
        dwOffset = 0;
	//GSK
	//        write_array[i]=u32Data;
        WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      }

       //GSK
       //       if(icheck ==1 ) {
       //        dwAddrSpace =cs_bar;
       //        u64Data =0;
       //        dwOffset = t_cs_reg;
       //        WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //        if(iprint==1 && j < 2) {
       //         u32Data=u64Data;
       //         printf (" transmitter status after send  = %8X \n",u32Data);
       //         u32Data=u64Data>>32;
       //         printf (" receiver status after send  = %8X \n",u32Data);
       //        }
       //       }
       //       nread = nwrite/2;
       //       if(nwrite%2 !=0) nread= nwrite/2 +1;
       //       for (i=0; i< nread; i++) {
       //        dwAddrSpace = tr_bar;
       //        u32Data = 0;
       //        dwOffset = 0;
       //        WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //        read_array[i*2] = u64Data;
       //        read_array[i*2+1] =u64Data>>32;
       //       }
       //       if(icheck == 1) {
       //        dwAddrSpace =cs_bar;
       //        u64Data =0;
       //        dwOffset = t_cs_reg;
       //        WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //        if(iprint==1 && j < 2) {
       //         u32Data=u64Data;
       //         printf (" transmitter status after read  = %8X \n",u32Data);
       //         u32Data=u64Data>>32;
       //         printf (" receiver status after read  = %8X \n",u32Data);
       //        }
       //        for (i=0; i< nwrite; i++) {
       //           if(iprint == 1 && j < 2) {
       //             if(i%8 ==0) printf("%d",i);
       //             printf("%9X",read_array[i]);
       //             if((i+1)%8 ==0) printf("\n");
       //           }
       //           if(read_array[i] != write_array[i]) printf("data mismatch, loop = %d word =%d read= %9X write = %9X\n",j,i,read_array[i],write_array[i]);
       //        }
       //        if((iprint ==1) && (nwrite%8 !=0) && j < 2) printf("\n");
       //       }
       //       if(j%100 ==0) printf(" loop = %d, nwrite= %d \n",j, nwrite);
       //       if(kwrite == -1) {
       //         nwrite =nwrite+1;
       //         if(nwrite > nwrite_max) nwrite =nwrite_min;
       //       }
    }

     /** end timer **/
    gettimeofday(&endtest1,NULL);
    seconds1 = endtest1.tv_sec;
    useconds1 = endtest1.tv_usec;
    
    printf("\nEnd time of test:   %ld sec %ld usec\n",seconds1,useconds1);

    seconds1 = endtest1.tv_sec - starttest1.tv_sec;
    useconds1 = endtest1.tv_usec - starttest1.tv_usec;
    
    mytime1 = seconds1*1000000. + useconds1*1.; //elapsed time in usec

    printf("\nElapsed time:\t\t\t %ld usec\n\n", mytime1);

    break;

  case 2:
    icheck=0;
    iprint=0;
    if(icheck == 1) printf(" data checking on \n");
    printf(" enter number of 32bits word send (< 20000), -1 for sequence test\n");
    scanf("%d",&kwrite);
    if(kwrite == -1) {
      printf("enter min number of word \n");
      scanf("%d",&nwrite_min);
      printf("enter max number of word \n");
      scanf("%d",&nwrite_max);
      nwrite=nwrite_min;
    }
    else nwrite = kwrite;

    printf("enter number loops \n");
    scanf("%d",&iloop);
    
    printf(" DMA sequence -> 1 for DMA read after DMA write \n");
    printf("                 2 for Open DMA read and slave write \n");
    scanf("%d",&iseq);
    printf(" type 1 for incomplete DMA test \n");
    scanf("%d",&incomp);
    

/*** allocate the DMA buffer for send and receive **/
    dwDMABufSize = 1000000;
    if(ifr ==0) {
      ifr=1;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
	printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
	printf("Failed locking a rec Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      else {
           u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
           printf(" buffer allocation lower address = %x\n", u32Data);
           u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
           printf(" buffer allocation higher address = %x\n", u32Data);
      }
    }
    printf(" type 1 to continue \n");
    scanf("%d",&i);
    tr_bar = t1_tr_bar;
    t_cs_reg = t1_cs_reg;
    r_cs_reg = r1_cs_reg;
    dma_tr = dma_tr1;
    if(itr == 2) {
      tr_bar = t2_tr_bar;
      t_cs_reg = t2_cs_reg;
      r_cs_reg = r2_cs_reg;
      dma_tr = dma_tr2;
    }

/* write this will abort previous DMA */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = dma_abort;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       /* clear DMA register after the abort */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = 0;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);


       
       //GSK
       //rand() generation outside loop, for speed test

    buffp_send = pbuf_send;
    buffp_rec = pbuf_rec;
    //	 printf("%llX\n",buffp_send);
    //this is not actually necessary:
    int ig;
    for (ig=0; ig<nwrite; ig++) {
      if(irand == 1) *buffp_send++=rand();
      else *buffp_send++= ig;
      *buffp_rec++ =0x0;
    }
    //    }
    printf("\nGenerated data (words) for loop-back test\n");
    for (i=0; i<nwrite; i++) {
      k = i%8;
      if( k ==0) printf(" %3d", i);
      u32Data = *buffp_send++;
      printf(" %llX",u32Data);
      if(k == 7 ) printf("\n");
    }
    printf("\n");
    for (i=0; i<nwrite; i++) {
      k = i%8;
      if( k ==0) printf(" %3d", i);
      u32Data = *buffp_rec++;
      printf(" %llX",u32Data);
      if(k == 7 ) printf("\n");
    }


      /** begin timer **/
    struct timeval starttest, endtest;
    gettimeofday(&starttest,NULL);
    long mytime, seconds, useconds;
    seconds = starttest.tv_sec;
    useconds = starttest.tv_usec;
      
    printf("\n\nStart time of test: %ld sec %ld usec\n",seconds,useconds);
      //get a fresh timestamp
    gettimeofday(&starttest,NULL);


    for (j=0; j<iloop; j++) {
/* set tx mode register */
      u32Data = 0xf0000008;
      dwOffset = tx_md_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      /** initialize the tranmission ***/
      u32Data = cs_init;
      dwOffset = t_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the tranmitter **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      dwOffset = t_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up transmitter \n");
/** initialize the receiver ***/
      u32Data = cs_init;
      dwOffset = r_cs_reg;
      dwAddrSpace =cs_bar;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the receiver **/
      dwAddrSpace = cs_bar;
      u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
      //GSK
       //       if(incomp ==1) u32Data = cs_start+nwrite*4+16; /* set up 4 less words to receive */
      dwOffset = r_cs_reg;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up receiver \n");
       //       if(icheck == 1) {
       //         dwAddrSpace =cs_bar;
       //         u64Data =0;
       //         dwOffset = t_cs_reg;
       //         WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       //	 if(iprint==1 && j < 2) {
       //	   u32Data=u64Data;
       //	   printf (" transmitter status before send  = %8X \n",u32Data);
       //	   u32Data=u64Data>>32;
       //	   printf (" receiver status before send  = %8X \n",u32Data);
       //	 }
       //       }

      buffp_send = pbuf_send;
      buffp_rec = pbuf_rec;

       //GSK
       //do rand() generation outside the loop, and fill array(s) ahead of time
       //       for (i=0; i<nwrite+100; i++) {
       //	 if(irand == 1) *buffp_send++=rand();
       //	 else *buffp_send++= i;
       //	 *buffp_rec++ =0;
       //       }

/*
       buffp_rec = pbuf_rec;
       buffp_send = pbuf_send;

       for (i=0; i<nwrite; i++) {
	  k = i%8;
	  if(iprint ==1 && k ==0) printf(" %3d", i);
	  u32Data = *buffp_send++;
          if(iprint==1) printf(" %llX",u32Data);
	  if(k == 7 && iprint == 1) printf("\n");
       }
*/

//GSK iseq==1 by definition for this test
//       if(iseq == 1) {
/* set up transmitter DMA starting address */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_low_reg;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_high_reg;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_by_cnt;
      u32Data = nwrite*4;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

	/* synch cache */
      WDC_DMASyncCpu(pDma_send);

/* write this will start DMA */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_cntrl;
      u32Data = dma_tr+dma_3dw_trans;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/***    check to see if DMA is done or not **/
      idone =0;
      for (i=0; i<200; i++) {;
	dwAddrSpace =cs_bar;
	u64Data =0;
	dwOffset = cs_dma_cntrl;
	WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	  //GSK
	  //	  if(iprint ==1 && j < 2) printf(" send DMA status word %d %X \n", i, u32Data);
	if((u32Data & dma_in_progress) == 0) {
	    //GSK
	    //	    if(iprint == 1 && j < 2) printf(" send DMA complete %d \n", i);
	  idone =1;
	}
	if((u32Data & dma_in_progress) == 0) break;
      }
      if(idone == 0) {
	  //gsk
	  //	  printf(" sending dma is not finished \n");
	  //	  printf(" send DMA status word %d %X \n", i, u32Data);
	break;
      }
	//GSK
	//        if(icheck == 1) {
	//         dwAddrSpace =cs_bar;
	//         u64Data =0;
	//         dwOffset = t_cs_reg;
	//         WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
	//	 if(iprint==1 && j < 2) {
	//	   u32Data=u64Data;
	//	   printf (" transmitter status after send  = %8X \n",u32Data);
	//	   u32Data=u64Data>>32;
	//	   printf (" receiver status after send  = %8X \n",u32Data);
	//	 }
	//        }
	//GSK end if iseq==1
	//       }

 	/* synch DMA i/O cache **/
      WDC_DMASyncIo(pDma_send);

	//GSK iseq==1 for this test
	//       if (iseq != 1) {
	///** now write data to the transmiiter */
//        buffp_send = pbuf_send;
//        for (i=0; i< nwrite; i++) {
//         dwAddrSpace = tr_bar;
//         u32Data = *buffp_send++;
//         dwOffset = 0;
//         WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//        }
//       }


 /** set up the receiver DMA and first  **/

      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_low_reg;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_high_reg;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_by_cnt;
      u32Data = nwrite*4;
      if(incomp ==1) u32Data = cs_start+nwrite*4+16; /* set up 4 more words to receive */
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = cs_dma_cntrl;
      u32Data = dma_tr+dma_3dw_rec;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

	/* synch cache */
      WDC_DMASyncCpu(pDma_rec);



/***    check to see if DMA is done or not **/
      idone =0;
      for (i=0; i<200; i++) {;
	dwAddrSpace =cs_bar;
	u64Data =0;
	dwOffset = cs_dma_cntrl;
	WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	//GSK
	//	  if(iprint ==1 && j < 2) printf(" receive DMA status word %d %X \n", i, u32Data);
	if((u32Data & dma_in_progress) == 0) {
	  idone =1;
	  //GSK
	  //	    if(iprint == 1 && j < 2) printf(" receive DMA complete %d \n", i);
	}
	if((u32Data & dma_in_progress) == 0) break;
      }
      /* synch DMA i/O cache **/

      WDC_DMASyncIo(pDma_rec);

      if(idone == 0){
	 //gsk
	 //	 printf(" DMA is not done, %d, iloop = %d, nwrite= %d\n",i, j, nwrite);
	 //         if(incomp ==1) {
	 //           u32Data = dma_abort;
	 //           dwOffset = cs_dma_msi_abort;
	 //           dwAddrSpace =cs_bar;
	 //           WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
	 //           u32Data = 0;
	 //           dwOffset = cs_dma_msi_abort;
	 //           dwAddrSpace =cs_bar;
	 //           WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
	 //           dwAddrSpace =cs_bar;
	 //	   dwOffset = cs_dma_cntrl;
	 //           WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	 //	   if(iprint ==1 && j < 2) printf(" receive DMA status word after abort %d %X \n", i, u32Data);
	 //           dwAddrSpace =cs_bar;
	 //           dwOffset = t_cs_reg;
	 //           WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
	 //	   if(iprint==1 && j < 2) {
	 //	     u32Data=u64Data;
	 //	     printf (" transmitter status after abort  = %8X \n",u32Data);
	 //	     u32Data=u64Data>>32;
	 //	     printf (" receiver status after abort  = %8X \n",u32Data);
	 //	   }
	 //         }
	 //         else 
	break;
      }

      if(idone == 1) {
	buffp_rec = pbuf_rec;
	buffp_send = pbuf_send;
	
	 //GSK
	 //	 for (i=0; i<nwrite; i++) {
	 //	   k = i%8;
	 //	  if(iprint ==1 && k ==0 && j < 2) printf(" %3d", i);
	 //	  u32Data = *buffp_rec++;
	 //	  u32Data_send = *buffp_send++;
	 //	  if((u32Data != u32Data_send) && (icheck ==1) ) printf(" %d, %d, %11x, %11x\n", j,i,u32Data_send,u32Data);
	 //	  if(iprint==1 && j < 2) printf(" %llX",u32Data);
	 //	  if(k == 7 && iprint == 1 && j < 2) printf("\n");
	 //	 }
	 //	 if(k !=7 && iprint ==1 && j < 2) printf("\n");
      }
       //       if(j%100 ==0) printf(" loop = %d, nwrite= %d \n",j, nwrite);

       //GSK
       //       if(kwrite == -1) {
       //        nwrite =nwrite+1;
       //        if(nwrite > nwrite_max) nwrite =nwrite_min;
       //       }
    }

      /** end timer **/
    gettimeofday(&endtest,NULL);
    seconds = endtest.tv_sec;
    useconds = endtest.tv_usec;
      
    printf("\nEnd time of test:   %ld sec %ld usec\n",seconds,useconds);

    seconds = endtest.tv_sec - starttest.tv_sec;
    useconds = endtest.tv_usec - starttest.tv_usec;

    mytime = seconds*1000000. + useconds*1.; //elapsed time in usec

    printf("\nElapsed time:\t\t\t %ld usec\n\n", mytime);

    break;
    
  case 3:
    printf("enter number words per packet \n");
    scanf("%d",&nwrite);
    printf("enter number loops \n");
    scanf("%d",&iloop);
    
    tr_bar = t1_tr_bar;
    t_cs_reg = t1_cs_reg;
    r_cs_reg = r1_cs_reg;
    if(itr == 2) {
      tr_bar = t2_tr_bar;
      t_cs_reg = t2_cs_reg;
      r_cs_reg = r2_cs_reg;
    }

/* write this will abort previous DMA */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = dma_abort;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
    dwAddrSpace =2;
    dwOffset = cs_dma_msi_abort;
    u32Data = 0;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

    printf("\n\nWriting to file: -----------> test.bin\n");

    FILE * pFile;
    pFile = fopen("test.bin","w");
    if (pFile==NULL){
      printf("\nFile NOT open; Exiting.\n");
      break;
    }

    //first write some stuff

/* set tx mode register */
    u32Data = 0xf0000fff;
    dwOffset = tx_md_reg;
    dwAddrSpace =cs_bar;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** initialize the tranmission ***/
    u32Data = cs_init;
    dwOffset = t_cs_reg;
    dwAddrSpace =cs_bar;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/** start the tranmitter **/
    dwAddrSpace = cs_bar;
    u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
    dwOffset = t_cs_reg;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
       //GSK
       //       if(iprint == 1 && j < 2) printf(" set up transmitter \n");
/** initialize the receiver ***/
    u32Data = cs_init;
    dwOffset = r_cs_reg;
    dwAddrSpace =cs_bar;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      /** start the receiver **/
    dwAddrSpace = cs_bar;
    u32Data = cs_start+nwrite*4;   /* 32 bits mode == 4 bytes per word **/
    dwOffset = r_cs_reg;
    WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);


    //now write to transmitter ---> edit from this point on

    u32Data = 0x3333;
    for (i=0; i< nwrite; i++) {
      dwAddrSpace = tr_bar;
      dwOffset = 0;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
    }


    //receiver read and write to file

    //loop read



      /** begin timer **/
    struct timeval starttest2, endtest2;
    gettimeofday(&starttest2,NULL);
    long mytime2, seconds2, useconds2;
    seconds2 = starttest2.tv_sec;
    useconds2 = starttest2.tv_usec;
      
    printf("\n\nStart time of test: %ld sec %ld usec\n",seconds2,useconds2);
      //get a fresh timestamp
    gettimeofday(&starttest2,NULL);




      /** end timer **/
    gettimeofday(&endtest2,NULL);
    seconds2 = endtest2.tv_sec;
    useconds2 = endtest2.tv_usec;
      
    printf("\nEnd time of test:   %ld sec %ld usec\n",seconds2,useconds2);

    seconds2 = endtest2.tv_sec - starttest2.tv_sec;
    useconds2 = endtest2.tv_usec - starttest2.tv_usec;

    mytime2 = seconds2*1000000. + useconds2*1.; //elapsed time in usec

    printf("\nElapsed time:\t\t\t %ld usec\n\n", mytime2);
    

    fclose(pFile);

    break;

  }

}
  


static int pcie_send(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_send;
    static WD_DMA *pDma_send;
    static DWORD dwStatus;
    static DWORD dwOptions_send = DMA_TO_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static PVOID pbuf_send;
    int nwrite,i,j, iprint;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_send = pbuf_send;
    }
    iprint =0;
    if(mode ==1 ) {
      for (i=0; i< nword; i++) {
        *(buf_send+i) = *buff_send++;
/*	printf("%d \n",*(buf_send+i));   */
      }
    }
    if(mode == 0) {
     nwrite = nword*4;
     /*setup transmiiter */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x40000000+nwrite;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     for (j=0; j< nword; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u32Data = *buff_send++;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     }
     for (i=0; i<20000; i++) {
       dwAddrSpace =2;
       dwOffset = 0xC;
       WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
       if(iprint ==1) printf(" status reed %d %X \n", i, u32Data);
       if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" Data Transfer complete %d \n", i);
       if((u32Data & 0x80000000) == 0) break;
     }
    }
    if( mode ==1 ){
      nwrite = nword*4;
      WDC_DMASyncCpu(pDma_send);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
     /*setup transmiiter */
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nwrite;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nwrite;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100000;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status reed %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" DMA complete %d \n", i);
	if((u32Data & 0x80000000) == 0) break;
      }
      WDC_DMASyncIo(pDma_send);
    }
    return i;
    }

static int pcie_send_1(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_send;
    static WD_DMA *pDma_send;
    static DWORD dwStatus;
    static DWORD dwOptions_send = DMA_TO_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static PVOID pbuf_send;
    int nwrite,i,j, iprint;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_send = pbuf_send;
    }
    iprint =0;
    if(mode ==1 ) {
      for (i=0; i< nword; i++) {
        *(buf_send+i) = *buff_send++;
/*	printf("%d \n",*(buf_send+i));   */
      }
    }
    if(mode == 0) {
     nwrite = nword*4;
     /*setup transmiiter */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x40000000+nwrite;
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     for (j=0; j< nword; j++) {
       dwAddrSpace =4;
       dwOffset = 0x0;
       u32Data = *buff_send++;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     }
     for (i=0; i<20000; i++) {
       dwAddrSpace =2;
       dwOffset = 0xC;
       WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
       if(iprint ==1) printf(" status reed %d %X \n", i, u32Data);
       if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" Data Transfer complete %d \n", i);
       if((u32Data & 0x80000000) == 0) break;
     }
    }
    if( mode ==1 ){
      nwrite = nword*4;
      WDC_DMASyncCpu(pDma_send);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
     /*setup transmiiter */
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nwrite;
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nwrite;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00230000;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status reed %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" DMA complete %d \n", i);
	if((u32Data & 0x80000000) == 0) break;
      }
      WDC_DMASyncIo(pDma_send);
    }
    return i;
    }

void *pcie_send_fake(void *threadarg)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_send;
    static WD_DMA *pDma_send;
    static DWORD dwStatus;
    static DWORD dwOptions_send = DMA_TO_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static PVOID pbuf_send;
    int nword;
    int nwrite,i,j, iprint,k;
    int taskid;
    static int ifr=0;
//
//
    WDC_DEVICE_HANDLE hDev,hDev1;

    struct thread_data
    {
     int thread_id;
     WDC_DEVICE_HANDLE hDev;
     WDC_DEVICE_HANDLE hDevc;
    };

    struct thread_data *my_data;


    dwDMABufSize = 1000000;
//
//
//

    printf("trigger thread started \n");
    my_data = (struct thread_data *) threadarg;
    taskid = my_data->thread_id;
    hDev = my_data->hDev;
    hDev1 = my_data->hDevc;
//
//
//
    ifr=0;
//    if (ifr == 0) {
//      ifr=1;
//      dwDMABufSize = 140000;
//      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
//      if (WD_STATUS_SUCCESS != dwStatus) {
//             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
//      }
//      buf_send = pbuf_send;
//    }
    nword = 1000000;
    nwrite = 1000000;
//    for (i=0; i< nword; i++) {
//        *(buf_send+i) = i+1;
/*	printf("%d \n",*(buf_send+i));   */
//     }

//     is = (pDma_send_fake->Page->pPhysicalAddr >> 32) & 0xffffffff;

//
/* write this will abort previous DMA */
         dwAddrSpace =2;
         dwOffset = 0x10;
         u32Data = 0x2;
         WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
/* clear DMA register after the abort */
         dwAddrSpace =2;
         dwOffset = 0x10;
         u32Data = 0;
          WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
//
//
    while (dwDMABufSize >=0) {
     if(ifr == 0){
/*setup transmiiter */
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x20;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      ifr=1 ;
      printf(" sned fake initialize the interface \n");
     }

     WDC_DMASyncCpu(pDma_send_fake);
     /*setup transmiiter */
     dwAddrSpace =2;
     u32Data = 0x40000000+nwrite;
     dwOffset = 0x20;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* set up sending DMA starting address */

     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x0;
     u32Data = pDma_send_fake->Page->pPhysicalAddr & 0xffffffff;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x4;
     u32Data = (pDma_send_fake->Page->pPhysicalAddr >> 32) & 0xffffffff;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
     dwAddrSpace =2;
     dwOffset = 0x8;
     u32Data = nwrite;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
     dwAddrSpace =2;
     dwOffset = 0xc;
     u32Data = 0x00230000;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

//     for (i=0; i<20000000; i++) {
     dwAddrSpace =2;
     dwOffset = 0xc;
     WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
     k=0;
     while ((u32Data & 0x80000000) != 0) {
      usleep(1);
      k=k+1;
      dwAddrSpace =2;
      dwOffset = 0xc;
      WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
//      if((i%100000) == 0) printf(" DMA status reed %d %X \n", i, u32Data);
//      if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" DMA complete %d \n", i);
//      if((u32Data & 0x80000000) == 0) break;
     }
//     printf(" end dma loop,%d \n", k);
     WDC_DMASyncIo(pDma_send_fake);
    }
}



 static int pcie_rec(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint =0;
//    printf(" istart = %d\n", istart);
//   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
//     printf(" nword = %d \n",nword);
/*
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before set = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }
*/
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

     /*initialize the receiver */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =2;
     u32Data = 0x40000000+nword*4;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/2+1;
      if(nword%2 == 0) nread = nword/2;
      for (j=0; j< nread; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout\n");
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }


 static int pcie_rec_2(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint =0;
 //   printf(" istart = %d\n", istart);
 //   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = tx_mode_reg;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

     /*initialize the receiver */
     dwAddrSpace =cs_bar;
     u32Data = cs_init;
     dwOffset = r2_cs_reg;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =cs_bar;
     u32Data = cs_start+nword*2;
     dwOffset = r2_cs_reg;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =cs_bar;
      u64Data =0;
      dwOffset = t2_cs_reg;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/4+1;
      if(nword%4 == 0) nread = nword/4;
      for (j=0; j< nread; j++) {
       dwAddrSpace =t2_tr_bar;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =cs_bar;
       u64Data =0;
       dwOffset = t2_cs_reg;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){            ///**** not up to date ****///
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout\n");
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }



 static int pcie_rec_16b(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = pbuf_rec;
    }
    iprint =0;
//    printf(" istart = %d\n", istart);
//   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
//     printf(" nword = %d \n",nword);
/*
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before set = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }
*/
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

     /*initialize the receiver */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =2;
     u32Data = 0x40000000+nword*2;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/4+1;
      if(nword%2 == 0) nread = nword/4;
      for (j=0; j< nread; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout\n");
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }


static int pcie_send_6_1(WDC_DEVICE_HANDLE hDev2, int mode, int nword, UINT32 *buff_send)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_send;
    static WD_DMA *pDma_send;
    static DWORD dwStatus;
    static DWORD dwOptions_send = DMA_TO_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static PVOID pbuf_send;
    int nwrite,i,j, iprint;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_send = pbuf_send;
    }
    iprint =1;
    if(iprint ==1) printf(" enter pcie_send_6_1 \n");
    if(mode ==1 ) {
      for (i=0; i< nword; i++) {
        *(buf_send+i) = *buff_send++;
/*	printf("%d \n",*(buf_send+i));   */
      }
    }
    if(mode == 0) {
     nwrite = nword*4;
     /*setup transmiiter */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x40000000+nwrite;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     for (j=0; j< nword; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u32Data = *buff_send++;
       WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
     }
     for (i=0; i<20000; i++) {
       dwAddrSpace =2;
       dwOffset = 0xC;
       WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
       if(iprint ==1) printf(" status reed %d %X \n", i, u32Data);
       if(((u32Data & 0x80000000) == 0) && (iprint == 1)) printf(" Data Transfer complete %d \n", i);
       if((u32Data & 0x80000000) == 0) break;
     }
    }
    if( mode ==1 ){
      nwrite = nword*4;
      WDC_DMASyncCpu(pDma_send);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
     /*setup transmiiter */
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nwrite;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nwrite;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100000;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status reed %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0) &&( iprint == 1)) printf(" DMA complete %d \n", i);
	if((u32Data & 0x80000000) == 0) break;
      }
      WDC_DMASyncIo(pDma_send);
    }
    return i;
    }


static int pcie_rec_6_1(WDC_DEVICE_HANDLE hDev2, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
  /* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
  static DWORD dwAddrSpace;
  static DWORD dwDMABufSize;

  static UINT32 *buf_rec;
  static WD_DMA *pDma_rec;
  static DWORD dwStatus;
  static DWORD dwOptions_rec = DMA_FROM_DEVICE;
  static DWORD dwOffset;
  static UINT32 u32Data;
  static UINT64 u64Data;
  static PVOID pbuf_rec;
  int nread,i,j, iprint,icomp;
  static int ifr=0;

  if (ifr == 0) {
    ifr=1;
    dwDMABufSize = 140000;
    dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
    if (WD_STATUS_SUCCESS != dwStatus) {
      printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
    }
    buf_rec = pbuf_rec;
  }
  iprint =0;
  //   printf(" istart = %d\n", istart);
  //   printf(" mode   = %d\n", mode);
  /** set up the receiver **/
  if((istart == 1) | (istart == 3)) {
    // initalize transmitter mode register...
    //    dwAddrSpace =2;
    //    u32Data = 0xf0000008;
    //    dwOffset = 0x28;
    //    WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

    /*initialize the receiver */
    dwAddrSpace =2;
    u32Data = 0x20000000;
    dwOffset = 0x1c;
    WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
    /* write byte count **/
    dwAddrSpace =2;
    u32Data = 0x40000000+nword*2;
    dwOffset = 0x1c;
    WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
    if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read hDev2 = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
    }

    return 0;
  }
  if ((istart == 2) | (istart == 3)) {
    //     if(ipr_status ==1) {
    //      dwAddrSpace =2;
    //      u64Data =0;
    //      dwOffset = 0x18;
    //      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
    //      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
    //     }
    if(mode == 0) {
      nread = nword/4+1;
      if(nword%4 == 0) nread = nword/4;
      for (j=0; j< nread; j++) {
	dwAddrSpace =0;
	dwOffset = 0x0;
	u64Data =0xbad;
	WDC_ReadAddr64(hDev2,dwAddrSpace, dwOffset, &u64Data);
	//       printf("u64Data = %16X\n",u64Data);
	*buff_rec++ = (u64Data &0xffffffff);
	*buff_rec++ = u64Data >>32;
	//       printf("%x \n",(u64Data &0xffffffff));
	//       printf("%x \n",(u64Data >>32 ));
	//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
	//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
	dwAddrSpace =2;
	u64Data =0;
	dwOffset = 0x18;
	WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
	printf (" status word after read hDev2 = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
    }
    if( mode ==1 ){            ///**** not up to date ****///
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
      /*
	printf(" nwrite = %d \n", nwrite);
	printf(" pcie_send hDev = %d\n", hDev);
	printf(" buf_send = %X\n",*buf_send);
      */
      /*setup receiver
	dwAddrSpace =2;
	u32Data = 0x20000000;
	dwOffset = 0x1c;
	WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
	dwAddrSpace =2;
	u32Data = 0x40000000+nread;
	dwOffset = 0x1c;
	WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      */
      /* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      /* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      /* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout\n");
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
	/*	printf("%d \n",*(buf_send+i));   */
      }
    }
  }
  return 0;
}



static int pcie_rec_6_2(WDC_DEVICE_HANDLE hDev2, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
  /* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

  /**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

  /** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

  static DWORD dwAddrSpace;
  static DWORD dwDMABufSize;

  static UINT32 *buf_rec;
  static WD_DMA *pDma_rec;
  static DWORD dwStatus;
  static DWORD dwOptions_rec = DMA_FROM_DEVICE;
  static DWORD dwOffset;
  static UINT32 u32Data;
  static UINT64 u64Data;
  static PVOID pbuf_rec;
  int nread,i,j, iprint,icomp;
  static int ifr=0;

  if (ifr == 0) {
    ifr=1;
    dwDMABufSize = 140000;
    dwStatus = WDC_DMAContigBufLock(hDev2, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
    if (WD_STATUS_SUCCESS != dwStatus) {
      printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
    }
    buf_rec = pbuf_rec;
  }
  iprint =0;
  //   printf(" istart = %d\n", istart);
  //   printf(" mode   = %d\n", mode);
  /** set up the receiver **/
  if((istart == 1) | (istart == 3)) {
    // initalize transmitter mode register...
    //     dwAddrSpace =2;
    //     u32Data = 0xf0000008;
    //     dwOffset = tx_mode_reg;
    //     WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

    /*initialize the receiver */
    dwAddrSpace =cs_bar;
    u32Data = cs_init;
    dwOffset = r2_cs_reg;
    WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
    /* write byte count **/
    dwAddrSpace =cs_bar;
    u32Data = cs_start+nword*2;
    dwOffset = r2_cs_reg;
    WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
    if(ipr_status ==1) {
      dwAddrSpace =cs_bar;
      u64Data =0;
      dwOffset = t2_cs_reg;
      WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
    }

    return 0;
  }
  if ((istart == 2) | (istart == 3)) {
    //     if(ipr_status ==1) {
    //      dwAddrSpace =2;
    //      u64Data =0;
    //      dwOffset = 0x18;
    //      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
    //      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
    //     }
    if(mode == 0) {
      nread = nword/4+1;
      if(nword%4 == 0) nread = nword/4;
      for (j=0; j< nread; j++) {
	dwAddrSpace =t2_tr_bar;
	dwOffset = 0x0;
	u64Data =0xbad;
	WDC_ReadAddr64(hDev2,dwAddrSpace, dwOffset, &u64Data);
	//       printf("u64Data = %16X\n",u64Data);
	*buff_rec++ = (u64Data &0xffffffff);
	*buff_rec++ = u64Data >>32;
	//       printf("%x \n",(u64Data &0xffffffff));
	//       printf("%x \n",(u64Data >>32 ));
	//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
	//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
	dwAddrSpace =cs_bar;
	u64Data =0;
	dwOffset = t2_cs_reg;
	WDC_ReadAddr64(hDev2, dwAddrSpace, dwOffset, &u64Data);
	printf (" status word after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
    }
    if( mode ==1 ){            ///**** not up to date ****///
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
      /*
	printf(" nwrite = %d \n", nwrite);
	printf(" pcie_send hDev = %d\n", hDev);
	printf(" buf_send = %X\n",*buf_send);
      */
      /*setup receiver
	dwAddrSpace =2;
	u32Data = 0x20000000;
	dwOffset = 0x1c;
	WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
	dwAddrSpace =2;
	u32Data = 0x40000000+nread;
	dwOffset = 0x1c;
	WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      */
      /* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      /* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);

      /* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev2, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev2, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout\n");
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
	/*	printf("%d \n",*(buf_send+i));   */
      }
    }
  }
  return 0;
}



static int xmit_boot(WDC_DEVICE_HANDLE hDev, int imod_xmit)
{
#include "wdc_defs.h"
#define  mb_xmit_conf_add 0x2

  FILE *inpf;
  int imod,ichip,count,counta,ichip_c,dummy1,ik,ij,i;
  unsigned char charchannel,carray[4000];
  int nsend,nword,k;
  UINT32 buf_send[10000],send_array[10000];
  UINT32 *px;
  struct timespec tim,tim2;
  tim.tv_sec=0;
  tim.tv_nsec = 128000;
  //
  //    boot up xmit module 1st
  //
  nsend=500;
  px = &buf_send;
  printf(" boot xmit module \n");
  inpf = fopen("/home/ub/xmit_fpga","r");
  /* inpf = fopen("/home/ub/xmit_fpga_link_header","r"); */
  imod=imod_xmit;
  ichip=mb_xmit_conf_add;
  buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  //      for (i=0; i<100000; i++) {
  //          ik= i%2;
  //          dummy1= (ik+i)*(ik+i);
  //      }


  /* read data as characters (28941) */
  usleep(1000);   // wait fior a while
  count = 0;
  counta= 0;
  ichip_c = 7; // set ichip_c to stay away from any other command in the
  dummy1 =0;
  while (fread(&charchannel,sizeof(char),1,inpf)==1) {
    carray[count] = charchannel;
    count++;
    counta++;
    if((count%(nsend*2)) == 0) {
      //        printf(" loop = %d\n",dummy1);
      buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
      send_array[0] =buf_send[0];
      if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
			      ,carray[2], carray[3]);
      for (ij=0; ij< nsend; ij++) {
	if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
	else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
	//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
	send_array[ij+1] = buf_send[ij+1];
      }
      nword =nsend+1;
      i=1;
      //       if(dummy1 == 0)
      ij = pcie_send(hDev, i, nword, px);
      nanosleep(&tim , &tim2);
      dummy1 = dummy1+1;
      count =0;
    }
  }
  if(feof(inpf)) {
    printf("You have reached the end-of-file word count= %d %d\n", counta, count);
    buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
    if ( count > 1) {
      if( ((count-1)%2) ==0) {
	ik =(count-1)/2;
      }
      else {
	ik =(count-1)/2+1;
      }
      ik=ik+2;   // add one more for safety
      printf("ik= %d\n",ik);
      for (ij=0; ij<ik; ij++){
	if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
	else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
	send_array[ij+1] = buf_send[ij+1];
      }
    }
    else ik=1;

    for (ij=ik-10; ij< ik+1; ij++) {
      printf("Last data = %d, %x\n",ij,buf_send[ij]);
    }

    nword =ik+1;
    i=1;
    i = pcie_send(hDev, i, nword, px);
  }
  usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
  fclose(inpf);
  return i;
}


static int fem_boot(WDC_DEVICE_HANDLE hDev, int imod_fem)
{
#include "wdc_defs.h"
#define  mb_feb_conf_add 0x2

  FILE *inpf;
  int imod,ichip,count,counta,ichip_c,dummy1,ik,ij,i;
  unsigned char charchannel,carray[4000];
  int nsend,nword,k;
  UINT32 buf_send[10000],send_array[10000];
  UINT32 *px;
  struct timespec tim,tim2;
  tim.tv_sec=0;
  tim.tv_nsec = 128000;
  //
  //    boot up xmit module 1st
  //
  nsend=500;
  px = &buf_send;
  //
  //    Boot stratix after XMIT module
  //
  inpf = fopen("/home/ub/feb_fpga_test","r");
  /* inpf = fopen("/home/ub/feb_tpc_fpga_sn_zero_test","r"); */
  imod=imod_fem;
  ichip=mb_feb_conf_add;
  buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
  i=1;
  k=1;
  i = pcie_send(hDev, i, k, px);
  //      for (i=0; i<100000; i++) {
  //          ik= i%2;
  //          dummy1= (ik+i)*(ik+i);
  //      }


  /* read data as characters (28941) */
  usleep(1000);   // wait fior a while
  count = 0;
  counta= 0;
  ichip_c = 7; // set ichip_c to stay away from any other command in the
  dummy1 =0;
  while (fread(&charchannel,sizeof(char),1,inpf)==1) {
    carray[count] = charchannel;
    count++;
    counta++;
    if((count%(nsend*2)) == 0) {
      //        printf(" loop = %d\n",dummy1);
      buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
      send_array[0] =buf_send[0];
      if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
			      ,carray[2], carray[3]);
      for (ij=0; ij< nsend; ij++) {
	if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
	else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
	//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
	send_array[ij+1] = buf_send[ij+1];
      }
      nword =nsend+1;
      i=1;
      //       if(dummy1 == 0)
      ij = pcie_send(hDev, i, nword, px);
      nanosleep(&tim , &tim2);
      dummy1 = dummy1+1;
      count =0;
    }
  }
  if(feof(inpf)) {
    printf("You have reached the end-of-file word count= %d %d\n", counta, count);
    buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
    if ( count > 1) {
      if( ((count-1)%2) ==0) {
	ik =(count-1)/2;
      }
      else {
	ik =(count-1)/2+1;
      }
      ik=ik+2;   // add one more for safety
      printf("ik= %d\n",ik);
      for (ij=0; ij<ik; ij++){
	if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
	else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
	send_array[ij+1] = buf_send[ij+1];
      }
    }
    else ik=1;

    for (ij=ik-10; ij< ik+1; ij++) {
      printf("Last data = %d, %x\n",ij,buf_send[ij]);
    }

    nword =ik+1;
    i=1;
    i = pcie_send(hDev, i, nword, px);
  }
  usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
  fclose(inpf);
  return i;
}




/* -----------------------------------------------
   Read/write memory and I/O addresses
   ----------------------------------------------- */
/* Read/write address menu options */
enum {
  MENU_RW_ADDR_SET_ADDR_SPACE = 1,
  MENU_RW_ADDR_SET_MODE,
  MENU_RW_ADDR_SET_TRANS_TYPE,
  MENU_RW_ADDR_READ,
  MENU_RW_ADDR_WRITE,
  MENU_RW_ADDR_EXIT = DIAG_EXIT_MENU,
};

#define ACTIVE_ADDR_SPACE_NEEDS_INIT 0xFF

/* Read/write memory or I/O space address menu */
static void MenuReadWriteAddr(WDC_DEVICE_HANDLE hDev)
{
  DWORD option;
  static DWORD dwAddrSpace = ACTIVE_ADDR_SPACE_NEEDS_INIT;
  static WDC_ADDR_MODE mode = WDC_MODE_32;
  static BOOL fBlock = FALSE;

  /* Initialize active address space */
  if (ACTIVE_ADDR_SPACE_NEEDS_INIT == dwAddrSpace)
    {
      DWORD dwNumAddrSpaces = PCIE_GetNumAddrSpaces(hDev);
        
      /* Find the first active address space */
      for (dwAddrSpace = 0; dwAddrSpace < dwNumAddrSpaces; dwAddrSpace++)
        {
	  if (WDC_AddrSpaceIsActive(hDev, dwAddrSpace))
	    break;
        }
        
      /* Sanity check */
      if (dwAddrSpace == dwNumAddrSpaces)
        {
	  PCIE_ERR("MenuReadWriteAddr: Error - no active address spaces found\n");
	  dwAddrSpace = ACTIVE_ADDR_SPACE_NEEDS_INIT;
	  return;
        }
    }

  do
    {
      printf("\n");
      printf("Read/write the device's memory and IO ranges\n");
      printf("---------------------------------------------\n");
      printf("%d. Change active address space for read/write "
	     "(currently: BAR %ld)\n", MENU_RW_ADDR_SET_ADDR_SPACE, dwAddrSpace);
      printf("%d. Change active read/write mode (currently: %s)\n",
	     MENU_RW_ADDR_SET_MODE,
	     (WDC_MODE_8 == mode) ? "8 bit" : (WDC_MODE_16 == mode) ? "16 bit" :
	     (WDC_MODE_32 == mode) ? "32 bit" : "64 bit");
      printf("%d. Toggle active transfer type (currently: %s)\n",
	     MENU_RW_ADDR_SET_TRANS_TYPE,
	     (fBlock ? "block transfers" : "non-block transfers"));
      printf("%d. Read from active address space\n", MENU_RW_ADDR_READ);
      printf("%d. Write to active address space\n", MENU_RW_ADDR_WRITE);
      printf("%d. Exit menu\n", MENU_RW_ADDR_EXIT);
      printf("\n");
        
      if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
						MENU_RW_ADDR_WRITE))
        {
	  continue;
        }
        
      switch (option)
        {
        case MENU_RW_ADDR_EXIT: /* Exit menu */
	  break;
        case MENU_RW_ADDR_SET_ADDR_SPACE: /* Set active address space for read/write address requests */
	  {
            SetAddrSpace(hDev, &dwAddrSpace);
            break;
	  }
        case MENU_RW_ADDR_SET_MODE: /* Set active mode for read/write address requests */
	  WDC_DIAG_SetMode(&mode);
	  break;
        case MENU_RW_ADDR_SET_TRANS_TYPE: /* Toggle active transfer type */
	  fBlock = !fBlock;
	  break;
        case MENU_RW_ADDR_READ:  /* Read from a memory or I/O address */
        case MENU_RW_ADDR_WRITE: /* Write to a memory or I/O address */
	  {
            WDC_DIRECTION direction =
	      (MENU_RW_ADDR_READ == option) ? WDC_READ : WDC_WRITE;

            if (fBlock)
	      WDC_DIAG_ReadWriteBlock(hDev, direction, dwAddrSpace);
            else
	      WDC_DIAG_ReadWriteAddr(hDev, direction, dwAddrSpace, mode);
            
            break;
	  }
        }
    } while (MENU_RW_ADDR_EXIT != option);
}

static void SetAddrSpace(WDC_DEVICE_HANDLE hDev, PDWORD pdwAddrSpace)
{
  DWORD dwAddrSpace;
  DWORD dwNumAddrSpaces = PCIE_GetNumAddrSpaces(hDev);
  PCIE_ADDR_SPACE_INFO addrSpaceInfo;
    
  printf("\n");
  printf("Select an active address space:\n");
  printf("-------------------------------\n");

  for (dwAddrSpace = 0; dwAddrSpace < dwNumAddrSpaces; dwAddrSpace++)
    {
      BZERO(addrSpaceInfo);
      addrSpaceInfo.dwAddrSpace = dwAddrSpace;
      if (!PCIE_GetAddrSpaceInfo(hDev, &addrSpaceInfo))
        {
	  PCIE_ERR("SetAddrSpace: Error - Failed to get address space information: %s",
		   PCIE_GetLastErr());
	  return;
        }

      printf("%ld. %-*s %-*s %s\n",
	     dwAddrSpace + 1,
	     MAX_NAME_DISPLAY, addrSpaceInfo.sName,
	     MAX_TYPE - 1, addrSpaceInfo.sType,
	     addrSpaceInfo.sDesc);
    }
  printf("\n");

  if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwAddrSpace,
					    "Enter option", FALSE, 1, dwNumAddrSpaces))
    {
      return;
    }

  dwAddrSpace--;
  if (!WDC_AddrSpaceIsActive(hDev, dwAddrSpace))
    {
      printf("You have selected an inactive address space\n");
      return;
    }
            
  *pdwAddrSpace = dwAddrSpace;
}

/* -----------------------------------------------
   Read/write the configuration space
   ----------------------------------------------- */
/* Read/write the configuration space menu options */
enum {
  MENU_RW_CFG_SPACE_READ_OFFSET = 1,
  MENU_RW_CFG_SPACE_WRITE_OFFSET,
  MENU_RW_CFG_SPACE_READ_ALL_REGS,
  MENU_RW_CFG_SPACE_READ_REG,
  MENU_RW_CFG_SPACE_WRITE_REG,
  MENU_RW_CFG_SPACE_EXIT = DIAG_EXIT_MENU,
};

/* Display read/write configuration space menu */
static void MenuReadWriteCfgSpace(WDC_DEVICE_HANDLE hDev)
{
  DWORD option;
  
  do {
    /* Display pre-defined registers' information */
    if (PCIE_CFG_REGS_NUM)
      {
	printf("\n");
	printf("Configuration registers:\n");
	printf("------------------------\n");
	WDC_DIAG_RegsInfoPrint(gpPCIE_CfgRegs, PCIE_CFG_REGS_NUM,
			       WDC_DIAG_REG_PRINT_ALL & ~WDC_DIAG_REG_PRINT_ADDR_SPACE);
      }

    printf("\n");
    printf("Read/write the device's configuration space\n");
    printf("--------------------------------------------\n");
    printf("%d. Read from an offset\n", MENU_RW_CFG_SPACE_READ_OFFSET);
    printf("%d. Write to an offset\n", MENU_RW_CFG_SPACE_WRITE_OFFSET);
    if (PCIE_CFG_REGS_NUM)
      {
	printf("%d. Read all configuration registers defined for the device (see list above)\n",
	       MENU_RW_CFG_SPACE_READ_ALL_REGS);
	printf("%d. Read from a named register\n", MENU_RW_CFG_SPACE_READ_REG);
	printf("%d. Write to a named register\n", MENU_RW_CFG_SPACE_WRITE_REG);
      }
    printf("%d. Exit menu\n", MENU_RW_CFG_SPACE_EXIT);
    printf("\n");

    if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
					      PCIE_CFG_REGS_NUM ? MENU_RW_CFG_SPACE_WRITE_REG :
					      MENU_RW_CFG_SPACE_WRITE_OFFSET))
      {
	continue;
      }

    switch (option)
      {
      case MENU_RW_CFG_SPACE_EXIT: /* Exit menu */
	break;
      case MENU_RW_CFG_SPACE_READ_OFFSET: /* Read from a configuration space offset */
	WDC_DIAG_ReadWriteBlock(hDev, WDC_READ, WDC_AD_CFG_SPACE);
	break;
      case MENU_RW_CFG_SPACE_WRITE_OFFSET: /* Write to a configuration space offset */
	WDC_DIAG_ReadWriteBlock(hDev, WDC_WRITE, WDC_AD_CFG_SPACE);
	break;
      case MENU_RW_CFG_SPACE_READ_ALL_REGS:
	WDC_DIAG_ReadRegsAll(hDev, gpPCIE_CfgRegs, PCIE_CFG_REGS_NUM, TRUE);
	break;
      case MENU_RW_CFG_SPACE_READ_REG:  /* Read from a configuration register */
	WDC_DIAG_ReadWriteReg(hDev, gpPCIE_CfgRegs, PCIE_CFG_REGS_NUM, WDC_READ, TRUE);
	break;
      case MENU_RW_CFG_SPACE_WRITE_REG: /* Write to a configuration register */
	WDC_DIAG_ReadWriteReg(hDev, gpPCIE_CfgRegs, PCIE_CFG_REGS_NUM, WDC_WRITE, TRUE);
	break;
      }
  } while (MENU_RW_CFG_SPACE_EXIT != option);
}

/* -----------------------------------------------
   Read/write the run-time registers
   ----------------------------------------------- */
/* Read/write the run-time registers menu options */
enum {
  MENU_RW_REGS_READ_ALL = 1,
  MENU_RW_REGS_READ_REG,
  MENU_RW_REGS_WRITE_REG,
  MENU_RW_REGS_EXIT = DIAG_EXIT_MENU,
};

/* Display read/write run-time registers menu */
static void MenuReadWriteRegs(WDC_DEVICE_HANDLE hDev)
{
  DWORD option;
    
  if (!PCIE_REGS_NUM)
    {
      printf("There are currently no pre-defined run-time registers\n");
      return;
    }
  
  do {
    /* Display pre-defined registers' information */
    printf("\n");
    printf("PCIE run-time registers:\n");
    printf("--------------------------\n");   
    WDC_DIAG_RegsInfoPrint(gpPCIE_Regs, PCIE_REGS_NUM, WDC_DIAG_REG_PRINT_ALL);

    printf("\n");
    printf("Read/write the PCIE run-time registers\n");
    printf("-----------------------------------------\n");
    printf("%d. Read all run-time registers defined for the device (see list above)\n",
	   MENU_RW_REGS_READ_ALL);
    printf("%d. Read from a specific register\n", MENU_RW_REGS_READ_REG);
    printf("%d. Write to a specific register\n", MENU_RW_REGS_WRITE_REG);
    printf("%d. Exit menu\n", MENU_RW_REGS_EXIT);
    printf("\n");

    if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
					      MENU_RW_REGS_WRITE_REG))
      {
	continue;
      }

    switch (option)
      {
      case MENU_RW_REGS_EXIT: /* Exit menu */
	break;
      case MENU_RW_REGS_READ_ALL:
	WDC_DIAG_ReadRegsAll(hDev, gpPCIE_Regs, PCIE_REGS_NUM, FALSE);
	break;
      case MENU_RW_REGS_READ_REG:  /* Read from a register */
	WDC_DIAG_ReadWriteReg(hDev, gpPCIE_Regs, PCIE_REGS_NUM, WDC_READ, FALSE);
	break;
      case MENU_RW_REGS_WRITE_REG: /* Write to a register */
	WDC_DIAG_ReadWriteReg(hDev, gpPCIE_Regs, PCIE_REGS_NUM, WDC_WRITE, FALSE);
	break;
      }
  } while (MENU_RW_REGS_EXIT != option);
}

/* -----------------------------------------------
   Interrupt handling
   ----------------------------------------------- */
/* Interrupts menu options */
enum {
  MENU_INT_ENABLE_DISABLE = 1,
  MENU_INT_EXIT = DIAG_EXIT_MENU,
};

/* Enable/Disable interrupts menu */
static void MenuInterrupts(WDC_DEVICE_HANDLE hDev)
{
  DWORD option, dwIntOptions;
  BOOL fIntEnable, fIsMsi;

  dwIntOptions = WDC_GET_INT_OPTIONS(hDev);
  fIsMsi = WDC_INT_IS_MSI(dwIntOptions);
  if (dwIntOptions & INTERRUPT_LEVEL_SENSITIVE)
    {
      /* TODO: You can remove this message after you have modified the
	 implementation of PCIE_IntEnable() in pcie_lib.c to 
	 correctly acknowledge level-sensitive interrupts (see guidelines
	 in PCIE_IntEnable()) */
      printf("\n");
      printf("WARNING!!!\n");
      printf("----------\n");
      printf("Your hardware has level sensitive interrupts.\n");
      printf("Before enabling the interrupts, %s first modify the source "
	     "code of PCIE_IntEnable(), in the file pcie_lib.c, to "
	     "correctly acknowledge\n%s interrupts when they occur (as dictated by "
	     "the hardware's specifications)\n",
	     fIsMsi ? "it's recommended that you" : "you must",
	     fIsMsi ? "level sensitive" : "");    }

  do
    {
      fIntEnable = !PCIE_IntIsEnabled(hDev);

      printf("\n");
      printf("Interrupts\n");
      printf("-----------\n");
      printf("%d. %s interrupts\n", MENU_INT_ENABLE_DISABLE,
	     fIntEnable ? "Enable" : "Disable");
      printf("%d. Exit menu\n", MENU_INT_EXIT);
      printf("\n");

      if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
						MENU_RW_ADDR_WRITE))
        {
	  continue;
        }

      switch (option)
        {
        case MENU_INT_EXIT: /* Exit menu */
	  break;
        case MENU_INT_ENABLE_DISABLE: /* Enable/disable interrupts */
	  if (fIntEnable)
            {
	      DWORD dwStatus = PCIE_IntEnable(hDev, DiagIntHandler);

	      if (WD_STATUS_SUCCESS == dwStatus)
		printf("Interrupts enabled\n");
	      else
                {
		  PCIE_ERR("Failed enabling interrupts. Error 0x%lx - %s\n",
			   dwStatus, Stat2Str(dwStatus));
                }
            }
	  else
            {
	      if (WD_STATUS_SUCCESS == PCIE_IntDisable(hDev))
		printf("Interrupts disabled\n");
	      else
		PCIE_ERR("Failed disabling interrupts: %s", PCIE_GetLastErr());
            }
	  break;
        }
    } while (MENU_INT_EXIT != option);
}

/* Diagnostics interrupt handler routine */
static void DiagIntHandler(WDC_DEVICE_HANDLE hDev, PCIE_INT_RESULT *pIntResult)
{
  /* TODO: You can modify this function in order to implement your own
     diagnostics interrupt handler routine */

  printf("Got interrupt number %ld\n", pIntResult->dwCounter);
  printf("Interrupt Type: %s\n",
	 WDC_DIAG_IntTypeDescriptionGet(pIntResult->dwEnabledIntType));
  if (WDC_INT_IS_MSI(pIntResult->dwEnabledIntType))
    printf("Message Data: 0x%lx\n", pIntResult->dwLastMessage);
}

/* ----------------------------------------------------
   Plug-and-play and power management events handling
   ---------------------------------------------------- */
/* Events menu options */
enum {
  MENU_EVENTS_REGISTER_UNREGISTER = 1,
  MENU_EVENTS_EXIT = DIAG_EXIT_MENU,
};

/* Register/unregister Plug-and-play and power management events */
static void MenuEvents(WDC_DEVICE_HANDLE hDev)
{
  DWORD option;
  BOOL fRegister;

  do
    {
      fRegister = !PCIE_EventIsRegistered(hDev);
        
      printf("\n");
      printf("Plug-and-play and power management events\n");
      printf("------------------------------------------\n");
      printf("%d. %s events\n", MENU_EVENTS_REGISTER_UNREGISTER,
	     fRegister ? "Register" : "Unregister");
      printf("%d. Exit menu\n", MENU_EVENTS_EXIT);
      printf("\n");
        
      if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
						MENU_EVENTS_REGISTER_UNREGISTER))
        {
	  continue;
        }

      switch (option)
        {
        case MENU_EVENTS_EXIT: /* Exit menu */
	  break;
        case MENU_EVENTS_REGISTER_UNREGISTER: /* Register/unregister events */
	  if (fRegister)
            {
	      if (WD_STATUS_SUCCESS == PCIE_EventRegister(hDev, DiagEventHandler))
		printf("Events registered\n");
	      else
		PCIE_ERR("Failed to register events. Last error:\n%s", PCIE_GetLastErr());
            }
	  else
            {
	      if (WD_STATUS_SUCCESS == PCIE_EventUnregister(hDev))
		printf("Events unregistered\n");
	      else
		PCIE_ERR("Failed to unregister events. Last Error:\n%s", PCIE_GetLastErr());
            }
	  break;
        }
    } while (MENU_EVENTS_EXIT != option);
}

/* Plug-and-play and power management events handler routine */
static void DiagEventHandler(WDC_DEVICE_HANDLE hDev, DWORD dwAction)
{
  /* TODO: You can modify this function in order to implement your own
     diagnostics events handler routine */

  printf("\nReceived event notification (device handle 0x%p): ", hDev);
  switch (dwAction)
    {
    case WD_INSERT:
      printf("WD_INSERT\n");
      break;
    case WD_REMOVE:
      printf("WD_REMOVE\n");
      break;
    case WD_POWER_CHANGED_D0:
      printf("WD_POWER_CHANGED_D0\n");
      break;
    case WD_POWER_CHANGED_D1:
      printf("WD_POWER_CHANGED_D1\n");
      break;
    case WD_POWER_CHANGED_D2:
      printf("WD_POWER_CHANGED_D2\n");
      break;
    case WD_POWER_CHANGED_D3:
      printf("WD_POWER_CHANGED_D3\n");
      break;
    case WD_POWER_SYSTEM_WORKING:
      printf("WD_POWER_SYSTEM_WORKING\n");
      break;
    case WD_POWER_SYSTEM_SLEEPING1:
      printf("WD_POWER_SYSTEM_SLEEPING1\n");
      break;
    case WD_POWER_SYSTEM_SLEEPING2:
      printf("WD_POWER_SYSTEM_SLEEPING2\n");
      break;
    case WD_POWER_SYSTEM_SLEEPING3:
      printf("WD_POWER_SYSTEM_SLEEPING3\n");
      break;
    case WD_POWER_SYSTEM_HIBERNATE:
      printf("WD_POWER_SYSTEM_HIBERNATE\n");
      break;
    case WD_POWER_SYSTEM_SHUTDOWN:
      printf("WD_POWER_SYSTEM_SHUTDOWN\n");
      break;
    default:
      printf("0x%lx\n", dwAction);
      break;
    }
}


static int check_status(WDC_DEVICE_HANDLE hDevPMT,
			WDC_DEVICE_HANDLE hDevTPC,
			int imod_trig,
			int imod_fem_pmt_start,
			int imod_fem_pmt_end,
			int imod_fem_tpc_start,
			int imod_fem_tpc_end,
			int imod_xmit_pmt,
			int imod_xmit_tpc) {

#define mb_feb_rd_status 20
#define mb_feb_pmt_rd_counters 86
#define mb_a_buf_status 34
#define mb_b_buf_status 35
#define mb_xmit_rdstatus 20
#define mb_xmit_rdcounters 21
#define mb_trig_rd_status 32
  //
  // STATUS CHECK BEFORE RUNNING
  //
  static UINT32 read_array[40000];
  static UINT32 buf_send[40000];
  static UINT32 iprint = 1;
  static UINT32 nword = 0;
  int i=0;
  int k=0;
  long imod, ichip;
  UINT32 *px, *py;
  px = &buf_send;
  py = &read_array;
  int imod_fem_pmt, imod_fem_tpc;

  int sum_status_pmt_fem=0;
  int sum_status_pmt_xmit=0;
  int sum_status_tpc_fem=0;
  int sum_status_tpc_xmit=0;

  int num_pmt_fem_buf_nonempty=0;
  int num_tpc_fem_buf_nonempty=0;

  int num_pmt_fem_header_nonempty=0;
  int num_tpc_fem_header_nonempty=0;

  int num_pmt_fem_data_nonempty=0;
  int num_tpc_fem_data_nonempty=0;

  int frame_ctr_pmt_xmit=0;
  int frame_ctr_tpc_xmit=0;
  int frame_ctr_trigger=0;

  int event_ctr_pmt_xmit=0;
  int event_ctr_tpc_xmit=0;
  int event_ctr_trigger=0;

  int read_ctr_pmt_xmit=0;
  int read_ctr_tpc_xmit=0;

  static int pmt_nublock[20];
  static int tpc_nublock[20];
  for(i=0; i<20; ++i) {
    pmt_nublock[i]=0;
    tpc_nublock[i]=0;
  }

  
  if(hDevTPC){
    // TPC FEM STATUS
    printf(" *****\033[95m Slow Ctrl Monitoring: \033[93mTPC-FEM Status Info \033[00m*****\n");
    printf(" module: b-err1: b-err2: pll   : snmem : bmmem : header: data  : r-pll : l-pll : r-dpa : l-dpa : r-cmd : l-cmd : r-done: l-done\n");
    for(imod_fem_tpc = imod_fem_tpc_start; imod_fem_tpc <= imod_fem_tpc_end; imod_fem_tpc++) {
      
      nword = 2;
      i = pcie_rec(hDevTPC,0,1,nword,iprint,py);     // init the receiver
      //
      imod=imod_fem_tpc;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
      i=1;
      k=1;
      i = pcie_send(hDevTPC, i, k, px);
      //     scanf("%d", &i);
      usleep(10);
      py = &read_array;
      read_array[0] =0;
      i = pcie_rec(hDevTPC,0,2,nword,iprint,py);     // read out 2 32 bits words
      usleep(10);
      printf(" %-5d : %-5d : %-5d : %-5d : %-5d : %-5d : %-5d : %-5d : %-5d : %-5d : %-5d : %-5d : %-5d : %-5d : %-5d : %-5d",
	     ((read_array[0]>>11) & 0x1f),
	     ((read_array[0]>>20) & 0x1),
	     ((read_array[0]>>19) & 0x1),
	     ((read_array[0]>>21) & 0x1),	   
	     ((read_array[0]>>22) & 0x1),
	     ((read_array[0]>>23) & 0x1),
	     ((read_array[0]>>31) & 0x1),
	     ((read_array[0]>>30) & 0x1),
	     ((read_array[0]>>24) & 0x1),
	     ((read_array[0]>>25) & 0x1),
	     ((read_array[0]>>17) & 0x1),
	     ((read_array[0]>>18) & 0x1),
	     ((read_array[0]>>26) & 0x1),
	     ((read_array[0]>>27) & 0x1),
	     ((read_array[0]>>28) & 0x1),
	     ((read_array[0]>>29) & 0x1));
      if( //((read_array[0]>>20) & 0x1) != 0 ||
	  ((read_array[0]>>19) & 0x1) != 0 ||
	  ((read_array[0]>>21) & 0x1) != 1 ||
	  ((read_array[0]>>22) & 0x1) != 1 ||
	  ((read_array[0]>>23) & 0x1) != 1 ||
	  //((read_array[0]>>31) & 0x1) != 1 ||
	  //((read_array[0]>>30) & 0x1) != 1 ||
	  ((read_array[0]>>24) & 0x1) != 1 ||
	  ((read_array[0]>>25) & 0x1) != 1 ||
	  ((read_array[0]>>17) & 0x1) != 1 ||
	  ((read_array[0]>>18) & 0x1) != 1 ||
	  ((read_array[0]>>26) & 0x1) != 1 ||
	  ((read_array[0]>>28) & 0x1) != 1 ||
	  ((read_array[0]>>27) & 0x1) != 1 || 
	  ((read_array[0]>>29) & 0x1) != 1 ) {
	  //((read_array[0]>>26) & 0x1) != ((read_array[0]>>28) & 0x1) ||
	  //((read_array[0]>>27) & 0x1) != ((read_array[0]>>29) & 0x1) ) {
	printf(" ... \033[93m CHECK!!!\033[00m\n");
	sum_status_tpc_fem++;
      }
      else printf("\n");

      if( ((read_array[0]>>31) & 0x1) != 1 )
	num_tpc_fem_header_nonempty++;
      if( ((read_array[0]>>30) & 0x1) != 1 )
	num_tpc_fem_data_nonempty++;
      //
      
      printf(" ***** Slow Ctrl Monitoring: TPC-FEM Status Info *****\n");
      printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
      printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
      printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
      printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
      printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
      printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
      printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
      printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
      printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
      printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
      printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
      printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
      printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
      printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
      printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
      printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));
    }
    printf("\n");
    
    // TPC FEM NU/SN BUFFER
    printf(" *****\033[95m Slow Ctrl Monitoring: \033[93mTPC-FEM NU/SN-Buffer Info \033[00m*****\n");
    printf(" nu-mod   : nu-word  : nu-block : sn-mod   : sn-word  : sn-block\n");
    for(imod_fem_tpc = imod_fem_tpc_start; imod_fem_tpc <= imod_fem_tpc_end; imod_fem_tpc++) {
      nword =2 ;
      i = pcie_rec(hDevTPC,0,1,nword,iprint,py);     // init the receiver
      imod=imod_fem_tpc;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_a_buf_status+(0x0<<16);  // read out status
      i=1;
      k=1;
      i = pcie_send(hDevTPC, i, k, px);
      py = &read_array;
      usleep(10);
      i = pcie_rec(hDevTPC,0,2,nword,iprint,py);     // read out 2 32 bits words
      printf(" %-8d :",((read_array[0]>>11) & 0x1f));
      if((((read_array[1] >> 16) & 0xffff)+ ((read_array[1] & 0xff)<< 16))){
	printf("\033[93m %-8d : %-8d\033[00m :",
	       (((read_array[1] >> 16) & 0xffff)+ ((read_array[1] & 0xff)<< 16)),
	       ((read_array[1]>>8) &0xff));
	num_tpc_fem_buf_nonempty++;
      }
      else
	printf(" %-8d : %-8d :",
	       (((read_array[1] >> 16) & 0xffff)+ ((read_array[1] & 0xff)<< 16)),
	       ((read_array[1]>>8) &0xff));
      tpc_nublock[(int)((read_array[0]>>11) & 0x1f)] = ((read_array[1]>>8) &0xff);
      
	printf(" ***** Slow Ctrl Monitoring: TPC-FEM NU-Buffer Status Info *****\n");
	printf("    Neutrino buffer status word = %x, %x \n", read_array[0], read_array[1]);
	printf("    module addres %d, command %d \n",((read_array[0]>>11) & 0x1f) ,(read_array[0] & 0xff));
	i = (((read_array[1] >> 16) & 0xffff)+ ((read_array[1] & 0xff)<< 16));
	printf("    Neutrino uword = %x, Neutrino ublock = %x \n", i, ((read_array[1]>>8) &0xff));
	printf("\n");  
      
      nword = 2;
      i = pcie_rec(hDevTPC,0,1,nword,iprint,py);     // init the receiver
      
      imod=imod_fem_tpc;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_b_buf_status+(0x0<<16);  // read out status
      i=1;
      k=1;
      i = pcie_send(hDevTPC, i, k, px);
      usleep(10);
      py = &read_array;
      printf(" %-8d :",((read_array[0]>>11) & 0x1f));
      if((((read_array[1] >> 16) & 0xffff)+ ((read_array[1] & 0xff)<< 16)))
	printf("\033[93m %-8d : %-8d\033[00m \n",
	       (((read_array[1] >> 16) & 0xffff)+ ((read_array[1] & 0xff)<< 16)),
	       ((read_array[1]>>8) &0xff));
      else
	printf(" %-8d : %-8d \n",
	       (((read_array[1] >> 16) & 0xffff)+ ((read_array[1] & 0xff)<< 16)),
	       ((read_array[1]>>8) &0xff));
      
	printf(" ***** Slow Ctrl Monitoring: TPC-FEM SN-Buffer Status Info *****\n");
	printf("    SuperNova buffer status word = %x, %x \n", read_array[0], read_array[1]);
	printf("    module addres %d, command %d \n",((read_array[0]>>11) & 0x1f) ,(read_array[0] & 0xff));
	i = (((read_array[1] >> 16) & 0xffff)+ ((read_array[1] & 0xff)<< 16));
	printf("    SuperNova uword = %x, SuperNova ublock = %x \n", i, ((read_array[1]>>8) &0xff));
	printf("\n");
    }
    printf("\n");
    
    // TPC XMIT STATUS
    nword =1 ;
    i = pcie_rec(hDevTPC,0,1,nword,iprint,py);     // init the receiver
    imod=imod_xmit_tpc;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_rdstatus+(0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send(hDevTPC, i, k, px);
    usleep(10);
    py = &read_array;
    i = pcie_rec(hDevTPC,0,2,nword,iprint,py);     // read out 2 32 bits words
    i = (read_array[0] >> 16);
    printf(" *****\033[95m Slow Ctrl Monitoring: \033[93mTPC-XMIT Status Info \033[00m*****\n");  
    printf(" a-err1 : a-err2 : t-err1 : t-err2 : nu-op1 : nu-op2 : sn-op1 : sn-op2 : nu-busy: sn-busy: nu-lock: sn-lock: dpa : rec : pll\n");
    printf(" %-6d : %-6d : %-6d : %-6d : %-6d : %-6d : %-6d : %-6d : %-6d : %-6d : %-6d : %-6d : %-3d : %-3d : %-3d",
	   ((i >> 14) &0x1),
	   ((i >> 15) &0x1),
	   ((i >> 12) &0x1),
	   ((i >> 13) &0x1),
	   ((i >> 11) &0x1),
	   ((i >> 10) &0x1),
	   ((i >> 9) &0x1),
	   ((i >> 8) &0x1),
	   ((i >> 7) &0x1),
	   ((i >> 6) &0x1),
	   ((i >> 3) &0x1),
	   ((i >> 4) &0x1),
	   ((i >> 2) &0x1),
	   ((i >> 1) &0x1),
	   (i &0x1));
    if( ((i >> 14) &0x1) != 0 ||
	((i >> 15) &0x1) != 0 ||
	((i >> 12) &0x1) != 0 ||
	((i >> 13) &0x1) != 0 ||
	((i >> 11) &0x1) != 1 ||
	((i >> 10) &0x1) != 1 ||
	//((i >> 9) &0x1)  != 1 ||
	//((i >> 8) &0x1)  != 1 ||
	((i >> 7) &0x1)  != 0 ||
	((i >> 6) &0x1)  != 0 ||
	((i >> 3) &0x1)  != 1 ||
	((i >> 4) &0x1)  != 1 ||
	((i >> 2) &0x1)  != 1 ||
	((i >> 1) &0x1)  != 1 ||
	(i &0x1) != 1) {
      printf(" ... \033[93m CHECK!!!\033[00m\n");
      sum_status_tpc_xmit++;
    }
    else
      printf("\n");
    
      printf(" ***** Slow Ctrl Monitoring: TPC-XMIT Readout Status Info *****\n");
      printf("    buffer status word = %x\n", read_array[0]);
      printf("    crate %d, header %x \n",(read_array[0] & 0x1f) ,((read_array[0] >> 8) & 0xff));
      i = (read_array[0] >> 16);
      printf("    alignment 2 error  %d \n", ((i >> 15) &0x1));
      printf("    alignment 1 error  %d \n", ((i >> 14) &0x1));
      printf("    time 2 error       %d \n", ((i >> 13) &0x1));
      printf("    time 1 error       %d \n", ((i >> 12) &0x1));
      printf("    opt 1 status Neu   %d \n", ((i >> 11) &0x1));
      printf("    opt 2 status Neu   %d \n", ((i >> 10) &0x1));
      printf("    opt 1 status Super %d \n", ((i >> 9) &0x1));
      printf("    opt 2 status Super %d \n", ((i >> 8) &0x1));
      printf("    busy neutrino      %d \n", ((i >> 7) &0x1));
      printf("    busy SuperNova     %d \n", ((i >> 6) &0x1));
      printf("    xmit Super locked  %d \n", ((i >> 4) &0x1));
      printf("    xmit Neu locked    %d \n", ((i >> 3) &0x1));
      printf("    DPA locked         %d \n", ((i >> 2) &0x1));
      printf("    receiver locked    %d \n", ((i >> 1) &0x1));
      printf("    PLL locked         %d \n", (i &0x1));
    printf("\n");
    
    // TPC XMIT COUNTER
    i = pcie_rec(hDevTPC,0,1,nword,iprint,py);     // init the receiver
    imod=imod_xmit_tpc;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_rdcounters+(0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send(hDevTPC, i, k, px);
    py = &read_array;
    usleep(100);
    i = pcie_rec(hDevTPC,0,2,nword,iprint,py);     // read out 2 32 bits words
    
    printf(" ***** \033[95mSlow Ctrl Monitoring: \033[93mTPC-XMIT Counter Info \033[00m*****\n");
    //printf("    buffer status word = %x, %x, %x, %x, %x\n", read_array[0], read_array[1],
    //read_array[2], read_array[3], read_array[4]);
    //printf("    crate %d, header %x \n",(read_array[0] & 0x1f) ,((read_array[0] >> 8) & 0xff));
    printf("  frame count %d \n", read_array[1]);
    printf("  event count %d \n", read_array[2]);
    printf("  neutrino read count %d \n", read_array[3]);
    printf("  supernova read count %d \n", read_array[4]);
    printf("\n");

    frame_ctr_tpc_xmit = read_array[1];
    event_ctr_tpc_xmit = read_array[2];
    read_ctr_tpc_xmit = read_array[3];
  }


  // Check consistency
  int frame_diff_pmt_tpc = 0;
  int frame_diff_pmt_trg = 0;
  int frame_diff_tpc_trg = 0;
  int read_lag_pmt_xmit  = 0;
  int read_lag_tpc_xmit  = 0;
  int event_diff_pmt_tpc = 0;
  int event_diff_pmt_trg = 0;
  int event_diff_tpc_trg = 0;
  if(frame_ctr_pmt_xmit && frame_ctr_tpc_xmit){
    frame_diff_pmt_tpc = frame_ctr_pmt_xmit - frame_ctr_tpc_xmit;
    event_diff_pmt_tpc = event_ctr_pmt_xmit - event_ctr_tpc_xmit;
  }
  if(frame_ctr_pmt_xmit && frame_ctr_trigger){
    frame_diff_pmt_trg = frame_ctr_pmt_xmit - frame_ctr_trigger;
    event_diff_pmt_trg = event_ctr_pmt_xmit - event_ctr_trigger;
  }
  if(frame_ctr_tpc_xmit && frame_ctr_trigger) {
    frame_diff_tpc_trg = frame_ctr_tpc_xmit - frame_ctr_trigger;
    event_diff_tpc_trg = event_ctr_tpc_xmit - event_ctr_trigger;
  }

  if(frame_ctr_pmt_xmit)
    read_lag_pmt_xmit = event_ctr_pmt_xmit - read_ctr_pmt_xmit;
  if(frame_ctr_tpc_xmit)
    read_lag_tpc_xmit = event_ctr_tpc_xmit - read_ctr_tpc_xmit;

  // give out INFO
  printf("\033[1;35;40m[ Status Check Ends...   ]\033[00m\n");
  if(num_pmt_fem_buf_nonempty)
    printf("\033[5;1;35;40m[ INFO ]\033[00m %d PMT FEM with non-empty buffer...\n",num_pmt_fem_buf_nonempty);
  if(num_pmt_fem_header_nonempty)
    printf("\033[5;1;35;40m[ INFO ]\033[00m %d PMT FEM with non-empty header...\n",num_pmt_fem_header_nonempty);
  if(num_pmt_fem_data_nonempty)
    printf("\033[5;1;35;40m[ INFO ]\033[00m %d PMT FEM with non-empty data...\n",num_pmt_fem_data_nonempty);

  if(num_tpc_fem_buf_nonempty)
    printf("\033[5;1;35;40m[ INFO ]\033[00m %d TPC FEM with non-empty buffer...\n",num_tpc_fem_buf_nonempty);
  if(num_tpc_fem_header_nonempty)
    printf("\033[5;1;35;40m[ INFO ]\033[00m %d TPC FEM with non-empty header...\n",num_tpc_fem_header_nonempty);
  if(num_tpc_fem_data_nonempty)
    printf("\033[5;1;35;40m[ INFO ]\033[00m %d TPC FEM with non-empty data...\n",num_tpc_fem_data_nonempty);

  if(frame_diff_pmt_tpc && frame_diff_pmt_tpc<10 && frame_diff_pmt_tpc>-10)
    printf("\033[5;1;35;40m[ INFO ]\033[00m Frame count mismatch (PMT-TPC XMIT) %d \n",frame_diff_pmt_tpc);
  if(frame_diff_pmt_tpc && frame_diff_pmt_trg<10 && frame_diff_pmt_trg>-10)
    printf("\033[5;1;35;40m[ INFO ]\033[00m Frame count mismatch (PMT XMIT - Trigger) %d \n",frame_diff_pmt_trg);
  if(frame_diff_tpc_trg && frame_diff_tpc_trg<10 && frame_diff_tpc_trg>-10)
    printf("\033[5;1;35;40m[ INFO ]\033[00m Frame count mismatch (TPC XMIT - Trigger) %d \n",frame_diff_tpc_trg);

  if(read_lag_pmt_xmit && read_lag_pmt_xmit<5)
    printf("\033[5;1;35;40m[ INFO ]\033[00m PMT XMIT read lag (behind by %d events) \n",read_lag_pmt_xmit);  
  if(read_lag_tpc_xmit && read_lag_tpc_xmit<5)
    printf("\033[5;1;35;40m[ INFO ]\033[00m TPC XMIT read lag (behind by %d events) \n",read_lag_tpc_xmit);

  if(event_diff_pmt_tpc && event_diff_pmt_tpc < 5 && event_diff_pmt_tpc > -5)
    printf("\033[5;1;35;40m[ INFO ]\033[00m PMT-TPC XMIT event count diff: %d \n",event_diff_pmt_tpc);
  if(event_diff_pmt_trg && event_diff_pmt_trg < 5 && event_diff_pmt_trg > -5)
    printf("\033[5;1;35;40m[ INFO ]\033[00m PMT XMIT - Trigger event count diff: %d \n",event_diff_pmt_trg);
  if(event_diff_tpc_trg && event_diff_tpc_trg < 5 && event_diff_tpc_trg > -5)
    printf("\033[5;1;35;40m[ INFO ]\033[00m TPC XMIT - Trigger event count diff: %d \n",event_diff_tpc_trg);

  // give out EXCEPTION
  int status_return_code = 0;

  // nublock
  for(i=0; i<20; ++i) {
    if(pmt_nublock[i]>=20) {
      printf("\033[5;1;33;41m[ EXCEPTION ]\033[00m PMT module %d nu-block %d \n",i,pmt_nublock[i]);
      status_return_code+=1;
    }
    if(tpc_nublock[i]>=20) {
      printf("\033[5;1;33;41m[ EXCEPTION ]\033[00m TPC module %d nu-block %d \n",i,tpc_nublock[i]);
      status_return_code+=1;
    }
  }

  // Frame diff
  if(frame_diff_pmt_tpc && frame_diff_pmt_tpc>=10 && frame_diff_pmt_tpc<=-10) {
    printf("\033[5;1;33;41m[ EXCEPTION ]\033[00m Large frame count mismatch (PMT-TPC XMIT) %d \n",frame_diff_pmt_tpc);
    //status_return_code++;
  }
  if(frame_diff_pmt_trg && frame_diff_pmt_trg>=10 && frame_diff_pmt_trg<=-10) {
    printf("\033[5;1;33;41m[ EXCEPTION ]\033[00m Large frame count mismatch (PMT XMIT - Trigger) %d \n",frame_diff_pmt_trg);
    status_return_code++;
  }
  if(frame_diff_tpc_trg && frame_diff_tpc_trg>=10 && frame_diff_tpc_trg<=-10) {
    printf("\033[5;1;33;41m[ EXCEPTION ]\033[00m Large frame count mismatch (TPC XMIT - Trigger) %d \n",frame_diff_tpc_trg);
    //status_return_code++;
  }

  // Read lag
  if(read_lag_pmt_xmit && read_lag_pmt_xmit>=5) {
    printf("\033[5;1;33;41m[ EXCEPTION ]\033[00m PMT XMIT read lag too large (behind by %d events) \n",read_lag_pmt_xmit);
    status_return_code++;
  }
  if(read_lag_tpc_xmit && read_lag_tpc_xmit>=5) {
    printf("\033[5;1;33;41m[ EXCEPTION ]\033[00m TPC XMIT read lag too large (behind by %d events) \n",read_lag_tpc_xmit);
    status_return_code++;
  }

  // Event diff
  if(event_diff_pmt_tpc && event_diff_pmt_tpc >= 5 && event_diff_pmt_tpc <= -5) {
    printf("\033[5;1;33;41m[ EXCEPTION ]\033[00m PMT-TPC XMIT event count diff too large:%d \n",event_diff_pmt_tpc);
    status_return_code++;
  }
  if(event_diff_pmt_trg && event_diff_pmt_trg >= 5 && event_diff_pmt_trg <= -5) {
    printf("\033[5;1;33;41m[ EXCEPTION ]\033[00m PMT TPC XMIT - Trigger event count diff too large:%d \n",event_diff_pmt_trg);
    status_return_code++;
  }
  if(event_diff_tpc_trg && event_diff_tpc_trg >= 5 && event_diff_tpc_trg <= -5) {
    printf("\033[5;1;33;41m[ EXCEPTION ]\033[00m TPC TPC XMIT - Trigger event count diff too large:%d \n",event_diff_tpc_trg);
    status_return_code++;
  }

  // Status
  if(sum_status_pmt_fem || sum_status_tpc_fem || sum_status_pmt_xmit || sum_status_tpc_xmit) {
    if(sum_status_pmt_fem)
      printf("\033[5;1;33;41m[ EXCEPTION ]\033[00m %d PMT-FEM have bad status...\n",sum_status_pmt_fem);
    if(sum_status_tpc_fem)
      printf("\033[5;1;33;41m[ EXCEPTION ]\033[00m %d TPC-FEM have bad status...\n",sum_status_tpc_fem);
    if(sum_status_pmt_xmit)
      printf("\033[5;1;33;41m[ EXCEPTION ]\033[00m %d PMT-XMIT bad status...\n",sum_status_pmt_xmit);
    if(sum_status_tpc_xmit)
      printf("\033[5;1;33;41m[ EXCEPTION ]\033[00m %d TPC-XMIT bad status...\n",sum_status_tpc_xmit);
    status_return_code += 1;
  }

  if(!status_return_code)
    printf("\033[1;32;40m[ GOOD STATUS  ] \033[00m\n");
  else
    printf("\033[1;31;43m[ *BAD* STATUS ] \033[00m\n");

          


  //
  // CHECK ENDS
  //
  return 0;
  //return status_return_code;
}

